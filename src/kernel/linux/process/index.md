# 进程管理
进程是操作系统对一个独立执行的任务的管理单元。其代表了一个应用层程序的实例化对象，执行一个应用层的自定义程序。在程序的执行中，系统将为进程分配 CPU 资源，并为程序许诺一个独立而广阔的虚拟内存空间，供程序使用。

进程的内存是操作系统许诺的一个虚假空间，分为两个部分，一部分是内核空间，一部分是用户空间，内核空间预先存放了操作系统为用户提供过的一些数据和信息，用户的代码和数据存放在用户空间，用户可以在自己的空间中执行程序，同时也可以调用内核空间中的函数，从而进入内核态，使用内核提供的 API 执行更加底层的操作，包括：IO 操作，硬件控制，系统控制等等。

## 进程加载

当一个程序被执行时：
1. 将程序的 ELF 文件（Executable and Linkable Format）内容加载到内存中
2. 分配到进程的虚拟地址空间中的相应位置（位置分配由编译器决定）
3. 操作系统为进程创建页表，维护虚拟内存到物理内存的映射逻辑

## 并发和并行

## 阻塞和空转

从操作系统层面，当进程调用阻塞式系统调用时：
1. 进程进入阻塞状态
2. 操作系统不会把CPU的时间片分配给这个进程
3. 直到调用结束，进程从阻塞状态重新进入执行状态

常见的阻塞式调用包括：

1. 进程调度和中断
   - 进程本身的调度和中断机制通过阻塞方式实现
   - 这个过程对于进程自身来说是无感知的

2. 阻塞式IO调用
   ```c
   // 阻塞式函数
   read(), write(), sleep(), wait()
   ```

3. 锁和同步机制
   - 互斥锁（Mutex）
   - 信号量（Semaphore）
   ```c
   // 线程互斥锁
   pthread_mutex_t mutex;
   pthread_cond_t cond;

   pthread_mutex_init(&mutex, NULL);
   // 尝试获取互斥锁，如果无法获取则进入阻塞状态
   pthread_mutex_lock(&mutex);
   // 开始访问被保护的资源
   // ...
   // 释放锁
   pthread_mutex_unlock(&mutex);

   // 信号量
   sem_t sem;
   sem_init(&sem, 0, 0); // 初始化信号量为0
   sem_wait(&sem); // 等待信号量
   ```

与阻塞不同，空转指的是进程进入无意义的空循环状态，可能通过不断检查条件来等待某个条件的达成。这可能是程序bug或刻意设计。在这种状态下，进程处于正常执行状态但不执行有用逻辑，导致CPU浪费。

> 死锁时，锁住的两个或多个进程会被阻塞，然后被操作系统挂起，CPU占用为0，这是典型的死锁特征。

## 进程间通信（IPC）

进程是操作系统提供给上层的虚拟容器，为程序运行提供隔离和保护。容器之间需要交互，交互方式由操作系统提供相应的系统调用实现。

### 基于内存的通信

1. 信号
   ```c
   sigprocmask()
   ```
   - 信号是一种软件软中断机制
   - 为进程提供响应外界发送单向数据的机制
   - 进程可以实现对特定信号的响应逻辑
   - 类似于事件的概念
   - 信号的回调函数是异步的，最好是可重入的

   信号处理流程：
   - 信号发送：操作系统生成信号并发送给目标进程
   - 信号接收和处理：进程接收信号，执行信号处理程序
   - 默认行为：
     * 终止进程（如SIGKILL、SIGTERM）
     * 暂停进程（如SIGSTOP）
     * 忽略信号（如SIGCHLD）
     * 继续执行（如SIGCONT）

2. 管道
   ```c
   pipe()
   mkfifo()
   ```
   - 单向管道（匿名管道）：主要用于父子进程间通信，数据流是单向的
   - 双向管道（命名管道）：支持无父子关系的进程间通信

3. 消息队列
   ```c
   msgget()
   msgsnd()
   msgrcv()
   ```
   - 在内核中维护的队列，用于存储进程间交换的消息
   - 支持消息的异步传输
   - 消息在队列中按顺序排列
   - 支持优先级
   - 提供良好的可靠性和同步机制

4. 信号量（Semaphore）
   - 用于控制多个进程对共享资源访问的同步机制
   - 用于进程间的互斥和同步
   - 类型：
     * 二值信号量（互斥锁）：值只有0和1
     * 计数信号量：值可以是非负整数，表示资源剩余数量

5. 共享内存
   ```c
   shm_open()
   ```
   - 多个进程可以同时访问共享内存
   - 通常需要使用互斥量或信号量进行同步
   - 适合大量、快速的进程间数据共享

### 基于IO的通信

1. 套接字（Socket）
   - 满足跨主机的通信
   - 特别适合通过网络或专用线路通信

2. eventfd
   - 用于进程或线程间通信
   - 支持用户态和内核态之间通信

3. 磁盘文件


## 内存结构
