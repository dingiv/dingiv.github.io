# 阻塞

阻塞、空转、死锁
- **阻塞**：进程因等待 I/O、锁、信号量等进入阻塞状态，CPU 时间片被让出。
- **空转**：进程处于无意义的循环等待，浪费 CPU 资源，常见于设计缺陷或 bug。
 
从操作系统层面，当进程调用阻塞式系统调用时：
1. 进程进入阻塞状态
2. 操作系统不会把 CPU 的时间片分配给这个进程
3. 直到调用结束，进程从阻塞状态重新进入执行状态

常见的阻塞式调用包括：
1. 进程调度和中断
   - 进程本身的调度和中断机制通过阻塞方式实现
   - 这个过程对于进程自身来说是无感知的
2. 阻塞式 IO 调用
   ```c
   // 阻塞式函数
   read(), write(), sleep(), wait()
   ```
3. 锁和同步机制
   - 互斥锁（Mutex）
   - 信号量（Semaphore）

   ```c
   // 线程互斥锁
   pthread_mutex_t mutex;
   pthread_cond_t cond;

   pthread_mutex_init(&mutex, NULL);
   // 尝试获取互斥锁，如果无法获取则进入阻塞状态
   pthread_mutex_lock(&mutex);
   // 开始访问被保护的资源
   // ...
   // 释放锁
   pthread_mutex_unlock(&mutex);

   // 信号量
   sem_t sem;
   sem_init(&sem, 0, 0); // 初始化信号量为0
   sem_wait(&sem); // 等待信号量
   ```

与阻塞不同，空转指的是进程进入无意义的空循环状态，可能通过不断检查条件来等待某个条件的达成。这可能是程序 bug 或刻意设计。在这种状态下，进程处于正常执行状态但不执行有用逻辑，导致 CPU 浪费。

死锁时，锁住的两个或多个进程会被阻塞，然后被操作系统挂起，CPU 占用为 0，这是典型的死锁特征。
