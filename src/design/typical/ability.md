---
title: 质量属性
order: 0
---

# 软件设计质量属性
软件工程的本质是管理复杂性。随着数字系统规模的指数级增长，开发者面临的最大挑战不再是单纯的逻辑实现，而是如何确保代码在不断变化的需求中保持可维护性、可扩展性和可读性。

软件设计质量属性（Software Quality Attributes，又称 -ilities）并非教条式的规则，而是经过数十年工业实践总结出的启发式方法论。它们为架构决策提供科学导航，帮助开发团队规避隐性技术债务，防止代码腐化，并提升软件系统的整体生命周期价值。

在一个成功的软件系统中，维护成本往往占据总成本的 80% 以上。设计原则通过鼓励代码重用、促进模块间的松耦合以及增强代码的透明度，直接降低了后续维护和功能扩展的成本。

## 核心质量属性体系

### 功能与性能

| 属性     | 定义                                     | 关键指标/实践                    |
| -------- | ---------------------------------------- | -------------------------------- |
| 正确性   |                                          |                                  |
| 效率     | 资源利用率（CPU/内存/网络/存储）         | 利用率<70%、GC暂停、尾延迟       |
| 极限负载 | 系统处理负载增长的能力（用户/数据/流量） | QPS、吞吐量、水平/垂直扩展、分片 |
| 响应性   | 端到端延迟（P50/P95/P99）                | <200ms UI、<50ms API、异步处理   |
| 易用性   | 用户交互直观、学习曲线低                 | NPS、任务完成率、A/B测试         |
| 国际化   | 支持多语言/区域                          | i18n、RTL、时区处理              |

### 代码质量
| 属性     | 定义                   | 关键指标/实践 |
| -------- | ---------------------- | ------------- |
| 可读性   | 代码是否能够被快速读懂 |               |
| 可复用性 |                        |               |

### 可用性与容错

| 属性   | 定义                                               | 关键指标/实践                        |
| ------ | -------------------------------------------------- | ------------------------------------ |
| 健壮性 | 系统在异常输入或环境下持续运行的能力               | 输入校验、熔断降级、错误处理边界测试 |
| 可靠性 | 系统在规定条件下和时间内执行预期功能且无故障的概率 | MTBF、错误率、SLA达标率              |
| 可用性 | 系统正常运行时间比例                               | 99.99%（"four 9s"）、MTBF/MTTR       |
| 恢复性 | 从故障/崩溃中恢复速度                              | RPO/RTO、快照回滚、蓝绿部署          |
| 安全性 | 抵抗攻击、数据保护、可攻击面                       | 零信任、加密、RBAC、OWASP Top10      |

### 演进与变更

| 属性     | 定义                         | 关键指标/实践                            |
| -------- | ---------------------------- | ---------------------------------------- |
| 可维护性 | 修复缺陷、添加功能的难易程度 | 可读性、圈复杂度、代码重复率、模块耦合度 |
| 可扩展性 | 添加新功能而不改核心代码     | 插件系统、接口隔离、事件驱动             |
| 可修改性 | 修改现有功能成本低           | 模块化、SOLID、ADR 记录                  |
| 可移植性 | 跨环境/平台迁移容易          | 容器化、多云支持、标准协议               |

### 操作与部署

| 属性     | 定义                               | 关键指标/实践                        |
| -------- | ---------------------------------- | ------------------------------------ |
| 可测试性 | 代码易于验证和测试的程度           | 单元测试覆盖率、依赖注入、接口抽象   |
| 可观测性 | 通过外部输出推断系统内部状态的能力 | 结构化日志、分布式链路追踪、指标监控 |
| 可部署性 | 快速、安全部署                     | CI/CD、GitOps、无缝升级              |
| 可配置性 | 通过配置调整行为                   | 外部化配置、环境变量、Feature Flags  |
| 互操作性 | 与外部系统集成                     | API 标准（gRPC/REST）、Schema 演进   |

## 按生命周期阶段划分

质量属性也可以按照软件生命周期的不同阶段来划分，这种划分有助于理解不同阶段各方的关注点和责任。

| 阶段 | 主要关注点                             | 典型质量属性（-ilities）                                                               |
| ---- | -------------------------------------- | -------------------------------------------------------------------------------------- |
| 开发 | 内部结构、可修改性、可读性、可测试基础 | 可维护性、可修改性、可测试性、可重用性、可移植性、可扩展性、可读性、模块化、架构一致性 |
| 测试 | 正确性、缺陷发现效率、验证覆盖度       | 可测试性、可靠性、正确性、健壮性、可观测性                                             |
| 运维 | 运行稳定性、故障恢复、监控效率         | 可用性、可靠性、可观测性、可伸缩性、容错性、恢复性、安全性、性能效率、可部署性         |

度量工具
| 阶段 | 典型度量方式 / 实践                                                                        |
| ---- | ------------------------------------------------------------------------------------------ |
| 开发 | 代码审查、SonarQube静态分析、架构决策记录（ADR）、单元测试覆盖率、认知复杂度、耦合/内聚度  |
| 测试 | 测试覆盖率（代码/分支/路径）、缺陷密度、缺陷泄漏率、自动化测试通过率、MTTR（缺陷修复时间） |
| 运维 | SLO/SLI、错误预算、MTBF/MTTR、P99延迟、变更失败率、告警准确率、Chaos工程覆盖               |

### 为什么开发阶段影响最大
缺陷在开发阶段修复成本最低，越往后（测试→上线→生产）成本呈指数增长（业界常见估算：1:10:100甚至更高）。

架构是否分层清晰、是否遵守 SOLID/DDD/整洁架构，直接决定可测试性和可维护性。如果开发阶段就把副作用到处散布、状态到处共享，后续测试几乎不可能写出确定性强的用例，运维也无法快速定位。

可观测性、可测试性等运维阶段关心的属性，必须在开发阶段就设计好。开发阶段的坏决策会让每一次需求变更都变成大手术，测试和运维只能被动救火。

+ 架构选错 → 测试难写、改一处动全局、运维频繁出故障
+ 开发阶段缺乏可测试设计 → 测试用例爆炸、mock困难、 flaky 测试多
+ 开发阶段忽略可观测性 → 故障定位慢、根因难找、反复重启、用户体验差

## 权衡框架

质量属性之间经常存在冲突，需要进行权衡。

### 常见冲突

| 高优先 → 低优先 | 冲突示例                | 缓解策略             |
| --------------- | ----------------------- | -------------------- |
| 可用性          | 增加冗余 → 效率下降     | 自动缩放 + 监控      |
| 可伸缩性        | 分库分表 → 可维护性变差 | CDC + 物化视图       |
| 安全性          | 加密/校验 → 性能下降    | 硬件加速 + 零拷贝    |
| 可测试性        | 依赖注入 → 部署复杂     | 容器 mock + 契约测试 |

### ISO/IEC 25010 标准

ISO 25010 将质量属性分为**产品质量**（功能性、性能、兼容性、安全性等）和**使用质量**（可用性、效率等）。这为系统性地评估和权衡质量属性提供了标准框架。

## 现代实践

### 云原生视角

**12因子App** 扩展了这些质量属性的要求：配置外部化、快速启动、无状态设计、日志流式处理。

**架构决策记录（ADR）**：每个设计都应记录权衡理由，例如"选择 Kafka 提升可用性，但接受更高的延迟"。

**度量工具**：

| 属性群    | 工具示例                             |
| --------- | ------------------------------------ |
| 性能/可用 | Prometheus + Grafana                 |
| 可观测    | OpenTelemetry（traces/metrics/logs） |
| 测试/维护 | SonarQube、Mutation Testing          |
| 安全      | Trivy、Falco                         |

### Shift-left 策略

把质量前移到开发阶段：

- 开发阶段就要写单元测试、契约测试、架构健身函数
- 可观测性优先设计：OpenTelemetry、结构化日志、trace 从开发阶段就内置
- 架构决策显式化：用 ADR 记录每个重要权衡
- 内建质量：CI 包含 lint、静态分析、架构违规检查、测试覆盖门限

## 代码示例

以下 C 代码示例体现了多属性设计思想：

```c
// 模块化设计：可维护+可测试（接口隔离），容错（错误码）
typedef struct {
    int (*init)(void *cfg);         // 可配置
    int (*process)(void *data);     // 纯函数倾向，易测试
    void (*cleanup)(void);
} ModuleOps;

int reliable_module(const ModuleOps *ops, void *cfg) {
    if (!ops || !ops->init) return -EINVAL;  // 健壮性
    int ret = ops->init(cfg);
    if (ret) return ret;                     // 恢复性
    // 核心逻辑：不可变输入，日志副作用隔离
    ret = ops->process(cfg);
    ops->cleanup();
    return ret ? -ret : 0;                   // 一致错误处理，可观测
}
```

这个设计覆盖了 SRP（单一接口）、DIP（ops 抽象）、Fault Tolerance（检查+回滚）等多个原则。
