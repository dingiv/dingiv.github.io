
# SOLID
字母,英文全称,中文名,一句话核心含义,违反时最典型表现
S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能
O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码
L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱
I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法
D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类

单一职责原则 (SRP)
不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。
2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。

开闭原则 (OCP)
软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。
现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。
违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。

里氏替换原则 (LSP)
子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。
最容易踩的坑（Java/TS 常见）：
子类抛出父类没声明的受检异常
子类方法前置条件变严格（父类允许 null，子类不允许）
子类返回值类型收窄（父类返回 Collection，子类返回 List）


接口隔离原则 (ISP)
宁可多个小接口，也不要一个胖接口。
现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。
好处：实现类代码量减少，测试更容易 mock。

依赖倒置原则 (DIP)
最核心的一条，其他几条很多时候都是为它服务的。
高层（业务）不依赖低层（基础设施），都依赖抽象。
现代写法（几乎所有框架默认做法）：
通过构造函数 / Setter 注入接口（依赖注入）
使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析

违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。



**SOLID 原则** 是面向对象设计中最经典的五条指导原则，由 Robert C. Martin（Uncle Bob）提出。目的是写出**易维护、易扩展、低耦合、高内聚**的代码。

| 字母 | 英文全称                        | 中文名          | 一句话核心含义                              | 违反时最典型表现                     |
|------|----------------------------------|------------------|-----------------------------------------------|---------------------------------------|
| S    | Single Responsibility Principle | 单一职责原则    | 一个类/模块只因单一原因而改变                | 一个类改动会影响多个不相关功能       |
| O    | Open-Closed Principle           | 开闭原则        | 对扩展开放，对修改关闭                      | 加新功能必须改已有核心代码           |
| L    | Liskov Substitution Principle   | 里氏替换原则    | 子类能透明替换父类而不破坏程序正确性        | 子类重写方法后行为异常 / 前置条件变弱 |
| I    | Interface Segregation Principle | 接口隔离原则    | 不要强迫客户端依赖它不用的接口              | 实现一个大接口却只用其中两三个方法   |
| D    | Dependency Inversion Principle  | 依赖倒置原则    | 高层模块不依赖低层模块，都依赖抽象          | 业务逻辑直接 new 具体数据库/第三方类 |

### 每条原则最务实的理解 + 现代开发常见场景

1. **单一职责原则 (SRP)**  
   - 不是“一个类只能有一个方法”，而是**一个类只服务于一个变化原因 / 一个业务角色**。  
   - 2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。

2. **开闭原则 (OCP)**  
   - 软件设计终极目标：**新需求主要靠新增代码实现，而不是改旧代码**。  
   - 现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。  
   - 违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。

3. **里氏替换原则 (LSP)**  
   - 子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。  
   - 最容易踩的坑（Java/TS 常见）：  
     - 子类抛出父类没声明的受检异常  
     - 子类方法前置条件变严格（父类允许 null，子类不允许）  
     - 子类返回值类型收窄（父类返回 Collection，子类返回 List）

4. **接口隔离原则 (ISP)**  
   - 宁可多个小接口，也不要一个胖接口。  
   - 现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。  
   - 好处：实现类代码量减少，测试更容易 mock。

5. **依赖倒置原则 (DIP)**  
   - **最核心的一条**，其他几条很多时候都是为它服务的。  
   - 高层（业务）不依赖低层（基础设施），都依赖抽象。  
   - 现代写法（几乎所有框架默认做法）：  
     - 通过构造函数 / Setter 注入接口（依赖注入）  
     - 使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析  
   - 违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。

### 一句话总结 SOLID 的真正价值（2026 年视角）

SOLID 不是让你写更“面向对象”的代码，而是帮你写出**变化成本低、可测试、能长期演进**的代码。

在微服务、云原生、领域驱动设计、函数式+OO 混合的今天，SOLID 仍然是判断一段代码设计质量的**最重要基准**之一。

你现在最想看哪一条原则的详细代码例子？  
- 单一职责（最常违反）  
- 开闭（最难做好）  
- 里氏替换（最容易踩坑）  
- 接口隔离  
- 依赖倒置（最有工程价值）

或者你当前项目里哪个地方感觉违反了 SOLID，想具体讨论？


## SOLID
字母,英文全称,中文名,一句话核心含义,违反时最典型表现
S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能
O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码
L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱
I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法
D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类

单一职责原则 (SRP)
不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。
2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。

开闭原则 (OCP)
软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。
现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。
违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。

里氏替换原则 (LSP)
子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。
最容易踩的坑（Java/TS 常见）：
子类抛出父类没声明的受检异常
子类方法前置条件变严格（父类允许 null，子类不允许）
子类返回值类型收窄（父类返回 Collection，子类返回 List）


接口隔离原则 (ISP)
宁可多个小接口，也不要一个胖接口。
现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。
好处：实现类代码量减少，测试更容易 mock。

依赖倒置原则 (DIP)
最核心的一条，其他几条很多时候都是为它服务的。
高层（业务）不依赖低层（基础设施），都依赖抽象。
现代写法（几乎所有框架默认做法）：
通过构造函数 / Setter 注入接口（依赖注入）
使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析

违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。
