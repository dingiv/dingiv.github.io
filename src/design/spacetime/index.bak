
# 设计原则
软件架构设计是从宏观和微观角度思考软件设计的方式，软件架构的优劣决定了一个软件系统的上限。

冯诺依曼体系下的计算机问题基本就是围绕三个主题来进行的：计算、存储和通信，其中**计算**分析的是如何使用高效快捷的算法求解问题，**存储**分析的是如何将数据进行简洁地存储，同时又能快速地查询，**通信**分析的是计算和存储之间的桥梁通道，如何高吞吐低延迟地获取存储资源。


空间有三个维度，但是我们的软件设计的结构是基于二维的。

控制面和数据面

IO 的本质是变量赋值

依赖解析的本质是图遍历，get 的本质也是图遍历，

 
## 多层级设计视角
软件设计是从微观的代码逻辑到宏观的分布式架构的渐进过程，每个层级都有其独特的核心矛盾和主导思想。理解这些不同层级的理念，有助于我们在合适的场景下选择合适的设计方法。

从代码编写到分布式系统，软件设计可以划分为四个层级，每层关注的焦点和追求的目标截然不同。

### 代码编写层

**核心矛盾**：逻辑的清晰度 vs 开发效率

**主导思想**：语义化与可读性

这一层关注的是变量命名、函数设计、代码组织等微观细节。好的代码应该像自然语言一样流畅，让读者能够迅速理解作者的意图。Clean Code 理论在这里发挥重要作用：函数要短小精悍，命名要见名知意，注释应该解释"为什么"而不是"怎么做"。

防御式编程也是这一层的重要实践，永远不信任外部输入，通过断言和异常处理确保逻辑稳健。

### 程序设计层

**核心矛盾**：需求变更的成本 vs 初始开发的复杂度

**主导思想**：解耦与复用

SOLID 原则、设计模式（GoF）、组合优于继承等理念都在这一层发挥作用。当一个类或模块需要频繁修改时，说明设计的耦合度过高；当多个地方出现相似逻辑时，说明缺少合理的抽象。

这一层的典型实践包括：通过接口隔离降低耦合、通过策略模式消除大量 if-else、通过依赖注入实现可测试性。

### 系统架构层

**核心矛盾**：业务边界的划分 vs 团队协作的成本

**主导思想**：边界与职责

DDD（领域驱动设计）在这里成为主导思想。划定限界上下文（Bounded Context），确保业务逻辑不被技术实现污染，是这一层最关键的决策。同一个"订单"对象，在销售域和物流域的定义可能完全不同，必须通过明确的边界来隔离这些差异。

分层架构、六边形架构、整洁架构等模式都在回答同一个问题：如何让核心业务逻辑与技术基础设施解耦。

### 分布式系统层

**核心矛盾**：网络不可靠 vs 数据一致性 vs 高可用性

**主导思想**：容错与伸缩

CAP 定理揭示了分布式系统的本质困境：在一致性、可用性和分区容错性之间只能三选二。BASE 理论告诉我们，有时应该追求最终一致性而非强一致性。

微服务设计重点关注服务注册、发现、熔断、降级等模式。当系统规模达到一定程度，单点故障不可避免，关键在于如何让故障的影响范围最小化。

## 组件耦合原则

当设计从类级别上升到组件级别时，需要遵循一套新的原则来控制组件间的依赖关系。

### ADP：无环依赖原则

组件依赖图中不应出现环路。如果 A 依赖 B，B 依赖 C，那么 C 绝对不能依赖 A。循环依赖会导致组件无法独立测试和发布，任何变更都可能产生连锁反应。

解决循环依赖的方法通常是引入新的抽象组件，或者通过依赖倒置打破原有的依赖链条。

### SDP：稳定依赖原则

依赖应该指向更稳定的方向。不稳定的组件（易变的）应该依赖稳定的组件（不易变的）。如果一个稳定的组件依赖了一个易变的组件，那么每次易变组件的修改都会迫使稳定组件跟着变化，这违背了稳定性的初衷。

组件的稳定性可以通过"入度依赖数"和"出度依赖数"来衡量：入度越大（被越多组件依赖）、出度越小（依赖越少组件），则组件越稳定。

### SAP：稳定抽象原则

一个组件越稳定，它就应该越抽象。稳定的组件被广泛依赖，不应该频繁变化，因此应该是抽象的接口或基类；不稳定的组件可以频繁变化，因此可以是具体的实现。

这一原则与 SDP 结合，形成了组件设计的指导方针：向着"稳定且抽象"的方向努力，避免"不稳定且具体"的组件。

## 架构模式演进

现代架构模式的发展趋势是：将业务逻辑置于中心，将技术细节置于外围。

### 六边形架构

传统分层架构将系统分为"上层"和"下层"，但六边形架构认为系统应该分为"内部（业务）"和"外部（驱动）"。

业务逻辑（Domain）位于中心，通过"端口（Ports）"与外界通信。数据库、HTTP 接口、消息队列都是外接的"适配器"。换个数据库就像换个插头，不影响核心逻辑。

这种架构的优势在于业务逻辑完全独立于技术实现，可以方便地进行技术栈迁移或添加新的访问渠道。

### 整洁架构

整洁架构是六边形架构的进一步演进，其核心是"依赖规则"：依赖只能从外向内指向。最里面的"实体（Entities）"最稳定，最外面的"框架（Frameworks）"最易变。

这种分层确保了核心业务逻辑不依赖于任何外部细节，无论是数据库、Web 框架还是 UI 库。所有的依赖都指向内部，形成了高度隔离的核心。

### DDD：领域驱动设计

如果说 SOLID 是教我们如何写好一个"类"，那么 DDD 是教我们如何设计一个"复杂的业务系统"。

统一语言（Ubiquitous Language）要求程序员和业务人员用同样的词汇交流，代码里的类名要和业务名词对齐。这种对齐不是简单的命名映射，而是对业务领域的深入理解和建模。

限界上下文（Bounded Context）是 DDD 的核心概念。明确边界，比如"商品"在仓库系统中关注库存，在营销系统中关注价格。用边界来隔离这些不同的含义，避免同一个概念在不同上下文中的混淆。



1. 架构流派：从“分层”到“内外”传统的架构是三层或四层架构（UI -> Service -> DAO），但现代架构更强调**“业务逻辑位于中心，技术细节位于外围”**。① 六边形架构 (Hexagonal Architecture / Ports and Adapters)这是你笔记中 container 和 scope 的高级进阶版。它认为系统不应该分“上下层”，而应该分**“内部（业务）”和“外部（驱动）”**。核心： 业务逻辑（Domain）在中心，通过“端口（Ports）”与外界通信。适配器： 数据库、HTTP 接口、MQ 都是外接的“适配器”。换个数据库就像换个插头，不影响核心逻辑。② 洋葱架构 (Onion Architecture) & 整洁架构 (Clean Architecture)由 Uncle Bob 总结，是六边形架构的演进。核心原则： 依赖规则（Dependency Rule）。依赖只能从外向内指向。最里面的“实体 (Entities)”最稳定，最外面的“框架 (Frameworks)”最易变。2. 战术与战略：DDD (领域驱动设计)如果说 SOLID 是教你如何写好一个“类”，那么 DDD 是教你如何设计一个“复杂的业务系统”。统一语言 (Ubiquitous Language)： 程序员和业务人员必须用同样的词汇交流，代码里的类名要和业务名词对齐。限界上下文 (Bounded Context)： 明确边界。比如“商品”在仓库系统中关注库存，在营销系统中关注价格。DDD 强调用边界来隔离这些不同的含义，这与你的 scope 笔记高度契合。3. 面向对象设计的“内功”：GRASP 原则很多人只知道 SOLID，但其实 GRASP (General Responsibility Assignment Software Patterns) 才是分配职责的“基础手册”。它包含了 9 个基本原则：信息专家 (Information Expert)： 把职责分配给拥有完成该职责所需信息的那个类。创造者 (Creator)： 谁负责创建这个对象？低耦合/高内聚： 评价设计的终极标准。纯虚构 (Pure Fabrication)： 当业务对象里找不到合适的位置放某个逻辑时，虚构一个类（如 Service 或 Utils）。4. 软件工程的“定律” (Philosophical Laws)这些定律不是具体的技术指南，而是对软件开发规律的深刻洞察：定律名称核心观点康威定律 (Conway's Law)组织结构决定系统架构。 如果公司分为前端组和后端组，系统大概率也会被切成前后端。奥卡姆剃刀 (Occam's Razor)如无必要，勿增实体。 简单的设计往往是更好的。帕累托法则 (80/20)80% 的复杂度往往是由 20% 的核心功能引起的。破窗效应 (Broken Windows)如果代码里有一处烂代码没修，很快整个项目的代码都会腐烂。5. 现代实战派：A Philosophy of Software Design这是斯坦福教授 John Ousterhout 提出的理论，他提出了一些挑战传统（如 SOLID）的观点：深模块 vs 浅模块 (Deep vs Shallow Modules)： 好的模块应该是“接口简单，功能强大（深）”。如果一个方法只有两行代码却有很长的接口声明，那就是“浅模块”，会增加认知负担。认知负荷 (Cognitive Load)： 评价设计的唯一标准是：一个新开发者理解这段代码需要多少脑力。

1. 微观层：代码编写 (Coding Level)
核心矛盾： 逻辑的清晰度 vs 开发效率。

主导思想： 语义化与可读性。

经典理论：

Clean Code (整洁代码)： 函数要短小，命名要见名知意。

防御式编程： 永远不信任外部输入，通过断言和异常处理确保逻辑稳健。

注释哲学： 代码解释“怎么做”，注释解释“为什么这么做”。

2. 中观层：单个程序/模块设计 (Design Level)
核心矛盾： 需求变更的成本 vs 初始开发的复杂度。

主导思想： 解耦与复用。

经典理论：

SOLID 原则： 解决类与类之间的耦合。

设计模式 (GoF)： 针对特定场景的“套路”，如观察者模式解决通知问题，工厂模式解决创建问题。

组合优于继承： 通过拼装功能而不是层层继承来构建复杂对象，避免“类爆炸”。

3. 宏观层：系统架构 (Architecture Level)
核心矛盾： 业务边界的划分 vs 团队协作的成本。

主导思想： 边界与职责。

经典理论：

DDD (领域驱动设计)： 划定限界上下文（Bounded Context），确保业务逻辑不被技术实现污染。

分层架构/六边形架构： 确定“业务核”与“技术壳”的依赖关系。

4. 宇观层：分布式系统 (Distributed Systems Level)
核心矛盾： 网络不可靠 vs 数据一致性 vs 极高的可用性。

主导思想： 容错与伸缩。

经典理论：

CAP 定理： 在一致性（C）、可用性（A）、分区容错性（P）之间做取舍。

BASE 理论： 追求最终一致性，而不是强一致性。

微服务设计： 关注服务注册、发现、熔断、降级。

维度,代码编写,程序设计,系统架构,分布式系统
关注点,变量、循环、函数,类、接口、模式,组件、模块、边界,服务、协议、数据流
追求目标,好看、好懂,好改、好测,业务清晰、易扩展,高并发、高可用、容错
失败后果,Bug 多、难调试,牵一发而动全身,业务逻辑混乱,系统宕机、数据丢失、