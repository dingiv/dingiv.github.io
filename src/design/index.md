---
title: 软件设计
order: 20
---

# 软件设计
软件设计的基础意义是根据实际的业务需求编写软件进行实现。但是，在实际的环境中，事情往往没有想象中的那么简单，我们需要额外面临更多考验。

+ 可行性问题，这是最基本的要求，要求软件的实现能够切实解决需求；
+ 成本问题，要求使用尽量低的时间成本、金钱成本；
+ 可维护问题，软件需求持续服役，新增功能、修复 bug、回滚修改等；
+ 质量问题，拥有较好的性能、健壮性、可用性、稳定性；

## 程序结构
常见程序的结构可以分成两种：one-shot 和 deamon；one-shot 程序读取命令行参数后，一下子从前执行到尾，处理完数据后，直接退出程序；而 deamon 程序会在解析完命令行参数和配置文件后进入死循环，并通过阻塞式系统调用监听和等待它感兴趣的下层响应，并在响应发生时被操作系统唤醒，然后执行业务逻辑，除非触发关闭命令或者异常，否则将会按照期望一直运行下去。

```c
// deamon 程序
int main(int argc, char *argv[]) {
  Args* args = parseArgs(argc, argv);

  while(true) {
    // 阻塞式调用，监听客户端的请求
    void* incoming = listen(args);

    // 业务层寻找处理该请求的函数
    void* handler = findHandler(args, incoming);

    // 分发该请求
    void* result = distribute(args, incoming, handler);

    // 响应请求
    response(incoming, result);
  }

  return 0;
}
```

前者，较为简单，略；后者是我们平时编写多数程序的结构，包括前端的 GUI 客户端程序和后端的 server 程序。

### deamon
deamon 程序的结构可以被概括为一个“前中后”三层结构——前端视图层、中间业务层、后端持久层。视图层面向自己的客户端，监听客户端的请求和操作，解析和翻译操作，并将请求的任务分发给中间业务层；中间层负责进行主体复杂逻辑的实现和繁重工作的处理，它在处理业务的过程中可能需要依赖外界的持久化数据，或者将数据进行持久化，它会选择性地调用后端持久层，进行数据持久化的操作；后端持久层通过系统 IO 调用，向进程外发送和获取数据，或是作为数据的直接管理者，代替进程中的其他部分管理数据。

![](./structure.dio.svg)

### 函数
进一步向更小的粒度分析，我们发现，一个程序往往由一个个**子程序**构成，或者直白点，在多数的编程语言中，它叫做**函数**。然而我们需要从更底层的 C 语言和汇编的角度去分析函数是什么？函数是进程的内存空间中的一段数据，它记录的是一段 CPU 可执行的机器指令序列，我们可以告知 CPU 这段内存中的数据是指令，并应当读取并执行它；同时，在执行之前，可以携带一定的指针，指向一些数据，并要求令这些数据作为函数执行时的一部分上下文，函数在执行期间，可以访问他们，最后函数应当将处理数据的结果，保留到一个指定的 Return 指针中进行返回，让函数的调用者能够通过调用函数进行自己想要的数据和结果。这个过程可以被抽象成一个管道，它从进口端接受一些数据，并使用这些数据进行计算，产生一个返回值，并从管道的出口端返回。

函数有如下几个重要特点：
+ 函数嵌套调用，函数内部可以调用另一个函数，从而形成嵌套，大大减少重复代码的书写；为了实现这个特性，大多数的编译器采用**调用栈**来实现；
+ 系统调用，系统调用不是用户自己编写的，它存在于进程中，在进程创建的时候就被操作系统一同加载到了进程的内存空间，用户可以直接调用这些函数实现逻辑复用和受限资源的访问；这些函数区别于用户自行实现的函数，他们是系统层提供的 API 接口；

  系统调用有一个特点那就是外界交互。程序期望和外界发生交互，或者说 IO 操作。IO 操作有一个非常大的特点就是，**可能是失败的**，它可能返回一个程序无法处理的结果或者没有结果，那么程序将会就此崩溃，或者是主动退出；
+ 函数复用，函数的目的就是为了复用程序逻辑，避免重复书写相同的代码。

### 作用域
进程从操作系统那里申请一个块巨大的内存空间，它是一个简洁的字节数组，但是却也非常的简陋，我们需要对内存进行划分使用和管理，而不是随意使用，其中一个重要的手段便是**作用域**。作用域是为了**划分和隔离**子程序，拆解问题，提供资源的隔离。

#### 生命周期
我们在一个内存区域中**划分**一小块进行使用，在区域存放了一些数据，然后再区域中进行了一些计算，然后释放和关闭了这个作用域，不同的作用域在不同的时期被展开和闭合，并且彼此之间的数据资源存在一定的隔离性。作用域需要程序设计时被**声明**，在运行时依照声明被**展开**；展开时，可以将状态传入一个域，在域展开的过程当中，状态可以被改变，在域使用完毕时，可以将**闭合**，释放资源，同时传出一些状态。此时，作用域完成了它的使命。

#### 父子作用域
我们划分并隔离不同的子程序，但是最后却又要让子程序之间发生交互和数据交换，发生父子嵌套和兄弟并列，这体现了**封装和接口**的思想。父作用域只需调用一个接口，便可以完成一个复杂动作，而无需关系其底层细节。从一定角度看，程序就是**状态 + 作用域**的管理。

作用域可以被分为，全局作用域和局部作用域。
+ 全局作用域中的内容被整个程序可见，并且早于所有局部作用域被展开，晚于所有局部作用域被闭合。全局作用域只有一个。全局作用域是所有作用域的父代。
+ **函数调用产生一个局部作用域**，

在不同的语言中，提供了不同的作用域抽象，拥有更多的层级，包括**模块作用域**、**类作用域**、**块作用域**。但是不管如何，我们需要着重关注的是父作用域和子作用域之间的关系——**父作用域依赖于子作用域**。

+ 当一个作用域依赖于其他作用域的时候，它的功能就受到了别人的影响，为了让这个作用域正常工作，就需要保证它依赖的所有作用域正常工作；
+ 作用域之间的接口应该保持稳定，当接口更变时，需求同时改变依赖者的逻辑；
+ 作用域之间应该避免**循环依赖**，因为循环依赖往往是程序划分不正确的外在体现，或者从哲理的角度讲，循环依赖其实是在解决“蛋生鸡”的问题，但是这是没有办法解决的；
