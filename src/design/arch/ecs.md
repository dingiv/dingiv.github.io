# ECS
ECS（Entity-Component-System）是一种主要用于渲染程序和游戏开发的架构模式，它通过将数据和行为分离来实现高度模块化和可扩展的系统设计。在游戏中，结合渲染引擎的渲染节奏，插空批量执行的游戏逻辑。

+ 模块化：ECS 架构通过将数据和行为分离，实现了高度的模块化设计。基于组合由于继承的思想，组件可以自由组合，系统可以独立开发，这使得添加新功能变得简单直接。开发者可以根据需要灵活地组合不同的组件来创建新的实体类型，而无需修改现有代码。
+ 性能优化：ECS 架构在性能方面具有显著优势。由于组件数据存储在连续的内存空间中，数据局部性好，便于实现缓存友好型代码。这种设计特别适合处理大量相似对象，系统可以高效地遍历和处理相同类型的组件数据，从而提升整体性能。
+ 可维护性：ECS 架构通过关注点分离，使代码结构更加清晰。每个系统只负责处理特定类型的组件，组件只包含数据，系统只包含逻辑，这种清晰的职责划分使得代码易于理解和维护。同时，由于系统和组件的独立性，单元测试也变得更为简单。
+ 灵活性：ECS 架构提供了运行时的高度灵活性。实体可以在运行时动态添加或移除组件，系统可以独立启用或禁用，这使得游戏逻辑可以动态调整。这种灵活性还便于实现热重载功能，开发者可以在不重启游戏的情况下修改和测试代码。

## 核心概念
Entity（实体）
- 实体是游戏世界中的基本单位
- 实体本身不包含任何数据或行为
- 实体只是一个唯一的标识符，用于组合不同的组件
- 例如：玩家、敌人、道具等都可以是实体

Component（组件）
- 组件是纯数据容器
- 每个组件只包含特定类型的数据
- 组件没有行为逻辑
- 常见组件示例：
  - PositionComponent：位置信息
  - HealthComponent：生命值
  - SpriteComponent：精灵/图像
  - CollisionComponent：碰撞信息

System（系统）
- 系统是处理逻辑的地方
- 每个系统负责处理特定类型的组件
- 系统不存储状态，只处理数据
- 常见系统示例：
  - MovementSystem：处理移动
  - RenderingSystem：处理渲染
  - CollisionSystem：处理碰撞检测
  - HealthSystem：处理生命值变化

## 对比 MVC

+ 并行性：ECS 是针对于 MVC 架构中，中间业务处理层的*并行性不够和批量化处理能力不够*的现实情况提出的业务处理模式。ECS 可以通过 System 抽象，将不同类型的业务进行并行化逻辑，提高了 CPU 的利用率。
+ 批量化：ECS 与渲染程序的渲染节奏更加契合。渲染程序会采用一定的渲染节奏，每隔一段时间，触发一次批量化的业务逻辑计算，再进行画面的更新，而不是像 MVC 程序，例如 web server 那样，一旦接受到新的 IO 任务就开始一次业务分发和处理。这将有效提高程序在大规模 IO 事件和批量化任务面前的吞吐能力，但是在一定程度上引入了延迟，这也是为什么 server 程序不采用 ECS 的原因。

> 掉帧：ECS 可以极大地提高一次渲染循环中的业务处理计算量，但是，如果开发者在渲染循环中加入了阻塞任务，那么极有可能导致在渲染循环即将到来的下一个周期，还没能够处理完上一个周期的任务，因此错过了本轮的渲染画面更新，从而导致了掉帧的情况。掉帧对于用户来说，表现行为就是画面一卡一卡的。