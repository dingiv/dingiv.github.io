# 设计原则
在软件工程多年的历史发展中，人们积累了丰富的软件设计经验。其中一些经验成为指导后来者的**金科玉律**，但是，时代在发展，过去的经验需要随着时代的变迁进行革新。

## 笔者智选

模块划分
作用域

依赖管理
作用域交互、依赖倒置

状态管理
生命周期、纯函数

## 历史经验

### SOLID

字母,英文全称,中文名,一句话核心含义,违反时最典型表现
S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能
O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码
L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱
I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法
D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类

单一职责原则 (SRP)
不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。
2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。

开闭原则 (OCP)
软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。
现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。
违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。

里氏替换原则 (LSP)
子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。
最容易踩的坑（Java/TS 常见）：
子类抛出父类没声明的受检异常
子类方法前置条件变严格（父类允许 null，子类不允许）
子类返回值类型收窄（父类返回 Collection，子类返回 List）


接口隔离原则 (ISP)
宁可多个小接口，也不要一个胖接口。
现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。
好处：实现类代码量减少，测试更容易 mock。

依赖倒置原则 (DIP)
最核心的一条，其他几条很多时候都是为它服务的。
高层（业务）不依赖低层（基础设施），都依赖抽象。
现代写法（几乎所有框架默认做法）：
通过构造函数 / Setter 注入接口（依赖注入）
使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析

违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。

### DRY

### KISS

### 设计模式

### 函数式范式

## 软件设计指标


可扩展，可观测，可测试，可维护

