---
title: 架构
order: 0
---

# 软件架构
软件架构设计是从宏观角度思考软件设计的方式。软件架构的优劣决定了一个软件系统的上限。

## 单进程程序的结构
从程序的宏观角度看，常见程序的结构可以分成两种：one-shot 和 deamon；one-shot 程序读取命令行参数后，一下子从前执行到尾，处理完数据后，直接退出程序；而 deamon 程序会在解析完命令行参数和配置文件后进入死循环，并通过阻塞式系统调用，监听和等待它感兴趣的下层响应，并在响应发生时被操作系统唤醒，然后执行业务逻辑，除非触发关闭命令或者异常，否则将会按照期望一直运行下去。

```c
// deamon 程序
int main(int argc, char *argv[]) {
   // 读取命令行参数，形成启动参数
  Args *args = parseArgs(argc, argv);
  // 读取配置文件，形成程序配置
  Config *config = read(file);

  while(true) {
　　// 查找配置中的监听任务
    void *event = findTask(args, config);
    if (event == NULL) {
      break;
    }

    // 阻塞式调用，根据配置信息按照要求监听客户端的请求
    void* incoming = listen(args, config);

    // 业务层寻找处理该请求的函数
    void* handler = findHandler(args, config, incoming);

    // 分发该请求
    void* result = distribute(args, config, incoming, handler);

    // 响应请求
    response(incoming, result);
  }

  // 释放程序的所有资源
  cleanAll(args, config);
  return 0;
}

// 清除监听任务的请求处理器
void handleShutdown(Args *args, Config *config, ...) {
   cleanTask(args, config);
}
```

前者，较为简单，略；后者是我们平时编写多数程序的结构，包括前端的 GUI 客户端程序和后端的 server 程序。

## daemon 程序
从纵向来看，程序需要在开始时解析配置和参数，然后进入循环，从配置和参数中寻找需要监听和处理的任务，如果找到了，则根据任务的类型，将具体任务分发给相应的处理函数，得到处理结果，然后把结果返回给客户端，往复循坏。何时停止？当需要监听的事件和任务被处理完了，或者触发了清理监听任务的处理器的时候，由于没有任务，则程序 break 出循环，程序结束。同时，在处理任务的过程中，可能由于监听到了新的事件发生，从而向任务队列中添加了新的任务，也就是任务是可增可减，动态变化的，形如一个**状态机**的结构。

从横向看，deamon 程序的结构可以被概括为一个“前中后”三层结构——前端视图层、中间业务层、后端持久层。视图层面向自己的客户端，监听客户端的请求和操作，解析和翻译操作，并将请求的任务分发给中间业务层；中间层负责进行主体复杂逻辑的实现和繁重工作的处理，它在处理业务的过程中可能需要依赖外界的持久化数据，或者将数据进行持久化，它会选择性地调用后端持久层，进行数据持久化的操作；后端持久层通过系统 IO 调用，向进程外发送和获取数据，或是作为数据的直接管理者，代替进程中的其他部分管理数据。在横向的三层中，必须要保持单向依赖，以简化程序的结构，让层间的功能保持独立。

![](./structure.dio.svg)

## 客户端 daemon 程序
相较于服务端的 server 程序，客户端的 daemon 渲染程序有一个特殊的地方，渲染 daemon 在主循环中加入了**渲染 tick**，主循环针对键盘 IO 等事件不再立即回应（相比 server 程序是立即回应），渲染 daemon 会采用使用计时器来计时，每过一段时间批量处理所有的事件，并结合游戏程序经常采用的 ECS 架构模式，批量并行处理上层业务逻辑，这些上层的业务逻辑通常由 GUI 客户端开发者编写。