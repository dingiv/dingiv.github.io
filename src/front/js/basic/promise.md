# promise
在浏览器的事件循环中，总是先执行同步任务，然后执行异步任务，在异步任务中，回调函数被保存在了多级队列当中，不过可以简单的认为任务被分为两种队列，宏任务队列和微任务队列。每次执行异步任务时，总是先将微队列中的任务执行完毕之后然后再执行宏任务。
```js 
new Promise((s)=>s())  // p0 f0
   .then(res=>'')      // p1 f1
   .then(res=>Promise.resolve()) // p2 f2 pnew
   .then(res=>'')   // p3 f3
```

## 构造函数
构造函数的执行：
1. 先创建一个Promise实例，pending状态
```js
new Promise((s,r)=>{})
```
2.立即执行内部的这个函数，当内部调用`s`时，完成这个Promise；

## then函数——完成时进队
对于一个Promise，可以调用其then方法，并传入一个回调函数。此时其执行顺序为：
1. 新建一个新的Promise（p1），其状态取决于其回调函数（f1）是否执行完毕；
2. 什么时候开始执行回调函数呢？在上一个回调函数完成时，将该回调函数放入微队列中进行等待。此处强调一个非常重要的点，就是**当调用then方法传入了一个回调函数的时候，回调函数还没有进入微队列中，回调函数进入微队列的时机是在当前被then的这个Promise完成的时候。并且就算进了微队列，也不是说回调函数会立即执行，它还需要进行排队才会执行。**
3. 如果回调函数（f2）返回了一个新的Promise（pnew），那么此时该Promise（p2）将不会被完成，即等待该Promise的回调函数（f3）不会在此时进队，取而代之的是，一个匿名的回调函数`()=>pnew.then(()=>'完成p2')`进入了队列当中，那么当执行了该匿名回调之后，`()=>'完成p2'`进队，等待p2完成时，f3才会进队，换言之，f3进队的时机将被推迟两个回调函数。


## 异步函数