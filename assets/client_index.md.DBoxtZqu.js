import{_ as a,o as t,c as r,ah as i}from"./chunks/framework.BvDvRtye.js";const h=JSON.parse('{"title":"客户端","description":"","frontmatter":{"title":"客户端","order":30},"headers":[],"relativePath":"client/index.md","filePath":"client/index.md"}'),l={name:"client/index.md"};function n(o,e,d,s,c,p){return t(),r("div",null,[...e[0]||(e[0]=[i('<h1 id="客户端开发技术" tabindex="-1">客户端开发技术 <a class="header-anchor" href="#客户端开发技术" aria-label="Permalink to “客户端开发技术”">​</a></h1><p>客户端开发通常是指面向普通用户构建可视化图形应用，涵盖了从 Web 网页应用、移动应用、桌面应用、嵌入式 UI 等多种形式，通过图形界面程序的方式，简化用户操作计算机的步骤流程，辅助用户使用计算机高效完成工作等。</p><p>此外，客户端程序还关注于：</p><ul><li>实现流畅的交互体验：实现方便易用是客户端程序的初衷，需要以服务客户为中心</li><li>构建美观的用户界面：用户对视觉效果具有审美需求和好恶，需要借助图形学理论和操作系统视图系统来实现界面美化</li><li>实现跨平台兼容性：用户使用多样的操作系统和终端设备，需要扩大服务的用户群体同时节约开发成本</li><li>确保安全性与隐私保护：客户端程序工作在用户的设备上，需要尊重用户的数据和设备安全</li></ul><h2 id="程序架构" tabindex="-1">程序架构 <a class="header-anchor" href="#程序架构" aria-label="Permalink to “程序架构”">​</a></h2><p>客户端图形界面程序属于 daemon 类程序，但是和 server 程序不同的是，server 监听 TCP socket 的读写，而 daemon 程序监听的是用户的鼠标和键盘等输入设备的事件，同时渲染需要显示的图像，更新到客户端设备的帧缓冲区。</p><p>特殊地，对于渲染工作，存在周期性和计划性的计算动作，为了给用户良好的体验。图形计算是一个耗时工作，而用户的设备又往往性能较差，客户端程序需要合理分配业务逻辑的任务工作量和图形渲染的工作量。并且，不论如何分配，为了保证可交互性，图形的渲染和程序的交互都应当是不可阻塞的。</p><h3 id="渲染模式" tabindex="-1">渲染模式 <a class="header-anchor" href="#渲染模式" aria-label="Permalink to “渲染模式”">​</a></h3><p>GUI 应用的渲染架构分为即时模式和留存模式两种范式。即时模式下，应用程序在每一帧从头描述整个界面，不维护持久的界面对象树，代码逻辑直接对应渲染输出。这种模式的优势在于实现简单、调试直观，开发者能精确控制每次渲染的行为，常见于游戏开发中的 Dear ImGui 和嵌入式系统。但即时模式需要在每次重绘时重新构建界面描述，对于复杂界面的性能开销较大。</p><p>留存模式则维护一个持久的界面对象模型，应用程序通过修改对象属性来触发界面更新，框架负责对象的脏检测与渲染调度。传统桌面开发中的 MFC、Qt，Web 开发中的 DOM、React 虚拟 DOM 都属于留存模式。这种模式将界面状态管理交给框架，开发者只需关注状态变化，框架自动处理脏标记和增量渲染。但留存模式的抽象层级较高，调试时难以追踪状态到渲染的完整链路，且框架本身维护的对象树会占用额外内存。</p>',10)])])}const m=a(l,[["render",n]]);export{h as __pageData,m as default};
