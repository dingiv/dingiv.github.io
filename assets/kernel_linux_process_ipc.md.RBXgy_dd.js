import{_ as l,c as s,o as a,ae as e}from"./chunks/framework.Dgg8-8ov.js";const k=JSON.parse('{"title":"进程间通信","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/process/ipc.md","filePath":"kernel/linux/process/ipc.md"}'),t={name:"kernel/linux/process/ipc.md"};function p(n,i,h,c,o,d){return a(),s("div",null,i[0]||(i[0]=[e(`<h1 id="进程间通信" tabindex="-1">进程间通信 <a class="header-anchor" href="#进程间通信" aria-label="Permalink to &quot;进程间通信&quot;">​</a></h1><p>进程是操作系统提供给上层的虚拟容器，为程序运行提供隔离和保护。容器之间需要交互，交互方式由操作系统提供相应的系统调用实现。</p><h2 id="基于内存的通信" tabindex="-1">基于内存的通信 <a class="header-anchor" href="#基于内存的通信" aria-label="Permalink to &quot;基于内存的通信&quot;">​</a></h2><ol><li><p>信号</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigprocmask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>信号是一种软件软中断机制</li><li>为进程提供响应外界发送单向数据的机制</li><li>进程可以实现对特定信号的响应逻辑</li><li>类似于事件的概念</li><li>信号的回调函数是异步的，最好是可重入的</li></ul><p>信号处理流程：</p><ul><li>信号发送：操作系统生成信号并发送给目标进程</li><li>信号接收和处理：进程接收信号，执行信号处理程序</li><li>默认行为： <ul><li>终止进程（如SIGKILL、SIGTERM）</li><li>暂停进程（如SIGSTOP）</li><li>忽略信号（如SIGCHLD）</li><li>继续执行（如SIGCONT）</li></ul></li></ul></li><li><p>管道</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkfifo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>单向管道（匿名管道）：主要用于父子进程间通信，数据流是单向的</li><li>双向管道（命名管道）：支持无父子关系的进程间通信</li></ul></li><li><p>消息队列</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgsnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgrcv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>在内核中维护的队列，用于存储进程间交换的消息</li><li>支持消息的异步传输</li><li>消息在队列中按顺序排列</li><li>支持优先级</li><li>提供良好的可靠性和同步机制</li></ul></li><li><p>信号量（Semaphore）</p><ul><li>用于控制多个进程对共享资源访问的同步机制</li><li>用于进程间的互斥和同步</li><li>类型： <ul><li>二值信号量（互斥锁）：值只有0和1</li><li>计数信号量：值可以是非负整数，表示资源剩余数量</li></ul></li></ul></li><li><p>共享内存</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shm_open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>多个进程可以同时访问共享内存</li><li>通常需要使用互斥量或信号量进行同步</li><li>适合大量、快速的进程间数据共享</li></ul></li></ol><h2 id="基于文件的通信" tabindex="-1">基于文件的通信 <a class="header-anchor" href="#基于文件的通信" aria-label="Permalink to &quot;基于文件的通信&quot;">​</a></h2><ol><li><p>套接字（Socket）</p><ul><li>满足跨主机的通信</li><li>特别适合通过网络或专用线路通信</li></ul></li><li><p>eventfd</p><ul><li>用于进程或线程间通信</li><li>支持用户态和内核态之间通信</li></ul></li><li><p>磁盘文件</p></li></ol>`,6)]))}const u=l(t,[["render",p]]);export{k as __pageData,u as default};
