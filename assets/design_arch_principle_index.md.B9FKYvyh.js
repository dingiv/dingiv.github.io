import{_ as a,c as i,o as r,ae as t}from"./chunks/framework.CDjunVez.js";const S=JSON.parse('{"title":"设计原则","description":"","frontmatter":{},"headers":[],"relativePath":"design/arch/principle/index.md","filePath":"design/arch/principle/index.md"}'),n={name:"design/arch/principle/index.md"};function o(l,e,s,c,d,h){return r(),i("div",null,[...e[0]||(e[0]=[t('<h1 id="设计原则" tabindex="-1">设计原则 <a class="header-anchor" href="#设计原则" aria-label="Permalink to &quot;设计原则&quot;">​</a></h1><p>在软件工程多年的历史发展中，人们积累了丰富的软件设计经验。其中一些经验成为指导后来者的金科玉律，但是，时代在发展，过去的经验需要随着时代的变迁进行革新。</p><h2 id="历史经验" tabindex="-1">历史经验 <a class="header-anchor" href="#历史经验" aria-label="Permalink to &quot;历史经验&quot;">​</a></h2><h3 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to &quot;SOLID&quot;">​</a></h3><p>字母,英文全称,中文名,一句话核心含义,违反时最典型表现 S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能 O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码 L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱 I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法 D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类</p><p>单一职责原则 (SRP) 不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。 2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。</p><p>开闭原则 (OCP) 软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。 现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。 违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。</p><p>里氏替换原则 (LSP) 子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。 最容易踩的坑（Java/TS 常见）： 子类抛出父类没声明的受检异常 子类方法前置条件变严格（父类允许 null，子类不允许） 子类返回值类型收窄（父类返回 Collection，子类返回 List）</p><p>接口隔离原则 (ISP) 宁可多个小接口，也不要一个胖接口。 现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。 好处：实现类代码量减少，测试更容易 mock。</p><p>依赖倒置原则 (DIP) 最核心的一条，其他几条很多时候都是为它服务的。 高层（业务）不依赖低层（基础设施），都依赖抽象。 现代写法（几乎所有框架默认做法）： 通过构造函数 / Setter 注入接口（依赖注入） 使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析</p><p>违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。</p><h3 id="dry" tabindex="-1">DRY <a class="header-anchor" href="#dry" aria-label="Permalink to &quot;DRY&quot;">​</a></h3><h3 id="kiss" tabindex="-1">KISS <a class="header-anchor" href="#kiss" aria-label="Permalink to &quot;KISS&quot;">​</a></h3><h3 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h3><h3 id="函数式范式" tabindex="-1">函数式范式 <a class="header-anchor" href="#函数式范式" aria-label="Permalink to &quot;函数式范式&quot;">​</a></h3><h2 id="软件设计指标" tabindex="-1">软件设计指标 <a class="header-anchor" href="#软件设计指标" aria-label="Permalink to &quot;软件设计指标&quot;">​</a></h2>',16)])])}const u=a(n,[["render",o]]);export{S as __pageData,u as default};
