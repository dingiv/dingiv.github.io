import{_ as s,c as a,o as l,ae as n}from"./chunks/framework.BtEkjhVd.js";const o=JSON.parse('{"title":"进程管理","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/process/index.md","filePath":"kernel/linux/process/index.md"}'),p={name:"kernel/linux/process/index.md"};function e(t,i,h,k,d,r){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to &quot;进程管理&quot;">​</a></h1><p>进程是操作系统对一个独立执行的任务的管理单元。其代表了一个应用层程序的实例化对象，执行一个应用层的自定义程序。在程序的执行中，系统将为进程分配 CPU 资源，并为程序许诺一个独立而广阔的虚拟内存空间，供程序使用。</p><p>进程的内存是操作系统许诺的一个虚假空间，分为两个部分，一部分是内核空间，一部分是用户空间，内核空间预先存放了操作系统为用户提供过的一些数据和信息，用户的代码和数据存放在用户空间，用户可以在自己的空间中执行程序，同时也可以调用内核空间中的函数，从而进入内核态，使用内核提供的 API 执行更加底层的操作，包括：IO 操作，硬件控制，系统控制等等。</p><h2 id="进程加载" tabindex="-1">进程加载 <a class="header-anchor" href="#进程加载" aria-label="Permalink to &quot;进程加载&quot;">​</a></h2><p>当一个程序被执行时：</p><ol><li>将程序的 ELF 文件（Executable and Linkable Format）内容加载到内存中</li><li>分配到进程的虚拟地址空间中的相应位置（位置分配由编译器决定）</li><li>操作系统为进程创建页表，维护虚拟内存到物理内存的映射逻辑</li></ol><h2 id="并发和并行" tabindex="-1">并发和并行 <a class="header-anchor" href="#并发和并行" aria-label="Permalink to &quot;并发和并行&quot;">​</a></h2><h2 id="阻塞和空转" tabindex="-1">阻塞和空转 <a class="header-anchor" href="#阻塞和空转" aria-label="Permalink to &quot;阻塞和空转&quot;">​</a></h2><p>从操作系统层面，当进程调用阻塞式系统调用时：</p><ol><li>进程进入阻塞状态</li><li>操作系统不会把CPU的时间片分配给这个进程</li><li>直到调用结束，进程从阻塞状态重新进入执行状态</li></ol><p>常见的阻塞式调用包括：</p><ol><li><p>进程调度和中断</p><ul><li>进程本身的调度和中断机制通过阻塞方式实现</li><li>这个过程对于进程自身来说是无感知的</li></ul></li><li><p>阻塞式IO调用</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻塞式函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></li><li><p>锁和同步机制</p><ul><li>互斥锁（Mutex）</li><li>信号量（Semaphore）</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 线程互斥锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_mutex_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_cond_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cond;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 尝试获取互斥锁，如果无法获取则进入阻塞状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始访问被保护的资源</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 信号量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sem_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sem;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 初始化信号量为0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待信号量</span></span></code></pre></div></li></ol><p>与阻塞不同，空转指的是进程进入无意义的空循环状态，可能通过不断检查条件来等待某个条件的达成。这可能是程序bug或刻意设计。在这种状态下，进程处于正常执行状态但不执行有用逻辑，导致CPU浪费。</p><blockquote><p>死锁时，锁住的两个或多个进程会被阻塞，然后被操作系统挂起，CPU占用为0，这是典型的死锁特征。</p></blockquote><h2 id="进程间通信-ipc" tabindex="-1">进程间通信（IPC） <a class="header-anchor" href="#进程间通信-ipc" aria-label="Permalink to &quot;进程间通信（IPC）&quot;">​</a></h2><p>进程是操作系统提供给上层的虚拟容器，为程序运行提供隔离和保护。容器之间需要交互，交互方式由操作系统提供相应的系统调用实现。</p><h3 id="基于内存的通信" tabindex="-1">基于内存的通信 <a class="header-anchor" href="#基于内存的通信" aria-label="Permalink to &quot;基于内存的通信&quot;">​</a></h3><ol><li><p>信号</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigprocmask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>信号是一种软件软中断机制</li><li>为进程提供响应外界发送单向数据的机制</li><li>进程可以实现对特定信号的响应逻辑</li><li>类似于事件的概念</li><li>信号的回调函数是异步的，最好是可重入的</li></ul><p>信号处理流程：</p><ul><li>信号发送：操作系统生成信号并发送给目标进程</li><li>信号接收和处理：进程接收信号，执行信号处理程序</li><li>默认行为： <ul><li>终止进程（如SIGKILL、SIGTERM）</li><li>暂停进程（如SIGSTOP）</li><li>忽略信号（如SIGCHLD）</li><li>继续执行（如SIGCONT）</li></ul></li></ul></li><li><p>管道</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkfifo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>单向管道（匿名管道）：主要用于父子进程间通信，数据流是单向的</li><li>双向管道（命名管道）：支持无父子关系的进程间通信</li></ul></li><li><p>消息队列</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgsnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgrcv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>在内核中维护的队列，用于存储进程间交换的消息</li><li>支持消息的异步传输</li><li>消息在队列中按顺序排列</li><li>支持优先级</li><li>提供良好的可靠性和同步机制</li></ul></li><li><p>信号量（Semaphore）</p><ul><li>用于控制多个进程对共享资源访问的同步机制</li><li>用于进程间的互斥和同步</li><li>类型： <ul><li>二值信号量（互斥锁）：值只有0和1</li><li>计数信号量：值可以是非负整数，表示资源剩余数量</li></ul></li></ul></li><li><p>共享内存</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shm_open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>多个进程可以同时访问共享内存</li><li>通常需要使用互斥量或信号量进行同步</li><li>适合大量、快速的进程间数据共享</li></ul></li></ol><h3 id="基于io的通信" tabindex="-1">基于IO的通信 <a class="header-anchor" href="#基于io的通信" aria-label="Permalink to &quot;基于IO的通信&quot;">​</a></h3><ol><li><p>套接字（Socket）</p><ul><li>满足跨主机的通信</li><li>特别适合通过网络或专用线路通信</li></ul></li><li><p>eventfd</p><ul><li>用于进程或线程间通信</li><li>支持用户态和内核态之间通信</li></ul></li><li><p>磁盘文件</p></li></ol><h2 id="内存结构" tabindex="-1">内存结构 <a class="header-anchor" href="#内存结构" aria-label="Permalink to &quot;内存结构&quot;">​</a></h2>`,21)]))}const E=s(p,[["render",e]]);export{o as __pageData,E as default};
