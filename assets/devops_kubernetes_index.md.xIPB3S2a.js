import{_ as s,c as t,o as a,ae as r}from"./chunks/framework.BtEkjhVd.js";const n="/assets/devops3.DOcp2gbt.png",o="/assets/devops4.DxksXrIQ.png",i="/assets/saas.CePITgwJ.png",m=JSON.parse('{"title":"K8s","description":"","frontmatter":{"title":"K8s","order":30},"headers":[],"relativePath":"devops/kubernetes/index.md","filePath":"devops/kubernetes/index.md"}'),d={name:"devops/kubernetes/index.md"};function p(c,e,l,_,u,b){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="kubernetes" tabindex="-1">Kubernetes <a class="header-anchor" href="#kubernetes" aria-label="Permalink to &quot;Kubernetes&quot;">​</a></h1><h2 id="传统的微服务架构-vs-云原生架构" tabindex="-1">传统的微服务架构 vs 云原生架构 <a class="header-anchor" href="#传统的微服务架构-vs-云原生架构" aria-label="Permalink to &quot;传统的微服务架构 vs 云原生架构&quot;">​</a></h2><p>docker 的虚拟化技术拉开了云原生架构的序幕，kubernetes 也取得了云原生时代事实性标准的地位。云原生技术将原本在后端开发的内容下沉到基础设施上，使得开发业务和运维管理进一步分工，细化了和明确了各自的边界。由于其出色的自动化能力，一定程度上，它不仅干掉了大量的运维，还干掉了一部分后台开发的人员，虽然 kubernetes 是基础设施层的应用，但是对上层的后台开发造成了不小的影响，它间接与后台的很多分布式架构的微服务组件竞争上岗，导致一些分布式微服务的组件遭到挤兑，如下图。传统分布式组件能干的，kubernetes 能干，传统分布式组件不能干的，kubernetes 还能干。</p><p><img src="'+n+'" alt="devops"><img src="'+o+'" alt="devops"></p><p>kubernetes 还具有一个非常重要的优势就是语言无关。传统的微服务架构几乎锁死了 Java 和 Spring Cloud，这样造成了 Java 一支独大的局面，而今天的 kubernetes 架构俨然提出了不一样的看法。总结就是，云原生架构对传统微服务架构的挑战性是很激烈的，云原生架构是未来必然的结果。</p><h2 id="云原生对前端的影响" tabindex="-1">云原生对前端的影响 <a class="header-anchor" href="#云原生对前端的影响" aria-label="Permalink to &quot;云原生对前端的影响&quot;">​</a></h2><p>云原生的出现极大地促进了云计算的发展。按照云计算厂商提供的云计算资源的封装程度，可以将云计算资源分为以下的类型 <img src="'+i+'" alt="saas"> 从下至上，自由度逐渐降低，但是使用更加方便，服务封装的程度越高。在一定程度上，如果前端人需要专注于页面的开发，那么，前端人可以购买相应的后台服务，并且直接使用云厂商的后台组件进行数据存储，无需担心后台的实现和网络攻击，由云厂商来进行开发和维护。这也就是所谓的 Serverless，专注于前端开发，而无需考虑后端实现的冗余细节。</p>',7)]))}const h=s(d,[["render",p]]);export{m as __pageData,h as default};
