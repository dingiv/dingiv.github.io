import{_ as e,o as r,c as l,ah as t}from"./chunks/framework.BiR4sZ89.js";const _=JSON.parse('{"title":"平台设备","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/embed/bus/platform.md","filePath":"kernel/embed/bus/platform.md"}'),i={name:"kernel/embed/bus/platform.md"};function n(o,a,s,d,h,c){return r(),l("div",null,[...a[0]||(a[0]=[t('<h1 id="平台设备" tabindex="-1">平台设备 <a class="header-anchor" href="#平台设备" aria-label="Permalink to “平台设备”">​</a></h1><p>不支持总线协议的设备一般称之为平台设备。意为和具体的硬件平台相关的设备。</p><p>由于设备的类型众多，不同的实现五花八门，有的设备并不支持总线协议，需要硬件厂商或者嵌入式开发者自行实现硬件的探测和配置。非标准的设备杂乱无章，探测和描述设备变得困难，为了支持动态的修改设备探测的机制，Linux 提供了<strong>设备树源</strong>加载机制，支持部分平台设备在不走 ACPI 的条件下，通过自定义设备树，提示内核探测自定义硬件。</p><h2 id="设备行为" tabindex="-1">设备行为 <a class="header-anchor" href="#设备行为" aria-label="Permalink to “设备行为”">​</a></h2><ul><li>设备探测：识别平台设备存在及其硬件信息，依赖设备树或 ACPI 描述，无动态扫描；</li><li>资源配置：为设备分配硬件资源（如 MMIO 地址、中断号、时钟），基于设备树/ACPI 提供的信息；</li><li>电源管理：控制设备电源状态（如开启、挂起）；</li><li>数据传输：通过 MMIO 或 GPIO 与设备交换数据；</li><li>中断处理：通过中断机制，异步监听硬件事件，如：DMA、错误处理；</li></ul><h2 id="gpio" tabindex="-1">GPIO <a class="header-anchor" href="#gpio" aria-label="Permalink to “GPIO”">​</a></h2><h2 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to “UART”">​</a></h2>',7)])])}const m=e(i,[["render",n]]);export{_ as __pageData,m as default};
