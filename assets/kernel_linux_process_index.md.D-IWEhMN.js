import{_ as i,o as a,c as t,ah as l,bl as n,bm as h}from"./chunks/framework.BvDvRtye.js";const o=JSON.parse('{"title":"进程管理","description":"","frontmatter":{"title":"进程管理","order":20},"headers":[],"relativePath":"kernel/linux/process/index.md","filePath":"kernel/linux/process/index.md"}'),e={name:"kernel/linux/process/index.md"};function p(k,s,d,r,c,E){return a(),t("div",null,[...s[0]||(s[0]=[l(`<h1 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to “进程管理”">​</a></h1><p>进程管理是牵涉多个 linux 的子系统的瓜田李下之地，理解进程管理需要从多个角度理解。</p><h2 id="资源容器" tabindex="-1">资源容器 <a class="header-anchor" href="#资源容器" aria-label="Permalink to “资源容器”">​</a></h2><p>进程是程序在运行中的一次实例，是系统资源分配的基本单位，是一个<strong>资源容器</strong>，容器提供了</p><ul><li>运行环境维持，依赖提供</li><li>资源管理：组织、限制、隔离、保护、持久化、迁移</li><li>生命周期管理，生命周期钩子函数</li></ul><p>进程代表了一个应用层程序的实例化对象及其运行的容器。每个进程都有自己的地址空间、文件描述符表、内存映射、栈、寄存器等。在程序的执行中，系统将为进程分配 CPU 资源、为程序许诺一个独立而广阔的虚拟内存空间、并单独管理该程序的 IO 文件描述符资源等等，供程序使用。</p><h2 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-label="Permalink to “任务”">​</a></h2><p><strong>进程是一个任务，任务支持并发</strong>。并发可以允许操作系统以一定的顺序，先后执行多个不同的任务，并且每个任务仅仅只执行一个较小时间段，例如：40 ms，然后就暂停执行，切换到另一个任务上继续执行。由于这个轮换的时间很短，从而给人一种假象，多个程序仿佛是同时在运行。并发的意义在于可以让多个程序快速交替执行，从而模拟多任务同时运行的假象。</p><p>另外，并发是基于调度的。并发依赖于系统对于每个任务的时间片分配，每个任务都有机会被调度，从而完成特定的任务。任务的调度需要采用特定的规则和精心设计的算法，以保证任务的调度公平。</p><p>在 Linux 中，进程使用一个 task_struct 来描述，这也是线程的结构体定义。因为在 linux 中，进程和线程都被抽象为一个<strong>任务</strong>——<strong>可调度对象</strong>。进程和线程使用一些标志位和变量来加以识别和区分，除此之外，二者几乎一致。</p><p>进程结构体往往作为程序的主线程进行调用，在主线程中，程序可以创建额外的子线程，子线程结构体通过指针与主线程的结构体共享一些变量，从而实现在同一个进程中，不同的线程能够访问相同的资源的效果。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pid_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mm_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mm;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> files_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">files;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list_head children;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_entity se;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_rt_entity rt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><table tabindex="0"><thead><tr><th>属性</th><th>进程A（主线程）</th><th>线程B（属于A）</th></tr></thead><tbody><tr><td><code>mm</code>（内存空间）</td><td>共享</td><td>共享</td></tr><tr><td><code>files</code>（文件表）</td><td>共享</td><td>共享</td></tr><tr><td><code>fs</code>（工作目录）</td><td>共享</td><td>共享</td></tr><tr><td>栈</td><td>独立</td><td>独立</td></tr><tr><td><code>task_struct</code></td><td>独立</td><td>独立</td></tr></tbody></table><h2 id="内存模型" tabindex="-1">内存模型 <a class="header-anchor" href="#内存模型" aria-label="Permalink to “内存模型”">​</a></h2><p>进程的内存是操作系统许诺的一个虚假空间，分为两个部分，一部分是内核空间，一部分是用户空间，内核空间预先存放了操作系统为用户提供过的一些数据和信息，用户的代码和数据存放在用户空间，用户可以在自己的空间中执行程序，同时也可以通过执行特定的指令，从而触发中断让操作系统介入，进入内核空间中去让操作系统执行内核代码，以使用内核提供的 API 执行更加底层的操作，包括：IO 操作，硬件控制，系统控制等等。</p><p><img src="`+n+'" alt="内存模型"></p><ul><li>栈区，为函数调用提供局部变量空间、保存返回地址，每个线程都有自己的栈空间，内存由操作系统自动维护；</li><li>堆区，为程序提供动态分配内存（如 malloc, new），内存需要程序员手动管理；</li></ul><h2 id="进程拓扑" tabindex="-1">进程拓扑 <a class="header-anchor" href="#进程拓扑" aria-label="Permalink to “进程拓扑”">​</a></h2><p>在 linux 中，所有的进程都是通过其他进程 fork 而来的，由此形成了进程之间的父子派生关系。每个进程都必须要有父进程，即使你看到一个进程是完全 detached 的，其实它也会默认找 1 号进程作为父进程。使用 fork 调用可以创建子进程，子进程默认和父进程位于同一个进程组。</p><p>Linux 系统中的所有进程都可以看作一棵以 init（PID 1）为根的树状结构。每个进程都有一个父进程（parent），可以有多个子进程（children）。通过 <code>pstree</code> 命令可以直观地查看进程树结构。所有的进程都是通过其他进程创建而来的（除了 1 号进程），由此形成了进程之间的父子派生关系。使用 <a href="./../syscall/process">fork 系列调用</a>可以创建子进程，子进程默认和父进程位于同一个进程组。</p><p>进程组是一个或多个相关进程的集合，通常用于信号的批量管理。每个进程组有一个唯一的进程组 ID（PGID），等于该组组长进程的 PID。进程组常用于 shell 管理前台/后台任务。</p><p>会话是一个或多个进程组的集合，通常由用户登录 shell 创建。每个会话有一个会话首进程（Session Leader），会话用于终端控制和作业管理。</p><h3 id="孤儿进程与僵尸进程" tabindex="-1">孤儿进程与僵尸进程 <a class="header-anchor" href="#孤儿进程与僵尸进程" aria-label="Permalink to “孤儿进程与僵尸进程”">​</a></h3><ul><li>孤儿进程：父进程终止后，子进程未结束，此时子进程会被 init 进程（PID 1）收养。</li><li>僵尸进程：子进程已结束，但父进程尚未调用 wait/waitpid 获取其状态，子进程会以僵尸状态保留在进程表中，直到父进程处理其退出信息。</li></ul><h3 id="进程在-vfs-中的虚拟文件" tabindex="-1">进程在 VFS 中的虚拟文件 <a class="header-anchor" href="#进程在-vfs-中的虚拟文件" aria-label="Permalink to “进程在 VFS 中的虚拟文件”">​</a></h3><p>每个进程在 <code>/proc/[pid]/</code> 下有一组虚拟文件：</p><table tabindex="0"><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td><code>/proc/[pid]/status</code></td><td>进程状态和信息</td></tr><tr><td><code>/proc/[pid]/cmdline</code></td><td>启动命令</td></tr><tr><td><code>/proc/[pid]/fd/</code></td><td>打开的文件描述符</td></tr><tr><td><code>/proc/[pid]/maps</code></td><td>内存映射信息</td></tr></tbody></table><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to “生命周期”">​</a></h2><p>进程具有从创建到死亡的阶段，特殊地还有睡眠阶段，</p><p><img src="'+h+`" alt="进程的生命周期"></p><p>生命周期可以使用进程相关的系统调用来进行管理，以 C 函数的形式存在。具体参考<a href="./../syscall/">系统调用</a></p><h3 id="进程加载" tabindex="-1">进程加载 <a class="header-anchor" href="#进程加载" aria-label="Permalink to “进程加载”">​</a></h3><p>当一个程序被执行时：</p><ol><li>将程序的 ELF 文件（Executable and Linkable Format）内容加载到内存中</li><li>分配到进程的虚拟地址空间中的相应位置（位置分配由编译器决定）</li><li>操作系统为进程创建页表，维护虚拟内存到物理内存的映射逻辑</li></ol><h3 id="休眠" tabindex="-1">休眠 <a class="header-anchor" href="#休眠" aria-label="Permalink to “休眠”">​</a></h3><p>阻塞、空转、死锁</p><ul><li><strong>阻塞</strong>：进程因等待 I/O、锁、信号量等进入阻塞状态，CPU 时间片被让出。</li><li><strong>空转</strong>：进程处于无意义的循环等待，浪费 CPU 资源，常见于设计缺陷或 bug。</li></ul><p>从操作系统层面，当进程调用阻塞式系统调用时：</p><ol><li>进程进入阻塞状态</li><li>操作系统不会把 CPU 的时间片分配给这个进程</li><li>直到调用结束，进程从阻塞状态重新进入执行状态</li></ol><p>常见的阻塞式调用包括：</p><ol><li><p>进程调度和中断</p><ul><li>进程本身的调度和中断机制通过阻塞方式实现</li><li>这个过程对于进程自身来说是无感知的</li></ul></li><li><p>阻塞式 IO 调用</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻塞式函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></li><li><p>锁和同步机制</p><ul><li>互斥锁（Mutex）</li><li>信号量（Semaphore）</li></ul><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 线程互斥锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_mutex_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_cond_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cond;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 尝试获取互斥锁，如果无法获取则进入阻塞状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始访问被保护的资源</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 信号量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sem_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sem;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 初始化信号量为0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待信号量</span></span></code></pre></div></li></ol><p>与阻塞不同，空转指的是进程进入无意义的空循环状态，可能通过不断检查条件来等待某个条件的达成。这可能是程序 bug 或刻意设计。在这种状态下，进程处于正常执行状态但不执行有用逻辑，导致 CPU 浪费。</p><p>死锁时，锁住的两个或多个进程会被阻塞，然后被操作系统挂起，CPU 占用为 0，这是典型的死锁特征。</p><h3 id="死亡" tabindex="-1">死亡 <a class="header-anchor" href="#死亡" aria-label="Permalink to “死亡”">​</a></h3>`,44)])])}const y=i(e,[["render",p]]);export{o as __pageData,y as default};
