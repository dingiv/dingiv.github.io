import{_ as l,c as e,ae as i,o}from"./chunks/framework.BzDBnRMZ.js";const p=JSON.parse('{"title":"并发","description":"","frontmatter":{},"headers":[],"relativePath":"basic/os/concurrency.md","filePath":"basic/os/concurrency.md"}'),t={name:"basic/os/concurrency.md"};function r(c,a,n,u,s,h){return o(),e("div",null,a[0]||(a[0]=[i('<h1 id="并发" tabindex="-1">并发 <a class="header-anchor" href="#并发" aria-label="Permalink to &quot;并发&quot;">​</a></h1><p>在操作系统中，同个处理机上有多个程序同时运行即并发。并发可分为同步和互斥。</p><h2 id="同步、互斥" tabindex="-1">同步、互斥 <a class="header-anchor" href="#同步、互斥" aria-label="Permalink to &quot;同步、互斥&quot;">​</a></h2><ul><li>互斥。同一个资源同一时间只有一个访问者可以进行访问，其他访问者需要等前一个访问者访问结束才可以开始访问该资源。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li><li>同步。分布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。所以同步就是在互斥的基础上，通过其它机制实现访问者对资源的有序访问。</li></ul><ul><li>总结：同步是一种更为复杂的互斥，而互斥是一种特殊的同步。</li></ul><h2 id="同步、异步" tabindex="-1">同步、异步 <a class="header-anchor" href="#同步、异步" aria-label="Permalink to &quot;同步、异步&quot;">​</a></h2><ul><li>同步。同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。</li><li>异步。异步和同步是相对的，异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</li></ul><ul><li>注意：线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。2）异步和多线程并不是一个同等关系。异步是最终目的，多线程只是我们实现异步的一种手段。</li></ul><h2 id="阻塞-非阻塞" tabindex="-1">阻塞，非阻塞 <a class="header-anchor" href="#阻塞-非阻塞" aria-label="Permalink to &quot;阻塞，非阻塞&quot;">​</a></h2><p>阻塞和非阻塞是当进程在访问数据时，根据IO操作的就绪状态不同而采取的不同处理方式，比如主程序调用一个函数要读取一个文件的内容，阻塞方式下主程序会等到函数读取完再继续往下执行，非阻塞方式下，读取函数会立刻返回一个状态值给主程序，主程序不等待文件读取完就继续往下执行。一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。</p><h2 id="同步阻塞-同步非阻塞-异步阻塞-异步非阻塞" tabindex="-1">同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 <a class="header-anchor" href="#同步阻塞-同步非阻塞-异步阻塞-异步非阻塞" aria-label="Permalink to &quot;同步阻塞，同步非阻塞，异步阻塞，异步非阻塞&quot;">​</a></h2><p>以发送方发出请求要接收方读取某文件内容为例。</p><ul><li>同步阻塞：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等，直到获取读取结果再响应发送发，等待期间不可做其他操作（阻塞）。</li><li>同步非阻塞：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上的得到读取结果，就立即返回，接收方继续去做其他事情。此时并未响应发送方，发送方一直在等待。直到IO操作（这里是读取文件）完成后，接收方获得读取结果响应发送方，接收方才可以进入下一次请求过程。（实际不应用）</li><li>异步阻塞：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作（阻塞）。（实际不应用）</li><li>异步非阻塞：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）</li></ul><ul><li>总结：1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。</li></ul><h2 id="面试题目举例" tabindex="-1">面试题目举例 <a class="header-anchor" href="#面试题目举例" aria-label="Permalink to &quot;面试题目举例&quot;">​</a></h2><ol><li>什么是线程同步和互斥？</li></ol><blockquote><p>线程同步：每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。可以理解成“你说完，我再做”。有了线程同步，每个线程才不是自己做自己的事情，而是协同完成某件大事。</p><p>线程互斥：当有若干个线程访问同一块资源时，规定同一时间只有一个线程可以得到访问权，其它线程需要等占用资源者释放该资源才可以申请访问。线程互斥可以看成是一种特殊的线程同步。</p></blockquote><ol start="2"><li>线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？</li></ol><blockquote><p>同步是个过程，阻塞是线程的一种状态：当多个线程访问同一资源时，规定同一时间只有一个线程可以进行访问，所以后访问的线程将阻塞，等待前访问的线程访问完。</p><p>线程同步不一定发生阻塞！线程同步的时候，需要协调推进速度，只有当访问同一资源出现互相等待和互相唤醒会发生阻塞。而阻塞了一定是同步，后访问的等待获取资源，线程进入阻塞状态，借以实现多线程同步的过程。</p></blockquote><ol start="3"><li>线程同步互斥的方式</li></ol><blockquote><p>临界区（Critical Section）：适合一个进程内的多线程访问公共区域或代码段时使用。 互斥量 (Mutex)：适合不同进程内多线程访问公共区域或代码段时使用，与临界区相似。 事件（Event）：通过线程间触发事件实现同步互斥。 信号量（Semaphore）：与临界区和互斥量不同，可以实现多个线程同时访问公共区域数据，原理与操作系统中PV操作类似，先设置一个访问公共区域的线程最大连接数，每有一个线程访问共享区资源数就减一，直到资源数小于等于零。</p></blockquote>',21)]))}const b=l(t,[["render",r]]);export{p as __pageData,b as default};
