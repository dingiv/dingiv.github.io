import{_ as e,o as a,c as n,ah as t}from"./chunks/framework.BwbIerCg.js";const h=JSON.parse('{"title":"并发","description":"","frontmatter":{"title":"并发","order":40},"headers":[],"relativePath":"design/concurrent/index.md","filePath":"design/concurrent/index.md"}'),r={name:"design/concurrent/index.md"};function s(c,p,i,o,d,l){return a(),n("div",null,[...p[0]||(p[0]=[t('<h1 id="并发编程" tabindex="-1">并发编程 <a class="header-anchor" href="#并发编程" aria-label="Permalink to “并发编程”">​</a></h1><p>1️⃣ 共享状态</p><p>多个执行单元访问同一数据。</p><p>后果：</p><p>数据竞争</p><p>不一致</p><p>Heisenbug</p><p>解决思路：</p><p>锁</p><p>原子操作</p><p>不共享（最优）</p><p>2️⃣ 顺序与可见性</p><p>不是“谁先写”，而是“谁看到什么”。</p><p>CPU、编译器、内存模型都会重排。</p><p>解决思路：</p><p>内存屏障</p><p>happens-before 关系</p><p>语言内存模型保证（Java / Rust）</p><p>3️⃣ 协调与阻塞</p><p>谁等谁？等多久？</p><p>错误设计会导致：</p><p>死锁</p><p>活锁</p><p>饥饿</p><p>解决思路：</p><p>条件变量</p><p>channel</p><p>async + await</p><p>超时 + 取消</p><p>4️⃣ 失败传播</p><p>并发中失败不是“return -1”。</p><p>一个任务失败，其他怎么办？</p><p>半完成状态如何回滚？</p><p>解决思路：</p><p>结构化并发</p><p>supervisor</p><p>失败隔离</p><h2 id="解决思路" tabindex="-1">解决思路 <a class="header-anchor" href="#解决思路" aria-label="Permalink to “解决思路”">​</a></h2><p>1️⃣ 共享内存模型（最难）</p><p>代表：</p><p>C / C++</p><p>Java 低层</p><p>pthread</p><p>特征：</p><p>锁、mutex、atomic</p><p>性能高</p><p>心智负担极重</p><p>适合：</p><p>内核</p><p>高频交易</p><p>极致性能模块</p><p>2️⃣ 消息传递模型（最稳）</p><p>代表：</p><p>Go channel</p><p>Erlang / Actor</p><p>Rust channel</p><p>特征：</p><p>不共享内存</p><p>通过消息传递状态</p><p>天然隔离</p><p>适合：</p><p>服务端</p><p>微服务</p><p>分布式系统</p><p>你之前对“跨进程响应式”的直觉，本质就在这里。</p><p>3️⃣ async / await（时间抽象）</p><p>代表：</p><p>JS</p><p>Rust async</p><p>Java CompletableFuture</p><p>特征：</p><p>协作式并发</p><p>单线程也可高并发</p><p>不等于线程安全</p><p>关键误区：</p><p>async 解决的是“等”，不是“共享”</p>',76)])])}const u=e(r,[["render",s]]);export{h as __pageData,u as default};
