import{_ as a,c as t,o as n,ae as s}from"./chunks/framework.Dgg8-8ov.js";const r="/assets/syscall.6k2T9StR.png",x=JSON.parse('{"title":"系统调用","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/syscall/index.md","filePath":"kernel/linux/syscall/index.md"}'),l={name:"kernel/linux/syscall/index.md"};function i(o,e,c,_,d,p){return n(),t("div",null,e[0]||(e[0]=[s('<h1 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-label="Permalink to &quot;系统调用&quot;">​</a></h1><p>系统调用存储在进程的内存的内核空间中，而进程间共享内核空间。进程需要通过执行一个特殊的提权指令触发用户态向内核态的切换，使得 CPU 的权限级别上升，从而访问特权指令和进行敏感操作。用户态的进程只有有限的两种合法方式去访问高级的指令和操作，一个是系统调用，另一个是触发错误处理。 <img src="'+r+'" alt=""></p><p>系统调用也是系统给予上层的功能封装，上层无需关注硬件管理、内存、网络通信等繁琐细节，直接使用系统能力，即可完成功能的实现。</p><h2 id="文件系统交互" tabindex="-1">文件系统交互 <a class="header-anchor" href="#文件系统交互" aria-label="Permalink to &quot;文件系统交互&quot;">​</a></h2><p>Linux 用户进程如果希望访问内核空间代码，只能够通过系统调用，但是系统调用的接口是有限的，Linux 系统对于新的系统调用添加时会非常谨慎，尽量避免引入不必要的系统调用，同时对于已经添加的系统调用，其接口也必须承诺稳定。</p><p>那么，如何解决新增的接口调用需求呢？Linux 复用了文件系统系统调用，并通过 VFS 在文件目录树中的暴露特殊文件，进程通过读写特殊文件从而与内核进行交互。</p>',6)]))}const m=a(l,[["render",i]]);export{x as __pageData,m as default};
