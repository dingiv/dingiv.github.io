import{_ as e,o as r,c as i,ah as t,b1 as n}from"./chunks/framework.CJUjh4G6.js";const f=JSON.parse('{"title":"软件设计","description":"","frontmatter":{"title":"软件设计","order":20},"headers":[],"relativePath":"design/index.md","filePath":"design/index.md"}'),l={name:"design/index.md"};function s(o,a,p,d,c,_){return r(),i("div",null,[...a[0]||(a[0]=[t('<h1 id="软件设计" tabindex="-1">软件设计 <a class="header-anchor" href="#软件设计" aria-label="Permalink to “软件设计”">​</a></h1><p>软件设计的基础意义是根据实际的业务需求编写软件进行实现。但是，在实际的环境中，事情往往没有想象中的那么简单，我们需要额外面临更多考验。例如：可行性问题、成本问题、可维护问题、质量问题等。如何解决这些附加问题是研究软件设计的根本动力。</p><h2 id="理论概览" tabindex="-1">理论概览 <a class="header-anchor" href="#理论概览" aria-label="Permalink to “理论概览”">​</a></h2><p>在众多的<a href="./typical/">经典范式</a>理论中，我们感到了百家争鸣般的喧闹。有的是宏观理论，为我们提供方向性指导，有的是专精细分领域，为不同的领域提出可实践的意见。</p><p>成熟大派，更是在特殊的领域内独占山头，为开发者提供一个稳定的栖息之地：</p><ul><li><a href="./oop/">面向对象编程</a></li><li><a href="./fp/">函数式编程</a></li><li><a href="./concurrent/">并发编程</a></li><li><a href="./async/">异步编程</a></li></ul><p><img src="'+n+'" alt=""></p><p>笔者总结<a href="./spacetime/">面向时空</a>是为了破除这些理论的隔阂，从一个更高更全面的维度去理解这些理论的本质，总结概括杂乱的理论商品，减少选择困难。并走到实践中去，提出具体的实践方案，让理论变得可行。</p>',8)])])}const m=e(l,[["render",s]]);export{f as __pageData,m as default};
