import{_ as e,c as a,o as i,ae as s}from"./chunks/framework.BtEkjhVd.js";const p=JSON.parse('{"title":"systemd","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/develop/systemd.md","filePath":"kernel/linux/develop/systemd.md"}'),t={name:"kernel/linux/develop/systemd.md"};function o(d,l,r,n,h,u){return i(),a("div",null,l[0]||(l[0]=[s('<h1 id="systemd" tabindex="-1">systemd <a class="header-anchor" href="#systemd" aria-label="Permalink to &quot;systemd&quot;">​</a></h1><p>systemd 是 linux 上的一号进程，用于在应用层提供基础的系统服务，简化应用层的使用流程。</p><h2 id="服务管理" tabindex="-1">服务管理 <a class="header-anchor" href="#服务管理" aria-label="Permalink to &quot;服务管理&quot;">​</a></h2><h2 id="集中化日志管理" tabindex="-1">集中化日志管理 <a class="header-anchor" href="#集中化日志管理" aria-label="Permalink to &quot;集中化日志管理&quot;">​</a></h2><h2 id="服务" tabindex="-1">服务 <a class="header-anchor" href="#服务" aria-label="Permalink to &quot;服务&quot;">​</a></h2><p>服务是后台运行或定时运行的任务，帮助系统或其他进程更好地完成任务。</p><h3 id="系统服务" tabindex="-1">系统服务 <a class="header-anchor" href="#系统服务" aria-label="Permalink to &quot;系统服务&quot;">​</a></h3><p>系统服务软件：</p><ul><li>不属于内核层代码</li><li>运行在用户空间中</li><li>协助用户与系统内核交互</li><li>为用户态程序提供基础设施服务</li></ul><p>典型软件包括：</p><ul><li>systemd（服务管理、journald日志服务、udev设备管理）</li><li>bash</li><li>iproute</li><li>grub</li></ul><p>多数Linux发行版自带systemd：</p><ul><li>配置文件位于<code>/etc/systemd</code>、<code>/usr/lib/systemd</code>、<code>~/.config/systemd</code>等文件夹</li><li>使用systemctl命令操作</li><li>使用journalctl命令管理日志内容</li></ul><h3 id="服务单元" tabindex="-1">服务单元 <a class="header-anchor" href="#服务单元" aria-label="Permalink to &quot;服务单元&quot;">​</a></h3><p>在systemd抽象中：</p><ul><li>独立运行的进程服务使用service文件描述</li><li>称为服务单元</li><li>规定服务进程的启动配置</li><li>systemd根据配置文件管理和启动服务</li><li>通过systemctl和journalctl接口管理和控制系统上注册的服务程序</li></ul><h2 id="内核模块" tabindex="-1">内核模块 <a class="header-anchor" href="#内核模块" aria-label="Permalink to &quot;内核模块&quot;">​</a></h2><p>Linux是可扩展架构，允许动态加载和卸载功能模块：</p><ul><li>包括设备驱动程序、文件系统、网络协议栈等</li><li>动态加载通过insmod/modprobe命令</li><li>卸载通过rmmod命令</li></ul><p>内核模块加载后：</p><ul><li>符号空间中的函数不会被加入到操作系统运行的物理内存中</li><li>通过EXPORT_SYMBOL宏导出函数</li><li>只有通过该宏显式导出的函数才能在模块外部可见</li></ul><blockquote><p>内核模块加载区别于动态链接库加载：</p><ul><li>内核模块加载是将二进制目标文件加载到物理内存中</li><li>动态链接库由系统在创建进程时加载到虚拟内存中</li></ul></blockquote><h2 id="日志管理" tabindex="-1">日志管理 <a class="header-anchor" href="#日志管理" aria-label="Permalink to &quot;日志管理&quot;">​</a></h2><h3 id="内核日志" tabindex="-1">内核日志 <a class="header-anchor" href="#内核日志" aria-label="Permalink to &quot;内核日志&quot;">​</a></h3><ul><li>使用 <code>printk</code> 函数打印日志</li><li>驱动可使用 <code>dev_printk</code>（自动携带设备信息）</li></ul><h3 id="用户态日志" tabindex="-1">用户态日志 <a class="header-anchor" href="#用户态日志" aria-label="Permalink to &quot;用户态日志&quot;">​</a></h3><ul><li>需要自行实现日志系统</li><li>可使用 systemd-journald 服务</li></ul><h3 id="systemd-日志管理这是一个常常伴随系统安装的用户态进程-用于管理机器上服务-同时也自带了一个日志模块-systemd-journald-它会定期读取" tabindex="-1">Systemd 日志管理这是一个常常伴随系统安装的用户态进程，用于管理机器上服务，同时也自带了一个日志模块-systemd-journald，它会定期读取 <a class="header-anchor" href="#systemd-日志管理这是一个常常伴随系统安装的用户态进程-用于管理机器上服务-同时也自带了一个日志模块-systemd-journald-它会定期读取" aria-label="Permalink to &quot;Systemd 日志管理这是一个常常伴随系统安装的用户态进程，用于管理机器上服务，同时也自带了一个日志模块-systemd-journald，它会定期读取&quot;">​</a></h3><p>内核日志，并将内核日志输出到位置ソvar／log／syslog｀文件中；同时它也向用户态的程序提供了一个＇syslog 函数接口，用户态程序可以选择使用这个函数来使用提供的日志打印系统和服务。syslog 函数会将日志消息发送给 systemd-journald 守护进程，具体的日志管理由它完成。</p><ul><li>systemd-journald 定期读取内核日志</li><li>输出到 <code>/var/log/syslog</code></li><li>提供 <code>syslog</code> 函数接口</li><li>使用 <code>journalctl</code> 查看日志：<div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">journalctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 查看最近 100 条日志</span></span></code></pre></div></li></ul>',30)]))}const m=e(t,[["render",o]]);export{p as __pageData,m as default};
