import{_ as a,o as n,c as i,ah as e}from"./chunks/framework.BwbIerCg.js";const k=JSON.parse('{"title":"Vulkan","description":"","frontmatter":{},"headers":[],"relativePath":"client/render/api/vulkan.md","filePath":"client/render/api/vulkan.md"}'),p={name:"client/render/api/vulkan.md"};function l(t,s,r,d,o,c){return n(),i("div",null,[...s[0]||(s[0]=[e(`<h1 id="vulkan" tabindex="-1">Vulkan <a class="header-anchor" href="#vulkan" aria-label="Permalink to “Vulkan”">​</a></h1><h1 id="spir-v" tabindex="-1">SPIR-V <a class="header-anchor" href="#spir-v" aria-label="Permalink to “SPIR-V”">​</a></h1><p>SPIR-V（Standard Portable Intermediate Representation）是 Khronos 制定的跨平台中间表示，服务于 Vulkan、OpenGL 和 OpenCL 生态。着色器源代码（GLSL、HLSL、WGSL）先编译为 SPIR-V 二进制，驱动再将 SPIR-V 转换为 GPU 机器码。这种分层设计降低了驱动复杂度，也使得着色器可以跨应用复用。</p><p>SPIR-V 的设计借鉴了 LLVM IR 的思想，提供一套稳定的、平台无关的中间表示。与 GLSL 的即时编译相比，SPIR-V 的预编译可消除启动时的卡顿。SPIR-V 也支持着色器模块化（import/export），多个着色器可共享函数定义，减少代码重复。SPIR-V 采用二进制格式，体积小且解析快，运行时开销远小于文本格式的着色器语言。</p><h2 id="编译流程" tabindex="-1">编译流程 <a class="header-anchor" href="#编译流程" aria-label="Permalink to “编译流程”">​</a></h2><p>SPIR-V 的编译流程分为两个阶段：前端编译将着色器源代码编译为 SPIR-V，后端编译将 SPIR-V 转换为 GPU 机器码。前端编译使用 <code>glslangValidator</code>（GLSL）、<code>dxc</code>（HLSL）、<code>naga</code>（WGSL）等工具，生成 <code>.spv</code> 文件。后端编译由 Vulkan 驱动在创建管线时完成，将 SPIR-V 转换为 NVIDIA 的 SASS、AMD 的 GFX ISA、Intel 的 Xe ISA 等。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>GLSL/HLSL/WGSL 源代码</span></span>
<span class="line"><span>    ↓ (前端编译器)</span></span>
<span class="line"><span>SPIR-V 中间表示 (.spv 文件)</span></span>
<span class="line"><span>    ↓ (Vulkan 驱动)</span></span>
<span class="line"><span>GPU 机器码 (SASS/GFX/Xe ISA)</span></span></code></pre></div><p>前端编译的优势在于可离线完成，应用启动时只需加载预编译的 SPIR-V 文件，无需运行时编译。这种模式适合生产环境，减少了首次加载的延迟。前端编译也可进行更激进的优化（如循环展开、内联），因为这些优化只需执行一次，不影响运行时性能。后端编译相对轻量，主要负责指令选择和寄存器分配，编译时间可控。</p><h2 id="指令集架构" tabindex="-1">指令集架构 <a class="header-anchor" href="#指令集架构" aria-label="Permalink to “指令集架构”">​</a></h2><p>SPIR-V 采用 SSA（Static Single Assignment）形式的指令集。每个操作都是显式的，没有隐式类型转换或状态依赖。指令由操作码和操作数组成，操作数可以是 ID 引用（指向其他指令的结果）或立即数。例如，OpAdd 指令表示加法，<code>%result = OpAdd %type %operand1 %operand2</code>，<code>%result</code> 是结果 ID，<code>%type</code> 是结果类型，<code>%operand1</code> 和 <code>%operand2</code> 是操作数 ID。</p><p>SPIR-V 的类型系统包括标量（ScalarType）、向量（VectorType）、矩阵（MatrixType）、数组（ArrayType）、结构体（StructType）、指针（PointerType）、图像（ImageType）、采样器（SamplerType）等。类型声明使用 OpType 指令，如 <code>OpTypeFloat 32</code> 声明 32 位浮点类型，<code>OpTypeVector %float 3</code> 声明三维向量。类型系统是强类型的，不支持隐式转换，确保了跨平台的正确性。</p><div class="language-spirv"><button title="Copy Code" class="copy"></button><span class="lang">spirv</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>; SPIR-V 示例：简单的加法</span></span>
<span class="line"><span>OpCapability Shader</span></span>
<span class="line"><span>OpMemoryModel Logical GLSL450</span></span>
<span class="line"><span>OpEntryPoint Vertex %main &quot;main&quot;</span></span>
<span class="line"><span>OpName %main &quot;main&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%void = OpTypeVoid</span></span>
<span class="line"><span>%void_fn = OpTypeFunction %void</span></span>
<span class="line"><span>%float = OpTypeFloat 32</span></span>
<span class="line"><span>%vec3 = OpTypeVector %float 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%main = OpFunction %void None %void_fn</span></span>
<span class="line"><span>%label = OpLabel</span></span>
<span class="line"><span>%a = OpConstant %float 1.0</span></span>
<span class="line"><span>%b = OpConstant %float 2.0</span></span>
<span class="line"><span>%sum = OpFAdd %float %a %b</span></span>
<span class="line"><span>OpReturn</span></span>
<span class="line"><span>OpFunctionEnd</span></span></code></pre></div><h2 id="装饰与布局" tabindex="-1">装饰与布局 <a class="header-anchor" href="#装饰与布局" aria-label="Permalink to “装饰与布局”">​</a></h2><p>SPIR-V 使用装饰（Decorations）将变量连接到管线阶段和资源。<code>Location</code> 装饰指定顶点输入输出位置，<code>BuiltIn</code> 装饰指定内置变量（如 Position、PointSize、FragCoord），<code>Binding</code> 和 <code>DescriptorSet</code> 装饰指定资源绑定（纹理、采样器、缓冲区）。<code>Block</code> 装饰标记统一缓冲区和存储缓冲区，<code>Offset</code> 装饰指定结构体成员偏移。</p><p>内存布局由 <code>std140</code> 和 <code>std430</code> 规则决定。<code>std140</code> 用于统一缓冲区（Uniform Buffer），标量对齐到 4 字节，向量对齐到 16 字节（vec3 例外），数组元素对齐到 16 字节。<code>std430</code> 用于存储缓冲区（Storage Buffer），标量和向量对齐到其元素大小，数组元素对齐到其元素大小（无额外填充）。这些规则确保 CPU 和 GPU 对数据布局的理解一致，避免了隐式对齐问题。</p><div class="language-spirv"><button title="Copy Code" class="copy"></button><span class="lang">spirv</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>; 统一缓冲区布局示例</span></span>
<span class="line"><span>OpMemberDecorate %Uniforms 0 Offset 0      ; modelMatrix</span></span>
<span class="line"><span>OpMemberDecorate %Uniforms 1 Offset 64     ; viewMatrix</span></span>
<span class="line"><span>OpMemberDecorate %Uniforms 2 Offset 128    ; projectionMatrix</span></span>
<span class="line"><span>OpDecorate %Uniforms Block</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%Uniforms = OpTypeStruct %mat4 %mat4 %mat4</span></span>
<span class="line"><span>%uniform_ptr = OpTypePointer Uniform %Uniforms</span></span>
<span class="line"><span>%uniforms = OpVariable %uniform_ptr Uniform</span></span></code></pre></div><h2 id="优化与验证" tabindex="-1">优化与验证 <a class="header-anchor" href="#优化与验证" aria-label="Permalink to “优化与验证”">​</a></h2><p>SPIR-V 的优化可在前端编译或后端编译进行。前端优化（如 <code>glslangValidator -O</code>）包括常量折叠、死代码消除、函数内联、循环展开。后端优化（驱动负责）包括指令调度、寄存器分配、SIMD 打包。优化级别越高，编译时间越长，但运行时性能更好。对于移动平台，可关闭激进优化以减少编译时间。</p><p>SPIR-V 的验证（Validation）确保着色器符合规范。<code>spirv-val</code> 工具可检查类型错误、未定义 ID、无效装饰、控制流错误（如函数返回不一致）。验证失败意味着着色器可能在某些 GPU 上崩溃，必须修复。Vulkan 驱动在创建管线时也会验证 SPIR-V，但验证信息可能不如 <code>spirv-val</code> 详细（驱动可能只报&quot;invalid SPIR-V&quot;，不指出具体位置）。</p><h2 id="工具链" tabindex="-1">工具链 <a class="header-anchor" href="#工具链" aria-label="Permalink to “工具链”">​</a></h2><p>SPIR-V 的工具链包括编译器、反汇编器、优化器、验证器。<code>glslangValidator</code> 是 GLSL 到 SPIR-V 的编译器，支持 Vulkan 和 OpenGL。<code>dxc</code> 是微软的 HLSL 编译器，可输出 SPIR-V（通过 <code>-spirv</code> 选项）。<code>naga</code> 是 Rust 编写的 WGSL 到 SPIR-V 编译器，用于 WebGPU 后端。<code>spirv-reflect</code> 可提取 SPIR-V 的着色器反射信息（资源绑定、输入输出），用于引擎自动绑定。</p><p><code>spirv-opt</code> 是 SPIR-V 优化器，可独立于编译器运行。优化项包括：<code>--strip-debug</code>（删除调试信息，减小文件体积）、<code>--inline-entry-points-exhaustive</code>（激进内联）、<code>--convert-local-access-chains</code>（优化局部数组访问）、<code>--ccp</code>（常量传播）。<code>spirv-opt</code> 可多次运行，每次优化可基于前一次结果。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 编译 GLSL 到 SPIR-V</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">glslangValidator</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -V</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 优化 SPIR-V</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-opt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --strip-debug</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.opt.spv</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 验证 SPIR-V</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-val</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 反汇编 SPIR-V（查看文本形式）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-dis</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span></span></code></pre></div><h2 id="跨平台编译" tabindex="-1">跨平台编译 <a class="header-anchor" href="#跨平台编译" aria-label="Permalink to “跨平台编译”">​</a></h2><p>SPIR-V 的跨平台能力是其核心价值。同一份 SPIR-V 可在 NVIDIA、AMD、Intel 的 GPU 上运行，也可转换为 WebGPU 的 WGSL。这种跨平台能力降低了引擎开发的成本，Vulkan、OpenGL、OpenCL 的开发者都可使用 SPIR-V 作为中间层。</p><p>SPIR-V 到其他着色语言的转换使用 <code>spirv-cross</code> 工具。<code>spirv-cross</code> 可将 SPIR-V 转换为 GLSL、HLSL、MSL（Metal Shading Language）、CPP（C++ 伪代码）。这种转换适用于不支持 Vulkan 的平台（如 macOS 的 Metal、iOS 的 Metal、WebGL 的 GLSL）。转换质量取决于 SPIR-V 的复杂度，简单着色器通常转换良好，复杂着色器可能需要手动调整。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># SPIR-V 转 MSL（用于 macOS/iOS）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-cross</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --msl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.metal</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># SPIR-V 转 HLSL（用于 DirectX）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-cross</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hlsl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.hlsl</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># SPIR-V 转 GLSL（用于 WebGL）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spirv-cross</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --es</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --version</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 300</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.spv</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> shader.vert.glsl</span></span></code></pre></div><h2 id="调试与性能分析" tabindex="-1">调试与性能分析 <a class="header-anchor" href="#调试与性能分析" aria-label="Permalink to “调试与性能分析”">​</a></h2><p>SPIR-V 的调试比源代码困难，因为它是中间表示，不保留原始变量名（除非保留调试信息）。<code>spirv-val</code> 可验证 SPIR-V 的正确性，但无法检查逻辑错误。Vulkan 的验证层（Validation Layers）可检测运行时错误（如资源未绑定、描述符集不匹配），但开销较大，仅用于开发环境。</p><p>性能分析工具包括 RenderDoc、Nsight、Radeon GPU Profiler。这些工具可捕获 Vulkan 帧并分析每个着色器的执行时间。着色器的 SPIR-V 代码可通过 <code>spirv-dis</code> 反汇编查看，但可读性较差。更好的方法是在源代码级别分析，使用 <code>glslangValidator -g</code> 保留调试信息，然后映射回源代码。</p><h2 id="扩展与版本" tabindex="-1">扩展与版本 <a class="header-anchor" href="#扩展与版本" aria-label="Permalink to “扩展与版本”">​</a></h2><p>SPIR-V 版本与 Vulkan 版本对应。SPIR-V 1.0 对应 Vulkan 1.0，支持基本的图形和计算着色器。SPIR-V 1.3 对应 Vulkan 1.1，增加子组操作（Subgroup Operations）、设备组（Device Groups）。SPIR-V 1.5 对应 Vulkan 1.2，增加 ray query（射线查询）、整数点积。SPIR-V 1.6 对应 Vulkan 1.3，增加 shader clock（着色器时钟）、矩阵访问（动态索引矩阵）。</p><p>SPIR-V 扩展提供额外的功能，但需要硬件支持。<code>SPV_KHR_ray_tracing</code> 增加射线追踪着色器，<code>SPV_KHR_ray_query</code> 增加射线查询（可在片段着色器中发射射线）。<code>SPV_EXT_demote_to_helper_invocation</code> 增加丢弃线程的替代方案（比 <code>discard</code> 更高效）。<code>SPV_KHR_subgroup_rotate</code> 增加子组旋转操作（用于快速傅里叶变换）。扩展需要前端编译器支持（如 <code>glslangValidator -target-env vulkan1.2</code>），也需要驱动支持。</p><p>SPIR-V 的未来发展包括更好的优化、更丰富的扩展、更紧凑的表示。Khronos 正在开发 SPIR-V 2.0，计划增加更强大的类型系统、更好的模块化支持、更高效的编码格式。SPIR-V 也将成为更多图形 API 的中间表示，如 WebGPU 的后端可使用 SPIR-V，进一步统一图形编程生态。</p>`,34)])])}const g=a(p,[["render",l]]);export{k as __pageData,g as default};
