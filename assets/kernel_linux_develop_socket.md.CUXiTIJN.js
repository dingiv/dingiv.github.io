import{_ as i,c as a,o as l,ah as n}from"./chunks/framework.C5lh6Kkj.js";const g=JSON.parse('{"title":"套接字","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/develop/socket.md","filePath":"kernel/linux/develop/socket.md"}'),h={name:"kernel/linux/develop/socket.md"};function k(t,s,p,e,d,r){return l(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="套接字" tabindex="-1">套接字 <a class="header-anchor" href="#套接字" aria-label="Permalink to “套接字”">​</a></h1><p>套接字是实现跨进程通信的标准 API，被各大操作系统广泛支持，是现代网络通信的基础。通过套接字，应用程序可以方便地实现本地或跨主机的进程间数据交换。</p><h2 id="基本操作流程" tabindex="-1">基本操作流程 <a class="header-anchor" href="#基本操作流程" aria-label="Permalink to “基本操作流程”">​</a></h2><p>典型的网络服务端程序，通常包含以下步骤：</p><ol><li>创建套接字（socket）</li><li>绑定地址（bind）</li><li>监听连接（listen）</li><li>接受连接（accept）</li><li>数据收发（read/write/recv/send）</li><li>关闭连接（close）</li></ol><p>示例代码：</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建套接字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AF_INET, SOCK_STREAM, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定套接字到本机地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr_in address;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AF_INET;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_addr.s_addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INADDR_ANY;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 监听所有接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> htons</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PORT);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 绑定端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(address));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收客户端请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connect_fd;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞调用，该函数将阻塞线程，直至有客户端来连接 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connect_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">socklen_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addr_len);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> recv_buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ssize_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytes_received;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞调用，该函数将阻塞线程，直至客户端发送消息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((bytes_received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connect_fd, recv_buf, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recv_buf), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 处理接收到的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connect_fd);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="套接字类型与协议族" tabindex="-1">套接字类型与协议族 <a class="header-anchor" href="#套接字类型与协议族" aria-label="Permalink to “套接字类型与协议族”">​</a></h2><p>套接字支持多种协议族和类型，常见的有：</p><ul><li><code>AF_INET</code>：IPv4 网络协议</li><li><code>AF_INET6</code>：IPv6 网络协议</li><li><code>SOCK_STREAM</code>：面向连接的字节流（如 TCP）</li><li><code>SOCK_DGRAM</code>：无连接的数据报（如 UDP）</li><li><code>SOCK_RAW</code>：原始套接字，常用于实现自定义协议</li></ul><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UDP</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockfd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AF_INET, SOCK_DGRAM, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定、发送、接收与 TCP 类似，但不需要 listen/accept</span></span></code></pre></div><h3 id="选项与控制" tabindex="-1">选项与控制 <a class="header-anchor" href="#选项与控制" aria-label="Permalink to “选项与控制”">​</a></h3><p>通过 <code>setsockopt</code> 和 <code>getsockopt</code> 可以灵活控制套接字行为，例如：</p><ul><li>地址重用：<code>setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, ...)</code></li><li>设置发送/接收缓冲区大小</li><li>设置超时：<code>SO_RCVTIMEO</code>、<code>SO_SNDTIMEO</code></li><li>启用/禁用 Nagle 算法：<code>TCP_NODELAY</code> 这些选项有助于优化网络程序的性能和健壮性。</li></ul><h2 id="io-多路复用" tabindex="-1">IO 多路复用 <a class="header-anchor" href="#io-多路复用" aria-label="Permalink to “IO 多路复用”">​</a></h2><p>默认情况下，套接字操作是阻塞的，当程序想要等待客户端连接和从客户端读写数据的时候，它会陷入休眠，直到有数据到来，它才会被操作系统唤醒，从而开始执行响应。这样导致了一个 server 线程同时只能服务于一个客户。</p><p>可以通过如下方式设置为非阻塞模式：</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;fcntl.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fcntl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, F_GETFL, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fcntl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, F_SETFL, flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> O_NONBLOCK);</span></span></code></pre></div><p>IO 多路复用技术允许一个线程同时监听多个套接字和文件描述符，从而使得 server 的并发性和可用性获得提高。Linux 提供了多种 IO 多路复用机制：</p><ul><li><strong>select</strong>：通过 <code>fd_set</code> 结构维护文件描述符集合，适合少量连接，被广大系统支持，移植性好。简单，但是性能受限。不推荐。</li><li><strong>poll</strong>：支持更多文件描述符，接口更灵活。与 select 类似，连接更多一点，但是没多多少。不推荐。</li><li><strong>epoll</strong>：Linux 特有，适合大规模并发连接，效率高，常用于高性能服务器。编写难度大，推荐。</li></ul><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// epoll</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/epoll.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> epfd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epoll_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> epoll_event ev, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">events</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ev.events </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EPOLLIN;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ev.data.fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listen_fd;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">epoll_ctl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(epfd, EPOLL_CTL_ADD, listen_fd, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epoll_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(epfd, events, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>一般地，对于低并发场景可以使用多线程技术来进行编写，高并发场景推荐 epoll，这个分界线在 100-500 并发左右。更高的并发，需要引入协程和异步架构，实现起来较为复杂。但是，现代的编程语言，例如：Go，Rust 等有丰富的支持，开箱即用。</p><h2 id="分包与拆包" tabindex="-1">分包与拆包 <a class="header-anchor" href="#分包与拆包" aria-label="Permalink to “分包与拆包”">​</a></h2><p>由于 TCP 是流协议，消息边界不固定，应用层需要根据协议自行处理分包和拆包，确保数据完整性，并实现自己的业务逻辑，业务层的消息也需要自行封装逻辑。</p><p>如果不希望自己实现，可以使用已有的逻辑，例如 Http(s) 和 Ftp 等常见的协议，从而快速实现开发。另一方面，如果客户的设备没有相应的客户端协议实现，那么也无法通信，使用通用的协议可以降低沟通成本。但是，Http 的性能较差，在服务集群中，一般会进行自定义协议，例如各种 RPC 协议，例如：gRPC。</p><h3 id="头体分包" tabindex="-1">头体分包 <a class="header-anchor" href="#头体分包" aria-label="Permalink to “头体分包”">​</a></h3><p>头体分包算法是解决字节流边界，封装自定义协议的通用解决方案。同时也是适用任何基于字节数组和字节流的数据组织和管理的 算法。在基于 TCP 的网络通信中，由于 TCP 是字节流协议，消息边界不固定，常见的做法是采用“包头+包体”分包算法来解决粘包和拆包问题。</p><p>每条消息由“包头”和“包体”两部分组成：</p><ul><li><strong>包头</strong>：通常为固定长度（如 4 字节），用于存放包体长度（或类型、校验等信息）。最常见的是前 4 字节存放包体长度（不含包头本身）。</li><li><strong>包体</strong>：紧跟在包头之后，长度由包头指定，存放实际业务数据。</li></ul><p><strong>数据格式示例：</strong></p><table tabindex="0"><thead><tr><th>字节偏移</th><th>0~3</th><th>4~N</th></tr></thead><tbody><tr><td>内容</td><td>包体长度L</td><td>包体内容</td></tr></tbody></table><h4 id="发送方流程" tabindex="-1">发送方流程 <a class="header-anchor" href="#发送方流程" aria-label="Permalink to “发送方流程”">​</a></h4><ol><li>将要发送的数据序列化为字节流。</li><li>计算包体长度 L。</li><li>构造包头（如 4 字节，存放 L，通常用网络字节序）。</li><li>发送“包头+包体”拼接后的完整数据。</li></ol><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> htonl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(body_len);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 转为网络字节序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, body, body_len, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h4 id="接收方流程" tabindex="-1">接收方流程 <a class="header-anchor" href="#接收方流程" aria-label="Permalink to “接收方流程”">​</a></h4><ol><li>先读取固定长度的包头（如 4 字节）。</li><li>解析包头，获得包体长度 L。</li><li>再读取 L 字节的包体。</li><li>解析包体，处理业务。</li></ol><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 读取包头</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, MSG_WAITALL);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ntohl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 转为主机字节序</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 读取包体</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, body, len, MSG_WAITALL);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 处理 body</span></span></code></pre></div><p>头体分包方案具有很强的通用性和高效性，适用于各种基于字节流的协议。它只需简单的内存拷贝和长度判断即可完成数据的分包与组包，同时包头还可以灵活扩展，携带类型、校验、序号等元数据。广泛应用于自定义 TCP 协议、各类 RPC 框架（如 gRPC、Thrift 的底层实现）、以及游戏服务器、消息队列等高性能网络服务场景。</p><p>实际使用时，需要注意包头和包体的读取都要循环进行，确保读取到完整的数据，防止出现短读问题。同时，包头长度和字节序需要通信双方提前约定一致，包体长度也要做合理限制，避免恶意超大包体导致内存溢出等安全风险。</p><h3 id="字节序处理" tabindex="-1">字节序处理 <a class="header-anchor" href="#字节序处理" aria-label="Permalink to “字节序处理”">​</a></h3><p>网络通信要求通信的双方使用统一的字节序（网络字节序为大端），因为发包的时候，单个字节和数据的排列可以有两种方向，并且不同平台 CPU 的本地字节序可能不同，所以需要特别注意不管双方的 CPU 字节序如何，都需要在通信的时候统一使用大端序。常用字节序转换函数有：</p><ul><li><code>htons()</code>、<code>htonl()</code>：主机字节序转网络字节序</li><li><code>ntohs()</code>、<code>ntohl()</code>：网络字节序转主机字节序</li><li>内核开发常用：<code>cpu_to_le32()</code>、<code>cpu_to_le64()</code> 等</li></ul>`,42)])])}const c=i(h,[["render",k]]);export{g as __pageData,c as default};
