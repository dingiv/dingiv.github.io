import{_ as i,c as s,o as e,ah as l}from"./chunks/framework.C5lh6Kkj.js";const c=JSON.parse('{"title":"无锁并发","description":"","frontmatter":{},"headers":[],"relativePath":"design/concurrent/lock_free.md","filePath":"design/concurrent/lock_free.md"}'),n={name:"design/concurrent/lock_free.md"};function t(r,a,h,p,d,k){return e(),s("div",null,[...a[0]||(a[0]=[l(`<h1 id="无锁并发" tabindex="-1">无锁并发 <a class="header-anchor" href="#无锁并发" aria-label="Permalink to “无锁并发”">​</a></h1><p>无锁并发技术是在不使用锁的情况下解决并发问题的技术，区别于锁机制，往往性能更加高效。使用锁往往容易导致死锁问题。</p><p>其优点包括：</p><ul><li>避免死锁和优先级反转</li><li>提高并发性能，减少上下文切换</li><li>适合高性能、低延迟场景</li></ul><h2 id="原子操作" tabindex="-1">原子操作 <a class="header-anchor" href="#原子操作" aria-label="Permalink to “原子操作”">​</a></h2><p>依赖于硬件级别的能力，基于原子指令，对单一变量进行并发保证，可以基于此设计无锁队列和无锁环等数据结构，拥有极高的性能，且没有死锁。见<a href="./atom">原子操作</a></p><ul><li><strong>CAS（Compare-And-Swap）</strong>：最常用的无锁原语，广泛用于实现无锁队列、无锁栈等数据结构。CAS 思想是指，当希望修改一个值的时候，尝试先进行值的比较，如果当前的数字的值是预期值，则使用新的值替换它，否则失败，并且比较和替换的操作是通过原子指令保证不可打断；所以，很多时候在使用 CAS 的时候，我们会将它放在一个死循环中，让 CPU 陷入忙等重试，重复执行 CAS 操作，直到成功，由于该操作非常快，其实失败的概率并不大。</li><li><strong>原子计数器</strong>：如引用计数、统计计数等。</li><li><strong>环形缓冲区、无锁队列</strong>：常用于内核、网络、日志等高并发场景。</li></ul><h2 id="自旋忙等" tabindex="-1">自旋忙等 <a class="header-anchor" href="#自旋忙等" aria-label="Permalink to “自旋忙等”">​</a></h2><p>实现简单，但是延迟较高。CPU 需要一定的消耗。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 8ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="rcu" tabindex="-1">RCU <a class="header-anchor" href="#rcu" aria-label="Permalink to “RCU”">​</a></h2><p>Read-Copy-Update 机制，在 Linux 系统广泛使用，对于读者来说支持共享读，对于写者来说，自己创建一个副本，然后修改，修改完之后再替换原本的数据，高并发读场景中的无锁利器。但是，写慢读快，延迟回收。</p><h2 id="消息传递" tabindex="-1">消息传递 <a class="header-anchor" href="#消息传递" aria-label="Permalink to “消息传递”">​</a></h2><p>不共享变量，从源头上解决问题——使用通信来共享内存，而不是通过共享内存来通信。</p><p>实践中，往往使用 MessageChannel 对象来传递信息，而不是让不同线程直接去访问共享内存。</p>`,15)])])}const g=i(n,[["render",t]]);export{c as __pageData,g as default};
