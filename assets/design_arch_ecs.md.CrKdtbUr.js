import{_ as i,c as e,o as t,ae as a}from"./chunks/framework.CDjunVez.js";const u=JSON.parse('{"title":"ECS","description":"","frontmatter":{},"headers":[],"relativePath":"design/arch/ecs.md","filePath":"design/arch/ecs.md"}'),o={name:"design/arch/ecs.md"};function n(s,l,r,c,m,p){return t(),e("div",null,[...l[0]||(l[0]=[a('<h1 id="ecs" tabindex="-1">ECS <a class="header-anchor" href="#ecs" aria-label="Permalink to &quot;ECS&quot;">​</a></h1><p>ECS（Entity-Component-System）是一种主要用于渲染程序和游戏开发的架构模式，它通过将数据和行为分离来实现高度模块化和可扩展的系统设计。在游戏中，结合渲染引擎的渲染节奏，插空批量执行的游戏逻辑。</p><ul><li>模块化：ECS 架构通过将数据和行为分离，实现了高度的模块化设计。基于组合由于继承的思想，组件可以自由组合，系统可以独立开发，这使得添加新功能变得简单直接。开发者可以根据需要灵活地组合不同的组件来创建新的实体类型，而无需修改现有代码。</li><li>性能优化：ECS 架构在性能方面具有显著优势。由于组件数据存储在连续的内存空间中，数据局部性好，便于实现缓存友好型代码。这种设计特别适合处理大量相似对象，系统可以高效地遍历和处理相同类型的组件数据，从而提升整体性能。</li><li>可维护性：ECS 架构通过关注点分离，使代码结构更加清晰。每个系统只负责处理特定类型的组件，组件只包含数据，系统只包含逻辑，这种清晰的职责划分使得代码易于理解和维护。同时，由于系统和组件的独立性，单元测试也变得更为简单。</li><li>灵活性：ECS 架构提供了运行时的高度灵活性。实体可以在运行时动态添加或移除组件，系统可以独立启用或禁用，这使得游戏逻辑可以动态调整。这种灵活性还便于实现热重载功能，开发者可以在不重启游戏的情况下修改和测试代码。</li></ul><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h2><p>Entity（实体）</p><ul><li>实体是游戏世界中的基本单位</li><li>实体本身不包含任何数据或行为</li><li>实体只是一个唯一的标识符，用于组合不同的组件</li><li>例如：玩家、敌人、道具等都可以是实体</li></ul><p>Component（组件）</p><ul><li>组件是纯数据容器</li><li>每个组件只包含特定类型的数据</li><li>组件没有行为逻辑</li><li>常见组件示例： <ul><li>PositionComponent：位置信息</li><li>HealthComponent：生命值</li><li>SpriteComponent：精灵/图像</li><li>CollisionComponent：碰撞信息</li></ul></li></ul><p>System（系统）</p><ul><li>系统是处理逻辑的地方</li><li>每个系统负责处理特定类型的组件</li><li>系统不存储状态，只处理数据</li><li>常见系统示例： <ul><li>MovementSystem：处理移动</li><li>RenderingSystem：处理渲染</li><li>CollisionSystem：处理碰撞检测</li><li>HealthSystem：处理生命值变化</li></ul></li></ul><h2 id="对比-mvc" tabindex="-1">对比 MVC <a class="header-anchor" href="#对比-mvc" aria-label="Permalink to &quot;对比 MVC&quot;">​</a></h2><ul><li>并行性：ECS 是针对于 MVC 架构中，中间业务处理层的<em>并行性不够和批量化处理能力不够</em>的现实情况提出的业务处理模式。ECS 可以通过 System 抽象，将不同类型的业务进行并行化逻辑，提高了 CPU 的利用率。</li><li>批量化：ECS 与渲染程序的渲染节奏更加契合。渲染程序会采用一定的渲染节奏，每隔一段时间，触发一次批量化的业务逻辑计算，再进行画面的更新，而不是像 MVC 程序，例如 web server 那样，一旦接受到新的 IO 任务就开始一次业务分发和处理。这将有效提高程序在大规模 IO 事件和批量化任务面前的吞吐能力，但是在一定程度上引入了延迟，这也是为什么 server 程序不采用 ECS 的原因。</li></ul><blockquote><p>掉帧：ECS 可以极大地提高一次渲染循环中的业务处理计算量，但是，如果开发者在渲染循环中加入了阻塞任务，那么极有可能导致在渲染循环即将到来的下一个周期，还没能够处理完上一个周期的任务，因此错过了本轮的渲染画面更新，从而导致了掉帧的情况。掉帧对于用户来说，表现行为就是画面一卡一卡的。</p></blockquote>',13)])])}const S=i(o,[["render",n]]);export{u as __pageData,S as default};
