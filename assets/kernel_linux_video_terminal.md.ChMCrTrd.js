import{_ as t,o as l,c as a,ah as i}from"./chunks/framework.DYrKkesV.js";const m=JSON.parse('{"title":"终端系统","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/video/terminal.md","filePath":"kernel/linux/video/terminal.md"}'),r={name:"kernel/linux/video/terminal.md"};function n(p,e,s,o,d,h){return l(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="终端系统" tabindex="-1">终端系统 <a class="header-anchor" href="#终端系统" aria-label="Permalink to “终端系统”">​</a></h1><p>终端系统提供用户和系统交互接口的系统组件，它包含一套自下而上的完整链路。现代的带窗口系统的 GUI 应用以是基于此的。</p><h2 id="终端设备" tabindex="-1">终端设备 <a class="header-anchor" href="#终端设备" aria-label="Permalink to “终端设备”">​</a></h2><p>终端设备在 Linux 系统中用于抽象一个串口设备，属于字符类型的设备。它代表了用户与系统进行交互一个通道，是用户与系统交互的桥梁。得益于接口抽象，系统可以允许终端设备具有不同的下层实现，根据下层实现的不同，可以有三种不同类型的终端。</p><h3 id="物理终端" tabindex="-1">物理终端 <a class="header-anchor" href="#物理终端" aria-label="Permalink to “物理终端”">​</a></h3><p>物理终端是直接以硬件设备（如串口、键盘、显示器）交互的终端设备，通常通过串口（Serial Port）或类似硬件接口实现。Linux 内核通过 TTY 子系统管理这些设备。用户可以通过物理连线和真实终端来与计算机进行交互。</p><ul><li><p>硬件层，物理终端通常连接到串口设备（如 /dev/ttyS0），通过 UART（通用异步收发器）芯片与系统通信。数据以字符流形式通过串口传输，速度由波特率（如 9600、115200）控制。</p></li><li><p>内核层，主要通过 <strong>TTY 驱动</strong>来操作串口硬件（如 drivers/tty/serial/ 中的驱动）负责与硬件通信，处理中断和数据缓冲。上层<strong>行规程 Line Discipline</strong> 初步处理输入输出的格式化（如回车换行、回显控制）。并通过 VFS 将设备以字符设备的形式挂载到 /dev/ttyS0 等路径上。</p></li><li><p>用户空间，用户空间程序例如 getty 等监听用户命令从而处理用户请求和命令。一般地，getty 可能会为用户分配一个 shell 程序，把用户输入地命令直接重定向到 shell 中，然后让 shell 地输出结果返回给用户。</p><p>对一个物理串口文件进行读数据，意味着从物理串口的缓冲区中获取用户的输入，向其写数据意味着给用户呈现系统的数据显示。这个文件通常由 getty 服务等打开，然后读取数据，重定向到一个新建的 shell 程序中，shell 处理用户的命令，然后返回处理结果，然后 getty 服务再把处理结果写回到物理串口文件中，用户获得命令执行的结果。</p></li></ul><h3 id="虚拟终端" tabindex="-1">虚拟终端 <a class="header-anchor" href="#虚拟终端" aria-label="Permalink to “虚拟终端”">​</a></h3><p>虚拟终端是 Linux 提供的一种<strong>基于本地显示设备和本地输入设备</strong>的终端接口，运行在系统的帧缓冲区（Framebuffer）或 VGA 硬件上，通常对应 /dev/tty1 到 /dev/tty6。它们由内核的 VT 子系统管理，允许多用户在同一台机器上切换不同终端会话。</p><ul><li><p>硬件层，依赖显示设备（VGA、HDMI）或帧缓冲区（如 /dev/fb0）。键盘输入通过内核的输入子系统（input）处理。</p></li><li><p>内核层，<strong>VT 子系统</strong>：位于 drivers/tty/vt/，管理多个虚拟终端会话。每个虚拟终端对应一个 TTY 设备（如 /dev/tty1），由内核分配。<strong>TTY 驱动</strong>：与显示硬件和键盘驱动交互，处理字符显示和输入。Line Discipline：处理输入输出格式（如控制字符 Ctrl+C）。VFS 将虚拟终端显示到 <code>/dev/tty[N]</code> 路径上，一般会有 64 个，但是只会启用 6 个 或 7 个。</p><p>活动终端。由于本地显示设备和输入设备是有限的。系统只允许一个终端获得这些设备的使用权，称为活动终端。一个终端希望在本地的显示设备上显示图像，就必须先成为活动终端，同时，键盘鼠标的输入也会被系统路由到当前的活动终端中，而不是给处于后台状态的终端。</p></li><li><p>用户空间：用户运行 getty 进程，负责登录会话（显示登录提示）。用户通过 Ctrl+Alt+F1-F6 切换不同虚拟终端。一般地，只有一个 tty 能够占领当前的屏幕，其中的 tty</p><p>在拥有窗口系统的机器上，窗口系统（如 X11 或 Wayland）通常占用一个虚拟终端（如 /dev/tty7）。在系统启动的时候，设置默认打开 tty7，显示窗口系统。窗口系统负责渲染整个屏幕的内容，上层 GUI 程序可以通过调用窗口系统提供的接口在此基础上创建自己的窗口程序。</p></li></ul><h3 id="伪终端-pty" tabindex="-1">伪终端（PTY） <a class="header-anchor" href="#伪终端-pty" aria-label="Permalink to “伪终端（PTY）”">​</a></h3><p>伪终端（PTY）是软件模拟的终端设备，用于图形化终端模拟器（如 GNOME Terminal）、SSH 会话或终端复用工具（如 tmux）。它们不依赖物理硬件，而是通过内核的 PTY 子系统实现。基于虚拟的<strong>主从设备对</strong>来实现。</p><ul><li><p>硬件层，无直接硬件依赖，完全由软件模拟。终端模拟器通过打开 /dev/ptmx 设备从而分配一个伪终端设备，被挂载到 <code>/dev/pts/[N]</code> 路径下。从而初始化一个主从设备对。</p><p>终端模拟器是使用纯软件编写的能够模拟终端硬件的用户操作界面软件，它负责与用户交互，收集用户的输入，然后将用户的输入写入主设备中，然后用户数据就会从从设备中输出，另一端的 shell 程序可以读取这些输入，得知用户的命令，然后执行相应的命令与系统交互，然后再把执行结果写回到从设备中，然后数据从主设备中输出，这个时候，终端模拟器读取这些结果数据，并采用美观的表现形式，包括但不限于排版、图形化，给用户呈现结果。</p><p>SSH 客户端也会打开主设备为远程登录的用户动态创建伪终端，从而让远程用户也能够操作机器。</p></li><li><p>内核层，PTY 子系统：位于 drivers/tty/pty.c，提供主从设备对（Master/Slave Pair）。主设备：/dev/ptmx，由<strong>终端模拟器或 SSH 守护进程</strong>打开。从设备：/dev/pts/0 等，分配给具体会话。数据流：主设备接收用户程序的输入，传递给从设备；从设备输出（如 shell 的结果）返回给主设备。Line Discipline：与物理终端类似，处理字符格式化。</p></li><li><p>用户空间，同上。</p></li></ul>',13)])])}const T=t(r,[["render",n]]);export{m as __pageData,T as default};
