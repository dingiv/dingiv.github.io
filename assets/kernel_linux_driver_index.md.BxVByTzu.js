import{_ as l,c as a,o as s,ae as e}from"./chunks/framework.Dgg8-8ov.js";const c=JSON.parse('{"title":"设备管理","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/driver/index.md","filePath":"kernel/linux/driver/index.md"}'),t={name:"kernel/linux/driver/index.md"};function p(n,i,h,d,o,r){return s(),a("div",null,i[0]||(i[0]=[e('<h1 id="设备管理" tabindex="-1">设备管理 <a class="header-anchor" href="#设备管理" aria-label="Permalink to &quot;设备管理&quot;">​</a></h1><p>硬件设备管理是操作系统的核心职责之一。在冯诺依曼架构下，设备主要就是 CPU、内存和其他。CPU 和内存会采用一些单独的管理机制，对此之外的其他设备，均采用一种较为统一的管理机制——驱动机制。</p><h3 id="io设备" tabindex="-1">IO设备 <a class="header-anchor" href="#io设备" aria-label="Permalink to &quot;IO设备&quot;">​</a></h3><p>操作系统内核不直接操作设备：</p><ul><li>通过调用设备的驱动程序完成对设备的读写</li><li>驱动程序由硬件厂商实现</li><li>使用设备时，将驱动程序以内核模块方式加载进内核</li><li>操作系统声明统一的SPI（Service Program Interface），由硬件厂商实现</li></ul><h3 id="可编程io-dma" tabindex="-1">可编程IO/DMA <a class="header-anchor" href="#可编程io-dma" aria-label="Permalink to &quot;可编程IO/DMA&quot;">​</a></h3><p>根据数据传输过程是否需要CPU参与，IO分为两类：</p><ol><li><p>可编程IO</p><ul><li>操作系统通过读写IO设备寄存器控制设备</li><li>分为两种类型： <ul><li>PMIO（Port-Mapped Input/Output）：通过访问IO端口控制设备</li><li>MMIO（Memory-Mapped Input/Output）：设备寄存器和缓冲区映射到物理内存中</li></ul></li></ul></li><li><p>DMA（Direct Memory Access）</p><ul><li>外设与内存之间交换数据的接口技术</li><li>数据传输过程无须CPU控制</li><li>数据拷贝和搬运由外设专用处理器完成</li><li>操作系统通过驱动程序提前告知外设数据拷贝位置</li><li>外设直接访问内存，将数据放到指定位置</li><li>完成后发起中断通知CPU</li></ul></li></ol><h2 id="io管理" tabindex="-1">IO管理 <a class="header-anchor" href="#io管理" aria-label="Permalink to &quot;IO管理&quot;">​</a></h2><p>IO设备拥有独立的控制处理器，现代IO设备通过MMIO方式将自身寄存器地址空间映射到物理内存空间中，让CPU通过直接读写物理地址空间来控制IO设备。</p><h3 id="设备挂载" tabindex="-1">设备挂载 <a class="header-anchor" href="#设备挂载" aria-label="Permalink to &quot;设备挂载&quot;">​</a></h3><ol><li><p>设备识别和驱动加载</p><ul><li>识别设备：操作系统检测设备并分配设备文件（Linux中通常位于<code>/dev/</code>目录下）</li><li>加载驱动：操作系统加载适当的驱动程序支持设备操作</li></ul></li><li><p>设备格式化</p><ul><li>存储设备需要经过格式化才能使用</li><li>格式化将物理存储空间划分为存储区域</li><li>为这些区域建立文件系统</li><li>未格式化的存储设备不能直接存储文件和数据</li></ul><p>文件系统格式化：</p><ul><li>文件系统是操作系统管理磁盘上文件的方式</li><li>不同操作系统使用不同的文件系统格式（ext4、NTFS、FAT32、exFAT等）</li><li>分区表（MBR或GPT）定义设备上不同部分的布局和大小</li></ul><p>例如，在Linux中格式化磁盘分区：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkfs.ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载存储设备</p><ul><li>格式化后，存储设备的文件系统才可用</li><li>挂载操作将设备上的文件系统与操作系统的目录结构连接</li><li>用户可以通过路径访问存储设备的内容</li></ul><p>在Linux中挂载设备：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div></li><li><p>文件系统检查与修复</p><ul><li>文件系统可能因突然断电或设备损坏而不一致</li><li>操作系统执行文件系统检查（fsck）修复问题</li></ul><p>在Linux中手动运行文件系统检查：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fsck</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载配置（可选）</p><ul><li>可以将存储设备配置为系统启动时自动挂载</li><li>通过编辑<code>/etc/fstab</code>文件完成配置</li></ul><p>例如，添加以下行将设备<code>/dev/sda1</code>挂载到<code>/mnt</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> defaults</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div></li></ol><h3 id="iommu" tabindex="-1">IOMMU <a class="header-anchor" href="#iommu" aria-label="Permalink to &quot;IOMMU&quot;">​</a></h3><p>IOMMU（IO设备内存空间管理单元）：</p><ul><li>在一些硬件平台上支持IOMMU技术</li><li>添加IOMMU单元，在CPU访问物理内存地址时添加类似MMU的内存虚拟技术</li><li>针对IO设备</li><li>通常伴随DMA一同出现</li></ul>',15)]))}const k=l(t,[["render",p]]);export{c as __pageData,k as default};
