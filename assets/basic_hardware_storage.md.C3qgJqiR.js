import{_ as e,c as l,o as i,ae as r}from"./chunks/framework.Dgg8-8ov.js";const p=JSON.parse('{"title":"存储","description":"","frontmatter":{},"headers":[],"relativePath":"basic/hardware/storage.md","filePath":"basic/hardware/storage.md"}'),t={name:"basic/hardware/storage.md"};function o(h,a,n,s,d,c){return i(),l("div",null,a[0]||(a[0]=[r('<h1 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h1><p>存储能力是计算机能力的重要组成。计算机存储的数据是通过编码技术进行的按规则映射，是一种约定的契约或者协议。计算机存储以 <strong>8 bit</strong> 数 —— <strong>1 字节</strong>为单位。存储设备往往可以被理解成一个长长的数组，它的每一个元素是一个字节，</p><h2 id="分级存储" tabindex="-1">分级存储 <a class="header-anchor" href="#分级存储" aria-label="Permalink to &quot;分级存储&quot;">​</a></h2><p>存储系统是一个多级的缓存结构，其实践的理由是时间和空间权衡。大量的存储意味着数据查询困难，速度慢；快速的数据查询意味着，存储量少，造价昂贵。</p><h3 id="寄存器" tabindex="-1">寄存器 <a class="header-anchor" href="#寄存器" aria-label="Permalink to &quot;寄存器&quot;">​</a></h3><p>寄存器是 CPU 内部的高速存储单元，是存储层级中最快的存储设备。它们直接集成在 CPU 芯片上，访问延迟通常在 1 个时钟周期内。寄存器的容量很小，通常只有几十到几百个字节，但速度极快。主要用于存储 CPU 当前正在处理的数据和指令。</p><p>寄存器通常可以看作是一个字节数组，是一个线性的存储结构，其中的</p><h3 id="cpu-缓存" tabindex="-1">CPU 缓存 <a class="header-anchor" href="#cpu-缓存" aria-label="Permalink to &quot;CPU 缓存&quot;">​</a></h3><p>CPU 缓存是位于 CPU 和主内存之间的高速缓冲存储器，分为 L1、L2、L3 三级：</p><ul><li>L1 缓存：速度最快，容量最小（通常为 32KB-64KB），分为指令缓存和数据缓存</li><li>L2 缓存：速度次之，容量较大（通常为 256KB-2MB）</li><li>L3 缓存：速度较慢，容量最大（通常为 2MB-32MB），在多核 CPU 中共享 缓存采用 SRAM（静态随机访问存储器）技术，相比 DRAM 速度更快但成本更高。</li></ul><h3 id="内存" tabindex="-1">内存 <a class="header-anchor" href="#内存" aria-label="Permalink to &quot;内存&quot;">​</a></h3><p>内存（RAM）是计算机的主存储器，采用 DRAM（动态随机访问存储器）技术。主要特点：</p><ul><li>访问速度：比 CPU 缓存慢，但比硬盘快得多</li><li>容量：通常为 4GB-64GB</li><li>易失性：断电后数据会丢失</li><li>价格：比硬盘贵，但比 CPU 缓存便宜 内存通过内存控制器与 CPU 通信，采用 DDR（双倍数据速率）技术提高传输效率。</li></ul><p>内存条的物理结构可以近似看作是一个大型的数组，可以通过地址逐字节访问，但是其实内存条内部可以分成多个块，并且可以并行访问提高速度，但是，操作系统为了简化内存的访问，会抽象一个内存访问器来屏蔽不同的内存条之间的差异。</p><h4 id="内存地址" tabindex="-1">内存地址 <a class="header-anchor" href="#内存地址" aria-label="Permalink to &quot;内存地址&quot;">​</a></h4><p>内存地址是内存中每个字节的唯一标识符，在 32 位的硬件平台上，内存地址是一个 32 位的整数，它的范围是 0x00000000 到 0xFFFFFFFF。内存地址的长度是 32 位，这意味着内存地址的范围是 2^32 个字节，也就是 4GB。在 64 位的硬件平台上，内存地址的长度是 64 位，这意味着内存地址的范围是 2^64 个字节，也就是 16EB。</p><h3 id="磁盘" tabindex="-1">磁盘 <a class="header-anchor" href="#磁盘" aria-label="Permalink to &quot;磁盘&quot;">​</a></h3><p>磁盘是计算机的主要外部存储设备，主要分为机械硬盘（HDD）和固态硬盘（SSD）两种：</p><h4 id="机械硬盘-hdd" tabindex="-1">机械硬盘（HDD） <a class="header-anchor" href="#机械硬盘-hdd" aria-label="Permalink to &quot;机械硬盘（HDD）&quot;">​</a></h4><ul><li>工作原理：通过磁头在旋转的磁盘表面读写数据</li><li>容量：通常为 500GB-20TB</li><li>速度：读写速度较慢，随机访问延迟高</li><li>价格：单位容量价格最低</li><li>寿命：较长，但怕震动</li></ul><h4 id="固态硬盘-ssd" tabindex="-1">固态硬盘（SSD） <a class="header-anchor" href="#固态硬盘-ssd" aria-label="Permalink to &quot;固态硬盘（SSD）&quot;">​</a></h4><ul><li>工作原理：使用闪存（Flash Memory）存储数据</li><li>容量：通常为 128GB-4TB</li><li>速度：读写速度快，随机访问延迟低</li><li>价格：比 HDD 贵</li><li>寿命：有写入次数限制</li></ul><h4 id="磁盘接口" tabindex="-1">磁盘接口 <a class="header-anchor" href="#磁盘接口" aria-label="Permalink to &quot;磁盘接口&quot;">​</a></h4><ul><li>SATA：传统接口，速度较慢</li><li>NVMe：新一代接口，采用 PCIe 通道，速度更快</li><li>M.2：物理接口标准，支持 SATA 和 NVMe 协议</li></ul><h2 id="存储技术的未来展望" tabindex="-1">存储技术的未来展望 <a class="header-anchor" href="#存储技术的未来展望" aria-label="Permalink to &quot;存储技术的未来展望&quot;">​</a></h2><p>在存储技术领域，多个创新方向正在并行发展。</p><h2 id="新型存储介质的研发" tabindex="-1">新型存储介质的研发 <a class="header-anchor" href="#新型存储介质的研发" aria-label="Permalink to &quot;新型存储介质的研发&quot;">​</a></h2><p>包括相变存储器（PCM）、磁阻随机存取存储器（MRAM）和 3D XPoint 技术。相变存储器利用材料在晶态和非晶态之间的相变来存储数据，具有比闪存更快的读写速度和更高的耐久性，有望成为 DRAM 和 SSD 之间的新层级。磁阻随机存取存储器则利用电子自旋来存储数据，具有非易失性、接近 DRAM 的读写速度以及低功耗特性，特别适合移动设备应用。3D XPoint 作为英特尔和美光联合开发的新型存储技术，其性能比 NAND 闪存快 1000 倍，同时成本低于 DRAM，为非易失性存储提供了新的选择。</p><h2 id="存储架构创新" tabindex="-1">存储架构创新 <a class="header-anchor" href="#存储架构创新" aria-label="Permalink to &quot;存储架构创新&quot;">​</a></h2><p>计算存储（Computational Storage）通过在存储设备中集成计算能力，减少数据在存储和 CPU 之间的传输，显著提高了数据处理效率并降低了系统延迟。存储级内存（Storage Class Memory）则试图结合 DRAM 的速度和 SSD 的容量优势，可能从根本上改变现有的存储层级结构，为持久化存储提供更快的解决方案。分布式存储技术，特别是软件定义存储（SDS）的普及，带来了更灵活的存储资源管理、更好的可扩展性，以及对混合云环境的支持。</p>',30)]))}const P=e(t,[["render",o]]);export{p as __pageData,P as default};
