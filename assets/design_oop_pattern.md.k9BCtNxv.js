import{_ as e,o as r,c as t,ah as n}from"./chunks/framework.DYrKkesV.js";const _=JSON.parse('{"title":"设计模式","description":"","frontmatter":{"title":"设计模式","order":2},"headers":[],"relativePath":"design/oop/pattern.md","filePath":"design/oop/pattern.md"}'),i={name:"design/oop/pattern.md"};function o(l,a,h,d,s,p){return r(),t("div",null,[...a[0]||(a[0]=[n('<h1 id="设计模式概述" tabindex="-1">设计模式概述 <a class="header-anchor" href="#设计模式概述" aria-label="Permalink to “设计模式概述”">​</a></h1><p>设计模式是指在软件设计中，对反复出现的问题提出的通用、可复用的解决方案。它不是具体的代码片段，而是一种经过验证的设计模板或思路，可以根据具体场景进行调整和实现。设计模式是软件开发中常见问题的典型解决方案，目的是让代码更易维护、易扩展、易理解、可复用。</p><h2 id="_23-种经典设计模式" tabindex="-1">23 种经典设计模式 <a class="header-anchor" href="#_23-种经典设计模式" aria-label="Permalink to “23 种经典设计模式”">​</a></h2><p>根据 GoF（Gang of Four）的经典分类，设计模式分为创建型、结构型和行为型三大类。创建型模式共 5 种，包括单例、工厂方法、抽象工厂、建造者、原型，主要控制对象的创建方式。结构型模式共 7 种，包括适配器、桥接、组合、装饰、外观、享元、代理，主要处理类或对象之间的组合结构。行为型模式共 11 种，包括观察者、策略、命令、状态、模板方法、责任链、访问者、中介者、迭代器、备忘录、解释器，主要处理类或对象之间的职责分配与通信。</p><h2 id="创建型模式" tabindex="-1">创建型模式 <a class="header-anchor" href="#创建型模式" aria-label="Permalink to “创建型模式”">​</a></h2><p>创建型模式关注对象的创建过程，将对象的创建和使用分离。单例模式保证一个类只有一个实例，常见的应用场景包括配置管理器、日志记录器、数据库连接池。工厂模式通过工厂类创建对象，客户端不需要知道具体创建逻辑，简单工厂用一个工厂类创建所有产品，工厂方法为每个产品定义一个工厂子类，抽象工厂通过多个工厂方法创建产品族。建造者模式分步骤创建复杂对象，常见于构建器（Builder）模式的链式调用。原型模式通过复制现有对象创建新对象，减少创建成本。</p><h2 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to “结构型模式”">​</a></h2><p>结构型模式关注类和对象的组合，形成更大的结构。适配器模式将不兼容的接口转换为兼容的接口，常见于新旧系统对接。桥接模式将抽象部分和实现部分分离，使它们可以独立变化。组合模式将对象组合成树形结构来表示部分整体层次结构，常用于处理树形数据。装饰器模式动态地给对象添加额外功能，不改变其结构，常见的如中间件系统。外观模式为复杂子系统提供简单接口，隐藏子系统复杂性。享元模式通过共享对象减少内存占用，常见于对象池。代理模式为其他对象提供代理以控制对这个对象的访问，常见于远程代理、虚拟代理、保护代理。</p><h2 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to “行为型模式”">​</a></h2><p>行为型模式关注对象之间的通信和职责分配。观察者模式定义对象间的一对多依赖关系，当一个对象改变状态时所有依赖者都会收到通知，这是事件驱动架构的基础。策略模式定义一系列算法把它们封装起来，使它们可以互相替换，常见于支付方式、排序算法等场景。命令模式将请求封装成对象，从而允许用不同的请求对客户进行参数化，常见于撤销重做功能。状态模式允许对象在内部状态改变时改变它的行为，常见于工作流、订单状态流转。模板方法模式在父类中定义算法骨架，将某些步骤延迟到子类实现，常见于框架设计。责任链模式将请求沿处理链传递，直到有对象处理它，常见于日志记录、异常处理。访问者模式在不改变类结构的前提下定义新操作，常见于编译器语法树处理。中介者模式用一个中介对象封装一系列对象交互，降低对象间耦合。迭代器模式提供访问集合元素的统一接口，常见于遍历集合。备忘录模式在不破坏封装的前提下捕获对象内部状态，常见于撤销功能。解释器模式给定语言定义其文法表示，常见于配置文件解析、SQL 解析。</p><h2 id="现代开发中最常用的模式" tabindex="-1">现代开发中最常用的模式 <a class="header-anchor" href="#现代开发中最常用的模式" aria-label="Permalink to “现代开发中最常用的模式”">​</a></h2><p>2026 年实际开发中最常写的模式包括单例、工厂（简单工厂加工厂方法）、观察者或发布订阅、策略、装饰器、适配器、代理。框架里大量使用依赖注入容器，它本质上是工厂加策略加代理的组合。微服务和分布式系统中的熔断器、限流器、降级、负载均衡器、重试、幂等等机制，很多也是模式思想的延伸。前端开发中，Vue 和 React 的响应式系统本质是观察者模式，组件树是组合模式的应用，高阶组件（HOC）类似于装饰器模式，状态机（如 XState）则是状态模式的体现。</p><h2 id="反模式" tabindex="-1">反模式 <a class="header-anchor" href="#反模式" aria-label="Permalink to “反模式”">​</a></h2>',13)])])}const f=e(i,[["render",o]]);export{_ as __pageData,f as default};
