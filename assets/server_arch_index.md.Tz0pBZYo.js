import{_ as e,c as r,o as t,ae as s}from"./chunks/framework.BQlYxExx.js";const o="/assets/web-dns.ms2Z9KlI.png",i="/assets/single.dio.B37jTiUa.svg",n="/assets/multi.dio.Bjw_RSMt.svg",u=JSON.parse('{"title":"集群架构","description":"","frontmatter":{"title":"集群架构","order":40},"headers":[],"relativePath":"server/arch/index.md","filePath":"server/arch/index.md"}'),l={name:"server/arch/index.md"};function p(d,a,h,c,_,g){return t(),r("div",null,[...a[0]||(a[0]=[s('<h1 id="web-集群架构" tabindex="-1">Web 集群架构 <a class="header-anchor" href="#web-集群架构" aria-label="Permalink to &quot;Web 集群架构&quot;">​</a></h1><p>服务端面临着巨大的流量压力，而自摩尔定律失效后，单机性能增长缓慢，多线程和分布式技术兴起，以横向扩展的方式增加系统的吞吐能力。</p><p><img src="'+o+'" alt=""></p><h2 id="常见架构" tabindex="-1">常见架构 <a class="header-anchor" href="#常见架构" aria-label="Permalink to &quot;常见架构&quot;">​</a></h2><h3 id="单机架构" tabindex="-1">单机架构 <a class="header-anchor" href="#单机架构" aria-label="Permalink to &quot;单机架构&quot;">​</a></h3><p>基于一个主服务进程的服务器，显著受限于单机的性能和软件的算法实现。而后出现了前后端分离的技术，将客户端的页面渲染和服务端的接口处理进行隔离，初步将一部分的服务器压力转移到了客户端的设备上。典型特征就是，使用 Vue 等前端框架单独编写前端页面，并且托管到静态服务器（Nginx）或者渲染服务器（SSR server）上；客户端下载后，由客户的浏览器等设备进行渲染操作，极大地卸载了服务器的压力。</p><p><img src="'+i+'" alt=""></p><h3 id="多机架构" tabindex="-1">多机架构 <a class="header-anchor" href="#多机架构" aria-label="Permalink to &quot;多机架构&quot;">​</a></h3><p>随着访问量的增加，单机依旧架构无法满足吞吐量的需求，可以开启多个服务器进程，形成多机架构；面向前端时，多机架构引入了负载均衡的策略，使用分发服务器（例如 nginx）对请求进行分发。</p><p><img src="'+n+'" alt=""></p><p>要想实现从单机架构向多机架构的重构，必须做到<strong>主体服务程序的无状态化</strong>。总体思路就是，将主体服务程序中的状态抽离出来，托管到一个独立的外部服务中去，其中，状态分为两种，一种控制面的状态，一种是数据面的状态。控制面状态管理服务被称为<strong>配置中心</strong>，数据面状态服务被称为<strong>数据库</strong>。集群中的服务实例不应该在进程中保存状态，应当通过发送 http 请求或者 RPC 调用向数据管理服务进行获取。</p><p>配置中心负责管理和分发集群中主体服务程序的控制面配置，同时可能还会负责<strong>心跳检测</strong>，集群中的每个服务程序实例必须定期向配置中心发送心跳，或者配置中心向服务实例发送心跳，以此来检测服务实例的可用性。</p><p>数据库负责存储和管理数据面的数据，并实现数据读写的并发控制。数据是整个系统的最上游和交会处，承担着极大的性能压力和并发要求，在此时，数据库成为了系统中新的瓶颈。为此，我们将采用多种手段减少数据库的压力，包括但不限于：缓存技术、分库分表、数据库集群……</p><h3 id="微服务架构" tabindex="-1">微服务架构 <a class="header-anchor" href="#微服务架构" aria-label="Permalink to &quot;微服务架构&quot;">​</a></h3><p>多机架构解决了服务程序的吞吐能力，但是整个集群的瓶颈转移到了数据库上，同时，随着业务的复杂度升高，多机架构将所有的业务逻辑放在同一个程序中，每个业务实例均需要处理全部的业务。为此，提出了微服务架构和分库分表方案。将一个大型的互联网项目拆分成一个个相对独立内聚的小模块，各自管理自己的一个数据库，提供单一的服务功能——由此称之为<strong>微服务</strong>。</p><p>微服务之间可能需要相互依赖，那么在一个服务需要调用另一个服务的功能的时候，它会通过 RPC 调用去访问上游服务，从而获得数据。那么，一个服务如何获知集群中它需要的上游的服务的 IP 呢？它如何确认它所要访问的服务是否还依然存活呢？此时，集群中需要引入一个新的组件用于执行<strong>服务发现</strong>的功能。</p><h3 id="云原生架构" tabindex="-1">云原生架构 <a class="header-anchor" href="#云原生架构" aria-label="Permalink to &quot;云原生架构&quot;">​</a></h3><p>Docker 容器的提出无疑是云时代的基石技术，而随后的 k8s <strong>容器编排系统</strong>更是在此基础上的妙笔。容器编排是在操作系统上抽象的一个新层次，达到了一石多鸟的效果，包括但不限于：</p><ul><li>部署简化</li><li>弹性部署</li><li>分布式下沉，将微服务中的运维管理和分布式协议的功能下沉到容器管理平台去做，从而让业务逻辑和集群的管理逻辑分离，减轻了开发人员的负担，同时屏蔽了不同语言之间的交互；</li><li>自动化运维</li><li>新模式开发，开发了函数计算和 Serverless 服务等新型服务。</li></ul>',19)])])}const b=e(l,[["render",p]]);export{u as __pageData,b as default};
