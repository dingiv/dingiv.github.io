import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.CBTkueSR.js";const g=JSON.parse('{"title":"块设备子系统","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/file/block.md","filePath":"kernel/linux/file/block.md"}'),t={name:"kernel/linux/file/block.md"};function k(h,s,e,p,r,d){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="块设备子系统" tabindex="-1">块设备子系统 <a class="header-anchor" href="#块设备子系统" aria-label="Permalink to &quot;块设备子系统&quot;">​</a></h1><p>块设备子系统是工作在文件系统和设备管理层中间的代理层。它负责使用设备管理层提供的块设备驱动读写磁盘文件，并提供异步 IO、IO 批处理等功能；同时，其提供了统一的接口，为文件系统软件封装了不同的磁盘的驱动差异，并为文件系统提供了一种基于 bio 请求的交互方式，让文件系统只需要专注于自身的逻辑即可。</p><ul><li>VFS</li><li>文件系统</li><li>块设备子系统</li><li>设备管理子系统 <ul><li>块设备驱动</li><li>块设备抽象</li><li>物理磁盘</li></ul></li></ul><h2 id="主要功能" tabindex="-1">主要功能 <a class="header-anchor" href="#主要功能" aria-label="Permalink to &quot;主要功能&quot;">​</a></h2><ul><li>I/O 请求管理：接收文件系统或用户态的 I/O 请求（struct bio），转换为设备驱动可处理的格式。通过 struct request_queue 管理请求队列，支持合并、排序和调度优化。<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 封装单个 io 请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bio {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bio </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bi_next;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              /* Next bio in chain */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block_device </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bi_bdev;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     /* Target block device */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> short</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bi_flags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          /* Status and command flags */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> short</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bi_opf;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /* Operation flags (e.g., REQ_OP_READ) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> short</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bi_ioprio;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* I/O priority */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bvec_iter bi_iter;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* Iterator for data transfer */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bio_vec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bi_io_vec;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* Vector of data pages */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    bio_end_io_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bi_end_io;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          /* Completion callback */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bi_private;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 /* Private data for callback */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    atomic_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bi_remaining;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /* Reference count for completion */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// IO 请求队列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request_queue {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list_head queue_head;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* List of pending requests */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">last_merge;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       /* Last merged request */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elevator_queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">elevator;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* I/O scheduler (e.g., deadline) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   make_request_fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">make_request_fn;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Direct bio processing function */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blk_queue_ctx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue_ctx;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* Queue context */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue_flags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* Queue properties (e.g., QUEUE_FLAG_MQ) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li>设备抽象：提供 struct block_device 和 struct gendisk，抽象块设备（如 /dev/sda）和分区（如 /dev/sda1）。屏蔽底层硬件差异（如 SATA、NVMe），为文件系统提供统一接口。<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于抽象一个磁盘分区</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block_device {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    dev_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bd_dev;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                     /* Device number (major:minor) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gendisk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bd_disk;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          /* Associated gendisk */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bd_inode;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           /* VFS inode for device file */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block_device </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bd_contains;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Parent device (e.g., sda for sda1) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hd_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bd_part;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* Partition info, if applicable */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list_head bd_list;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* List of block devices */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bd_private;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* Driver-specific data */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于抽象一个物理磁盘</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gendisk {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> major;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                        /* Major number */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first_minor;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  /* First minor number */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> minors;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                       /* Number of minors */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> disk_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[DISK_NAME_LEN];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Device name (e.g., &quot;sda&quot;) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block_device_operations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fops;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Driver operations */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request_queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       /* I/O request queue */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private_data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                /* Driver-specific data */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> disk_part_tbl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">part_tbl;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /* Partition table */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li>I/O 调度：使用调度器（如 CFQ、deadline、noop）优化 I/O 性能，减少磁盘寻道时间，提高吞吐量。</li><li>异步 I/O 支持：支持异步 I/O，通过 bio-&gt;bi_end_io 回调通知请求完成，降低延迟。</li><li>分区与设备管理：支持分区表解析（如 GPT、MBR），管理设备状态（如热插拔）。通过 sysfs（如 /sys/block/sda）暴露设备信息和配置。</li></ul><h2 id="读文件工作流程" tabindex="-1">读文件工作流程 <a class="header-anchor" href="#读文件工作流程" aria-label="Permalink to &quot;读文件工作流程&quot;">​</a></h2><ul><li>I/O 请求生成：文件系统（如 ext4）或用户态程序通过 VFS 发起 I/O 请求。ext4 通过 super_block-&gt;s_bdev 创建 struct bio，指定目标扇区和数据。</li><li>请求提交：调用 submit_bio，将 bio 送入 block_device-&gt;bd_disk-&gt;queue。子系统可能将多个 bio 合并为 struct request，或直接处理（make_request_fn 模式，如 NVMe）。</li><li>I/O 调度：request_queue 使用调度器（如 deadline）对请求排序、合并，优化性能。</li><li>驱动处理：驱动通过 gendisk-&gt;fops-&gt;submit_bio 或队列的 request_fn 处理请求。请求转换为硬件命令（如 SCSI 命令），通过中断完成。</li><li>完成通知：硬件完成 I/O，触发中断，驱动调用 bio-&gt;bi_end_io 通知文件系统。文件系统更新元数据，完成操作。</li></ul>`,7)])])}const c=i(t,[["render",k]]);export{g as __pageData,c as default};
