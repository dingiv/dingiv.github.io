import{_ as i,o as a,c as n,ah as t}from"./chunks/framework.D8J2w7BQ.js";const o=JSON.parse('{"title":"Prolog","description":"","frontmatter":{"title":"Prolog","order":2},"headers":[],"relativePath":"ai/symbol/prolog.md","filePath":"ai/symbol/prolog.md"}'),h={name:"ai/symbol/prolog.md"};function l(p,s,k,e,r,d){return a(),n("div",null,[...s[0]||(s[0]=[t(`<h1 id="prolog" tabindex="-1">Prolog <a class="header-anchor" href="#prolog" aria-label="Permalink to “Prolog”">​</a></h1><p>符号 AI 的编程范式与普通命令式编程貌似相似，但是存在显著区别。理解这种差异是掌握经典符号主义 AI 的关键，也能帮助我们看清现代神经网络方法与早期符号方法的根本分歧。</p><h2 id="声明式与命令式" tabindex="-1">声明式与命令式 <a class="header-anchor" href="#声明式与命令式" aria-label="Permalink to “声明式与命令式”">​</a></h2><p>普通编程语言如 C、Python、Java 采用命令式范式，开发者描述&quot;怎么做&quot;——即执行步骤的序列。程序的控制流由开发者预先写好，计算机按指令机械执行。符号 AI 采用声明式范式，开发者只需描述&quot;是什么&quot;——即领域知识和逻辑规则，推理引擎负责自动推导结论。</p><p>这种差异在实践中表现明显。用 Python 写一个动物分类程序，开发者需要穷举所有可能的条件分支，程序只能按预设的代码路径执行，无法产生开发者未预料的新结论。用 Prolog 实现同样功能，只需声明事实和规则，引擎会自动搜索解空间，甚至能推导出开发者未曾显式编码的新知识。</p><h2 id="知识与控制分离" tabindex="-1">知识与控制分离 <a class="header-anchor" href="#知识与控制分离" aria-label="Permalink to “知识与控制分离”">​</a></h2><p>符号 AI 的核心架构原则是知识库与推理引擎分离。知识库存储领域特定的事实和规则，推理引擎是通用的逻辑求解器。修改系统行为只需更新知识库，无需改动推理引擎。这种分离使得同一推理引擎可以应用于完全不同的领域，专家系统的开发成本大幅降低。</p><p>普通程序的知识与控制是交织在一起的。业务逻辑直接硬编码在控制流中，修改行为需要重写代码、重新编译部署。编译器将高级语言翻译成机器码，执行时仍然是固定的指令序列，不存在搜索、回溯或自动规则匹配。符号推理引擎更像一个通用定理证明器，在运行时根据当前事实集动态搜索规则空间，支持统一和回溯机制。</p><h2 id="prolog-语言基础" tabindex="-1">Prolog 语言基础 <a class="header-anchor" href="#prolog-语言基础" aria-label="Permalink to “Prolog 语言基础”">​</a></h2><p>Prolog 程序由三种语句构成：事实、规则和查询。事实是无条件为真的原子命题，如 <code>parent(john, mary)</code> 表示 John 是 Mary 的父母。规则描述条件关系，头部分是结论，体部分是前提条件，如 <code>grandparent(X, Y) :- parent(X, Z), parent(Z, Y)</code> 表示 X 是 Y 的祖父母当且仅当存在 Z 使得 X 是 Z 的父母且 Z 是 Y 的父母。查询向系统提问，引擎通过搜索和回溯寻找答案。</p><p>Prolog 的执行机制基于归结原理和 SLD 分辨。查询触发规则匹配，变量通过统一操作绑定值，失败时自动回溯到最近的分支点。递归是 Prolog 的核心编程模式，列表处理、树遍历等操作都通过递归实现。切断操作用于剪枝搜索树，避免不必要的回溯，但使用不当会破坏程序完备性。</p><h2 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to “代码示例”">​</a></h2><p>以家谱关系为例展示 Prolog 的声明式编程特点。首先定义基本事实，然后编写递归规则推导更复杂的关系。</p><div class="language-prolog"><button title="Copy Code" class="copy"></button><span class="lang">prolog</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 事实：父母关系 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">liz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">jim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 规则：祖先关系（递归定义） */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ancestor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              /* X 是 Y 的父母 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ancestor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), ancestor(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* X 是 Z 的父母，Z 是 Y 的祖先 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 规则：后代关系 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">descendant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ancestor(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 查询示例 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?- ancestor(tom, pat).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* true. tom → bob → pat */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?- ancestor(tom, X).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* X = bob ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = liz ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = pat ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = jim ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = tim. */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?- descendant(X, tom).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* X = bob ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = liz ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = pat ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = jim ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   X = tim. */</span></span></code></pre></div><p>这个示例展示了符号 AI 的核心特点。开发者只需声明基本事实和推理规则，引擎自动完成所有搜索和推导工作。当我们查询 <code>ancestor(tom, pat)</code> 时，引擎自动搜索路径：tom 是 bob 的父母，bob 是 pat 的父母，因此 tom 是 pat 的祖先。整个推理过程无需显式编写循环或递归调用，完全由 Prolog 的搜索机制完成。</p><p>对比 Python 实现，开发者需要显式编写递归函数、管理遍历逻辑、处理边界条件。两种实现的功能相同，但 Prolog 版本更接近领域知识的自然表达。</p><h2 id="lisp-与符号操纵" tabindex="-1">Lisp 与符号操纵 <a class="header-anchor" href="#lisp-与符号操纵" aria-label="Permalink to “Lisp 与符号操纵”">​</a></h2><p>Lisp 是早期 AI 的主流语言，从 1958 年起就成为符号 AI 的首选工具。代码即数据的设计使得程序可以像处理数据一样处理代码结构，元编程和递归处理符号表达式非常自然。Lisp 的符号表达式（S-expression）是树形结构，适合表示语法树、逻辑公式等复杂符号结构。</p><p>早期 AI 程序多用 Lisp 实现，包括逻辑理论家程序、通用问题求解器等。Lisp 的动态类型、垃圾回收、高阶函数等特性在当时的编程环境中是革命性的，这些特性后来影响了 Python、Ruby 等现代语言。</p><h2 id="专家系统架构" tabindex="-1">专家系统架构 <a class="header-anchor" href="#专家系统架构" aria-label="Permalink to “专家系统架构”">​</a></h2><p>典型专家系统由三个组件构成：知识库、推理引擎和用户界面。知识库存储规则和事实，推理引擎应用规则进行推理，用户界面接受查询并展示推理过程。MYCIN 用 Lisp 实现规则链，能够解释推理依据，这种可解释性是现代黑盒模型所缺乏的。DENDRAL 用符号匹配分析化学结构，展示了符号系统在科学发现中的潜力。</p><h2 id="实现挑战" tabindex="-1">实现挑战 <a class="header-anchor" href="#实现挑战" aria-label="Permalink to “实现挑战”">​</a></h2><p>纯符号 AI 的编程虽然优雅，但在工程实践中面临严峻挑战。知识获取瓶颈意味着每条规则都需要专家与知识工程师紧密合作，专家的隐性知识难以显式化为规则。脆性问题是致命伤，规则只能覆盖预见到的情况，遇到边界场景就会崩溃。规模问题指规则数量随问题复杂度呈指数增长，几万条规则的系统难以维护。</p><p>正是这些挑战导致符号 AI 在 2012 年后让位于连接主义。但符号方法的价值并未消失，在法律推理、数学证明、安全关键系统等需要可解释性和精确推理的场景中仍然不可替代。现代神经符号融合试图结合两者的优势，这可能是通往更强大 AI 的必经之路。</p><hr><h2 id="编程对比" tabindex="-1">编程对比 <a class="header-anchor" href="#编程对比" aria-label="Permalink to “编程对比”">​</a></h2><table tabindex="0"><thead><tr><th>方面</th><th>符号 AI（如 Prolog）</th><th>普通编程语言（如 Python）</th></tr></thead><tbody><tr><td>核心范式</td><td>声明式：描述&quot;是什么&quot;</td><td>命令式：描述&quot;怎么做&quot;</td></tr><tr><td>知识表示</td><td>知识库与推理引擎分离</td><td>逻辑硬编码在控制流中</td></tr><tr><td>执行机制</td><td>引擎自动搜索、匹配、演绎</td><td>按固定顺序或分支执行</td></tr><tr><td>灵活性</td><td>修改知识库即可改变行为</td><td>修改逻辑需重写代码</td></tr><tr><td>通用性</td><td>目标是通用推理能力</td><td>解决特定问题</td></tr><tr><td>解释性</td><td>推理过程可追溯</td><td>需要额外调试或日志</td></tr></tbody></table>`,27)])])}const g=i(h,[["render",l]]);export{o as __pageData,g as default};
