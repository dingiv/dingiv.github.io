import{_ as i,c as a,o as l,ae as n}from"./chunks/framework.Dgg8-8ov.js";const c=JSON.parse('{"title":"文件系统","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/fs/index.md","filePath":"kernel/linux/fs/index.md"}'),h={name:"kernel/linux/fs/index.md"};function t(e,s,p,k,d,r){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="文件系统" tabindex="-1">文件系统 <a class="header-anchor" href="#文件系统" aria-label="Permalink to &quot;文件系统&quot;">​</a></h1><h2 id="io管理" tabindex="-1">IO管理 <a class="header-anchor" href="#io管理" aria-label="Permalink to &quot;IO管理&quot;">​</a></h2><p>IO设备拥有独立的控制处理器，现代IO设备通过MMIO方式将自身寄存器地址空间映射到物理内存空间中，让CPU通过直接读写物理地址空间来控制IO设备。</p><h3 id="设备挂载" tabindex="-1">设备挂载 <a class="header-anchor" href="#设备挂载" aria-label="Permalink to &quot;设备挂载&quot;">​</a></h3><ol><li><p>设备识别和驱动加载</p><ul><li>识别设备：操作系统检测设备并分配设备文件（Linux中通常位于<code>/dev/</code>目录下）</li><li>加载驱动：操作系统加载适当的驱动程序支持设备操作</li></ul></li><li><p>设备格式化</p><ul><li>存储设备需要经过格式化才能使用</li><li>格式化将物理存储空间划分为存储区域</li><li>为这些区域建立文件系统</li><li>未格式化的存储设备不能直接存储文件和数据</li></ul><p>文件系统格式化：</p><ul><li>文件系统是操作系统管理磁盘上文件的方式</li><li>不同操作系统使用不同的文件系统格式（ext4、NTFS、FAT32、exFAT等）</li><li>分区表（MBR或GPT）定义设备上不同部分的布局和大小</li></ul><p>例如，在Linux中格式化磁盘分区：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkfs.ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载存储设备</p><ul><li>格式化后，存储设备的文件系统才可用</li><li>挂载操作将设备上的文件系统与操作系统的目录结构连接</li><li>用户可以通过路径访问存储设备的内容</li></ul><p>在Linux中挂载设备：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div></li><li><p>文件系统检查与修复</p><ul><li>文件系统可能因突然断电或设备损坏而不一致</li><li>操作系统执行文件系统检查（fsck）修复问题</li></ul><p>在Linux中手动运行文件系统检查：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fsck</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载配置（可选）</p><ul><li>可以将存储设备配置为系统启动时自动挂载</li><li>通过编辑<code>/etc/fstab</code>文件完成配置</li></ul><p>例如，添加以下行将设备<code>/dev/sda1</code>挂载到<code>/mnt</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> defaults</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div></li></ol><h3 id="iommu" tabindex="-1">IOMMU <a class="header-anchor" href="#iommu" aria-label="Permalink to &quot;IOMMU&quot;">​</a></h3><p>IOMMU（IO设备内存空间管理单元）：</p><ul><li>在一些硬件平台上支持IOMMU技术</li><li>添加IOMMU单元，在CPU访问物理内存地址时添加类似MMU的内存虚拟技术</li><li>针对IO设备</li><li>通常伴随DMA一同出现</li></ul><h3 id="socket套接字" tabindex="-1">Socket套接字 <a class="header-anchor" href="#socket套接字" aria-label="Permalink to &quot;Socket套接字&quot;">​</a></h3><p>Socket是操作系统提供的跨进程通信底层抽象：</p><ul><li>基于bind、listen、accept等操作</li><li>实现对网络通信的封装</li><li>让上层能够使用C函数方便地调用</li></ul><p>服务器端代码示例：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建套接字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AF_INET, SOCK_STREAM, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定套接字到本机地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr_in address;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AF_INET;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_addr.s_addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INADDR_ANY;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 监听所有接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> htons</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PORT);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 绑定端口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sockaddr_in));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收客户端请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connect_fd;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞直到有客户端连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connect_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">socklen_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addr_len);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> recv_buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ssize_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytes_received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 接收数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        bytes_received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connect_fd, recv_buf, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recv_buf), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 也可以使用通用的文件描述符操作函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // bytes_received = read(connect_fd, recv_buf, sizeof(recv_buf));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="io-多路复用" tabindex="-1">IO 多路复用 <a class="header-anchor" href="#io-多路复用" aria-label="Permalink to &quot;IO 多路复用&quot;">​</a></h3><p>Linux系统通过select、poll、epoll提供系统级别的事件监听机制：</p><ul><li>select：通过fd_set结构维护文件描述符集合</li><li>每次调用select函数会阻塞</li><li>内核循环遍历fd_set，监听文件描述符变化</li><li>找出可以处理的文件描述符进行处理</li></ul><h2 id="万物皆文件" tabindex="-1">万物皆文件 <a class="header-anchor" href="#万物皆文件" aria-label="Permalink to &quot;万物皆文件&quot;">​</a></h2><p>&quot;一切皆文件&quot;是UNIX的著名哲学理念。在Linux中：</p><ul><li>具体文件、设备、网络socket等都可以抽象为文件</li><li>内核通过虚拟文件系统（VFS）提供统一界面</li><li>程序可以通过文件描述符fd调用IO函数访问文件</li><li>应用程序可以调用select、poll、epoll等系统调用监听文件变化</li></ul><p>常见的IO函数：</p><ul><li>open</li><li>read</li><li>write</li><li>ioctl</li><li>close</li></ul><h2 id="文件管理" tabindex="-1">文件管理 <a class="header-anchor" href="#文件管理" aria-label="Permalink to &quot;文件管理&quot;">​</a></h2><p>Linux至少需要一个存储设备来建立文件系统：</p><ul><li>对数据文件进行持久化</li><li>满足&quot;一切皆文件&quot;的设计哲学</li><li>最小 Linux 机器实例需要挂载硬盘或基于内存的假文件系统</li></ul><h3 id="vfs-虚拟文件系统" tabindex="-1">VFS（虚拟文件系统） <a class="header-anchor" href="#vfs-虚拟文件系统" aria-label="Permalink to &quot;VFS（虚拟文件系统）&quot;">​</a></h3><p>虚拟文件系统的作用：</p><ul><li>实现UNIX环境下&quot;一切皆文件&quot;的具体方式</li><li>为用户空间提供树形结构的文件目录结构</li><li>让用户通过文件路径访问系统资源</li><li>所有资源都被抽象成文件</li><li>用户态程序可以使用统一的操作文件接口</li></ul><h3 id="文件系统-1" tabindex="-1">文件系统 <a class="header-anchor" href="#文件系统-1" aria-label="Permalink to &quot;文件系统&quot;">​</a></h3><p>文件系统用于描述磁盘中数据的组织方式和结构：</p><ul><li>磁盘在挂载到虚拟文件系统前需要格式化</li><li>格式化过程就是建立文件系统的过程</li></ul><blockquote><p>注意区分文件系统和VFS：</p><ul><li>文件系统用于管理和描述块设备中的数据</li><li>VFS是Linux中的文件结构抽象</li></ul></blockquote>`,31)]))}const o=i(h,[["render",t]]);export{c as __pageData,o as default};
