import{_ as s,c as a,o as l,ae as n}from"./chunks/framework.Dh1jimFm.js";const c=JSON.parse('{"title":"Linux 系统知识","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/index.md","filePath":"kernel/linux/index.md"}'),h={name:"kernel/linux/index.md"};function e(t,i,p,k,d,r){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="linux-系统知识" tabindex="-1">Linux 系统知识 <a class="header-anchor" href="#linux-系统知识" aria-label="Permalink to &quot;Linux 系统知识&quot;">​</a></h1><h2 id="开机流程" tabindex="-1">开机流程 <a class="header-anchor" href="#开机流程" aria-label="Permalink to &quot;开机流程&quot;">​</a></h2><h3 id="_1-供电" tabindex="-1">1. 供电 <a class="header-anchor" href="#_1-供电" aria-label="Permalink to &quot;1. 供电&quot;">​</a></h3><p>在系统通电时，主板等周边设备上的小型专用处理器将优先工作。其中挂载在CPU总线上的小型控制器EC（Embedded Controller）负责计算机的电源管理工作。EC控制电源供应单元为硬件系统供电，系统各部分进入各自的供电流程，包括CPU、内存、南北桥芯片等。</p><blockquote><p>周边设备的控制器芯片不承担主要的计算任务，但会帮助协调各个硬件之间的工作。</p></blockquote><p>各个硬件的供电顺序有所先后，一般顺序是：CPU、内存、南北桥、扩展卡和外围设备、启动存储等。电源控制单元在确保电源供应一切顺利后，向EC发出信号表示供电完毕。供电成功后，EC通知主板上的各个芯片组，正式开启计算机的启动流程。</p><p>首先，南北桥进行交互：</p><ol><li>南桥向北桥发出正常信号</li><li>北桥收到南桥信号，并向CPU发送正常信号</li><li>CPU开始工作</li></ol><blockquote><p>供电单元可以进行交流电到直流电的转化，并保持电源电压的稳定。</p></blockquote><h3 id="_2-bios-uefi-寻找-boot-loader" tabindex="-1">2. BIOS/UEFI 寻找 Boot Loader <a class="header-anchor" href="#_2-bios-uefi-寻找-boot-loader" aria-label="Permalink to &quot;2. BIOS/UEFI 寻找 Boot Loader&quot;">​</a></h3><p>CPU开始工作后的第一个程序是BIOS/UEFI程序，它是主板上的固件。BIOS程序会：</p><ol><li>扫描和检查设备</li><li>初始化硬件系统（主板、内存、CPU、显卡等）</li><li>确保设备能够正常工作（POST - Power-On Self Test）</li><li>为内存条和MMIO设备分配地址空间</li><li>将地址空间连成连续的数组空间（地址位数取决于机器位宽，通常为32位或64位）</li></ol><p>在硬件检查完毕后，BIOS/UEFI程序尝试依次从多个外部存储设备中加载Boot Loader程序到内存中。如果某个设备中没有找到，则尝试从下一个存储设备加载。一旦加载成功，计算机的执行权就移交给Boot Loader。</p><p>BIOS加载Boot Loader时，从外部存储设备的启动扇区（MBR - Master Boot Record）加载，并将其放置到内存中的约定区域。</p><p>BIOS查找Boot Loader程序的顺序可能如下：</p><ul><li>硬盘</li><li>USB</li><li>CDROM</li><li>网卡（pxe启动）</li></ul><p>BIOS通常提供基于终端的配置界面，允许用户自定义引导过程，例如修改启动介质的优先级。</p><blockquote><p>一些硬件层面的功能（如网卡的SR-IOV功能）不一定会被启用。如需启用，需要重启机器并提前修改BIOS配置。</p></blockquote><h3 id="_3-boot-loader-加载操作系统" tabindex="-1">3. Boot Loader 加载操作系统 <a class="header-anchor" href="#_3-boot-loader-加载操作系统" aria-label="Permalink to &quot;3. Boot Loader 加载操作系统&quot;">​</a></h3><p>Boot Loader是存放在操作系统镜像盘中约定区域的一段程序。它被BIOS程序加载并执行，负责：</p><ol><li>把操作系统的文件加载到内存中</li><li>初始化操作系统</li><li>将计算机的执行权移交给操作系统</li></ol><blockquote><p>Boot Loader执行时，CPU处于Real模式，只能访问1MB的内存空间，没有内存保护。Boot Loader利用硬盘的分区表、文件系统信息和操作系统核心文件，实现从实模式到保护模式的切换，以及从硬盘到内存的数据传输。</p></blockquote><p>Boot Loader根据MBR中的磁盘分区信息，找到活动分区（操作系统文件所在的分区），然后：</p><ol><li>找到操作系统可执行文件</li><li>加载操作系统到指定的内存区域</li><li>跳转CPU到该区域，开始执行操作系统</li></ol><p>常见的Boot Loader实现包括：</p><ul><li>GRUB（广泛用于Linux系统）</li><li>LILO</li><li>NTLDR</li><li>BOOTMGR</li></ul><p>在Linux文件系统中，Boot Loader通常位于<code>/boot</code>目录下。</p><h3 id="_4-操作系统启动" tabindex="-1">4. 操作系统启动 <a class="header-anchor" href="#_4-操作系统启动" aria-label="Permalink to &quot;4. 操作系统启动&quot;">​</a></h3><p>以Linux系统为例，当系统启动时：</p><ol><li>BIOS/UEFI程序在上电时对设备进行扫描检查和初始化</li><li>为内存条和MMIO设备分配地址空间</li><li>将地址空间连成连续的数组空间</li><li>操作系统接管硬件管理</li></ol><h2 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to &quot;进程管理&quot;">​</a></h2><h3 id="进程加载" tabindex="-1">进程加载 <a class="header-anchor" href="#进程加载" aria-label="Permalink to &quot;进程加载&quot;">​</a></h3><p>当一个程序被执行时：</p><ol><li>将程序的ELF文件（Executable and Linkable Format）内容加载到内存中</li><li>分配到进程的虚拟地址空间中的相应位置（位置分配由编译器决定）</li><li>操作系统为进程创建页表，维护虚拟内存到物理内存的映射逻辑</li></ol><h3 id="并发和并行" tabindex="-1">并发和并行 <a class="header-anchor" href="#并发和并行" aria-label="Permalink to &quot;并发和并行&quot;">​</a></h3><h3 id="阻塞和空转" tabindex="-1">阻塞和空转 <a class="header-anchor" href="#阻塞和空转" aria-label="Permalink to &quot;阻塞和空转&quot;">​</a></h3><p>从操作系统层面，当进程调用阻塞式系统调用时：</p><ol><li>进程进入阻塞状态</li><li>操作系统不会把CPU的时间片分配给这个进程</li><li>直到调用结束，进程从阻塞状态重新进入执行状态</li></ol><p>常见的阻塞式调用包括：</p><ol><li><p>进程调度和中断</p><ul><li>进程本身的调度和中断机制通过阻塞方式实现</li><li>这个过程对于进程自身来说是无感知的</li></ul></li><li><p>阻塞式IO调用</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻塞式函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></li><li><p>锁和同步机制</p><ul><li>互斥锁（Mutex）</li><li>信号量（Semaphore）</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 线程互斥锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_mutex_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pthread_cond_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cond;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 尝试获取互斥锁，如果无法获取则进入阻塞状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始访问被保护的资源</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pthread_mutex_unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 信号量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sem_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sem;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 初始化信号量为0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sem_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待信号量</span></span></code></pre></div></li></ol><p>与阻塞不同，空转指的是进程进入无意义的空循环状态，可能通过不断检查条件来等待某个条件的达成。这可能是程序bug或刻意设计。在这种状态下，进程处于正常执行状态但不执行有用逻辑，导致CPU浪费。</p><blockquote><p>死锁时，锁住的两个或多个进程会被阻塞，然后被操作系统挂起，CPU占用为0，这是典型的死锁特征。</p></blockquote><h3 id="进程间通信-ipc" tabindex="-1">进程间通信（IPC） <a class="header-anchor" href="#进程间通信-ipc" aria-label="Permalink to &quot;进程间通信（IPC）&quot;">​</a></h3><p>进程是操作系统提供给上层的虚拟容器，为程序运行提供隔离和保护。容器之间需要交互，交互方式由操作系统提供相应的系统调用实现。</p><h4 id="基于内存的通信" tabindex="-1">基于内存的通信 <a class="header-anchor" href="#基于内存的通信" aria-label="Permalink to &quot;基于内存的通信&quot;">​</a></h4><ol><li><p>信号</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigprocmask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>信号是一种软件软中断机制</li><li>为进程提供响应外界发送单向数据的机制</li><li>进程可以实现对特定信号的响应逻辑</li><li>类似于事件的概念</li><li>信号的回调函数是异步的，最好是可重入的</li></ul><p>信号处理流程：</p><ul><li>信号发送：操作系统生成信号并发送给目标进程</li><li>信号接收和处理：进程接收信号，执行信号处理程序</li><li>默认行为： <ul><li>终止进程（如SIGKILL、SIGTERM）</li><li>暂停进程（如SIGSTOP）</li><li>忽略信号（如SIGCHLD）</li><li>继续执行（如SIGCONT）</li></ul></li></ul></li><li><p>管道</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkfifo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>单向管道（匿名管道）：主要用于父子进程间通信，数据流是单向的</li><li>双向管道（命名管道）：支持无父子关系的进程间通信</li></ul></li><li><p>消息队列</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgsnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgrcv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>在内核中维护的队列，用于存储进程间交换的消息</li><li>支持消息的异步传输</li><li>消息在队列中按顺序排列</li><li>支持优先级</li><li>提供良好的可靠性和同步机制</li></ul></li><li><p>信号量（Semaphore）</p><ul><li>用于控制多个进程对共享资源访问的同步机制</li><li>用于进程间的互斥和同步</li><li>类型： <ul><li>二值信号量（互斥锁）：值只有0和1</li><li>计数信号量：值可以是非负整数，表示资源剩余数量</li></ul></li></ul></li><li><p>共享内存</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shm_open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>多个进程可以同时访问共享内存</li><li>通常需要使用互斥量或信号量进行同步</li><li>适合大量、快速的进程间数据共享</li></ul></li></ol><h4 id="基于io的通信" tabindex="-1">基于IO的通信 <a class="header-anchor" href="#基于io的通信" aria-label="Permalink to &quot;基于IO的通信&quot;">​</a></h4><ol><li><p>套接字（Socket）</p><ul><li>满足跨主机的通信</li><li>特别适合通过网络或专用线路通信</li></ul></li><li><p>eventfd</p><ul><li>用于进程或线程间通信</li><li>支持用户态和内核态之间通信</li></ul></li><li><p>磁盘文件</p></li></ol><h3 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h3><h4 id="物理内存" tabindex="-1">物理内存 <a class="header-anchor" href="#物理内存" aria-label="Permalink to &quot;物理内存&quot;">​</a></h4><p>主板和BIOS程序在上电时：</p><ol><li>检查和扫描设备</li><li>初始化各种设备（内存条和各种IO设备的寄存器和缓冲区）</li><li>将这些存储空间拼接成连贯的物理内存空间</li></ol><p>物理内存空间可以看作是一个地址数组，每个地址的大小取决于计算机的位数（32位、64位等）。在操作系统引导时，BIOS将物理内存空间信息告知操作系统，包括：</p><ul><li>内存地址的分区</li><li>各个硬件设备的地址范围</li></ul><h4 id="虚拟内存" tabindex="-1">虚拟内存 <a class="header-anchor" href="#虚拟内存" aria-label="Permalink to &quot;虚拟内存&quot;">​</a></h4><p>操作系统为进程提供虚拟内存，每个应用程序进程都认为自己独占全部、连续的内存。在64位系统上：</p><ul><li>虚拟内存大小为256TB</li><li>地址范围：0x0000000000000000 到 0x0000FFFFFFFFFFFF</li></ul><h4 id="内存映射" tabindex="-1">内存映射 <a class="header-anchor" href="#内存映射" aria-label="Permalink to &quot;内存映射&quot;">​</a></h4><p>物理内存和虚拟内存之间存在映射关系：</p><ul><li>映射以一块连续的内存为单位（通常为4000 Byte）</li><li>一块虚拟内存对应一块真实的物理内存</li><li>这个单位称为内存分页</li><li>操作系统通过页表（多级数组数据结构）维护映射关系</li></ul><p>当进程创建时，操作系统为进程创建页表，维护进程的虚拟内存到物理内存的映射。当应用程序通过系统调用进行内存分配时：</p><ol><li>调用操作系统的封装函数</li><li>操作系统分配物理内存</li><li>执行内存映射操作</li><li>返回指向虚拟内存的指针</li></ol><h4 id="自定义内存映射" tabindex="-1">自定义内存映射 <a class="header-anchor" href="#自定义内存映射" aria-label="Permalink to &quot;自定义内存映射&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/mman.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> addr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 可以是NULL，由操作系统自行分配</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> fd</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 需要映射的文件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> offset</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 偏移量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> prot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> fd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">off_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>mmap函数将文件fd中的内容映射到当前进程的内存空间中addr位置处，大小为length，通过prot参数控制内存访问权限，通过flags提供更多配置选项。</p><h2 id="io管理" tabindex="-1">IO管理 <a class="header-anchor" href="#io管理" aria-label="Permalink to &quot;IO管理&quot;">​</a></h2><p>IO设备拥有独立的控制处理器，现代IO设备通过MMIO方式将自身寄存器地址空间映射到物理内存空间中，让CPU通过直接读写物理地址空间来控制IO设备。</p><h3 id="设备挂载" tabindex="-1">设备挂载 <a class="header-anchor" href="#设备挂载" aria-label="Permalink to &quot;设备挂载&quot;">​</a></h3><ol><li><p>设备识别和驱动加载</p><ul><li>识别设备：操作系统检测设备并分配设备文件（Linux中通常位于<code>/dev/</code>目录下）</li><li>加载驱动：操作系统加载适当的驱动程序支持设备操作</li></ul></li><li><p>设备格式化</p><ul><li>存储设备需要经过格式化才能使用</li><li>格式化将物理存储空间划分为存储区域</li><li>为这些区域建立文件系统</li><li>未格式化的存储设备不能直接存储文件和数据</li></ul><p>文件系统格式化：</p><ul><li>文件系统是操作系统管理磁盘上文件的方式</li><li>不同操作系统使用不同的文件系统格式（ext4、NTFS、FAT32、exFAT等）</li><li>分区表（MBR或GPT）定义设备上不同部分的布局和大小</li></ul><p>例如，在Linux中格式化磁盘分区：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkfs.ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载存储设备</p><ul><li>格式化后，存储设备的文件系统才可用</li><li>挂载操作将设备上的文件系统与操作系统的目录结构连接</li><li>用户可以通过路径访问存储设备的内容</li></ul><p>在Linux中挂载设备：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div></li><li><p>文件系统检查与修复</p><ul><li>文件系统可能因突然断电或设备损坏而不一致</li><li>操作系统执行文件系统检查（fsck）修复问题</li></ul><p>在Linux中手动运行文件系统检查：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fsck</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda1</span></span></code></pre></div></li><li><p>挂载配置（可选）</p><ul><li>可以将存储设备配置为系统启动时自动挂载</li><li>通过编辑<code>/etc/fstab</code>文件完成配置</li></ul><p>例如，添加以下行将设备<code>/dev/sda1</code>挂载到<code>/mnt</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/dev/sda1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> defaults</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div></li></ol><h3 id="iommu" tabindex="-1">IOMMU <a class="header-anchor" href="#iommu" aria-label="Permalink to &quot;IOMMU&quot;">​</a></h3><p>IOMMU（IO设备内存空间管理单元）：</p><ul><li>在一些硬件平台上支持IOMMU技术</li><li>添加IOMMU单元，在CPU访问物理内存地址时添加类似MMU的内存虚拟技术</li><li>针对IO设备</li><li>通常伴随DMA一同出现</li></ul><h3 id="socket套接字" tabindex="-1">Socket套接字 <a class="header-anchor" href="#socket套接字" aria-label="Permalink to &quot;Socket套接字&quot;">​</a></h3><p>Socket是操作系统提供的跨进程通信底层抽象：</p><ul><li>基于bind、listen、accept等操作</li><li>实现对网络通信的封装</li><li>让上层能够使用C函数方便地调用</li></ul><p>服务器端代码示例：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建套接字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AF_INET, SOCK_STREAM, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定套接字到本机地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr_in address;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AF_INET;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_addr.s_addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INADDR_ANY;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 监听所有接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address.sin_port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> htons</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PORT);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 绑定端口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sockaddr_in));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收客户端请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connect_fd;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞直到有客户端连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connect_fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_fd, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sockaddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">socklen_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addr_len);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> recv_buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ssize_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytes_received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 接收数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        bytes_received </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(connect_fd, recv_buf, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recv_buf), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 也可以使用通用的文件描述符操作函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // bytes_received = read(connect_fd, recv_buf, sizeof(recv_buf));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="io多路复用" tabindex="-1">IO多路复用 <a class="header-anchor" href="#io多路复用" aria-label="Permalink to &quot;IO多路复用&quot;">​</a></h3><p>Linux系统通过select、poll、epoll提供系统级别的事件监听机制：</p><ul><li>select：通过fd_set结构维护文件描述符集合</li><li>每次调用select函数会阻塞</li><li>内核循环遍历fd_set，监听文件描述符变化</li><li>找出可以处理的文件描述符进行处理</li></ul><h2 id="中断-interrupt" tabindex="-1">中断（Interrupt） <a class="header-anchor" href="#中断-interrupt" aria-label="Permalink to &quot;中断（Interrupt）&quot;">​</a></h2><p>中断是一种信号，由硬件或软件发出，请求CPU停止当前操作，转而响应特定事件。该机制广泛用于IO设备和CPU的交互中。</p><h3 id="中断的作用" tabindex="-1">中断的作用 <a class="header-anchor" href="#中断的作用" aria-label="Permalink to &quot;中断的作用&quot;">​</a></h3><ol><li>多任务处理</li><li>资源管理</li><li>事件驱动：响应IO设备的中断，实现监听IO事件</li></ol><h3 id="中断的类型" tabindex="-1">中断的类型 <a class="header-anchor" href="#中断的类型" aria-label="Permalink to &quot;中断的类型&quot;">​</a></h3><ol><li><p>硬件中断</p><ul><li>IO中断（磁盘读写完成）</li><li>定时器中断</li><li>外设中断（鼠标键盘操作）</li></ul></li><li><p>软件中断</p></li><li><p>异常</p></li></ol><h3 id="中断的流程" tabindex="-1">中断的流程 <a class="header-anchor" href="#中断的流程" aria-label="Permalink to &quot;中断的流程&quot;">​</a></h3><ol><li>触发中断：硬件或软件触发中断信号</li><li>保存现场：CPU停止当前任务，保存寄存器和程序计数器到堆栈</li><li>查找中断向量：CPU根据中断向量表IVT查找中断处理程序地址</li><li>执行中断处理程序：CPU转到中断处理程序，完成特定任务</li><li>恢复现场：执行完成后恢复现场，继续之前任务</li></ol><h2 id="万物皆文件" tabindex="-1">万物皆文件 <a class="header-anchor" href="#万物皆文件" aria-label="Permalink to &quot;万物皆文件&quot;">​</a></h2><p>&quot;一切皆文件&quot;是UNIX的著名哲学理念。在Linux中：</p><ul><li>具体文件、设备、网络socket等都可以抽象为文件</li><li>内核通过虚拟文件系统（VFS）提供统一界面</li><li>程序可以通过文件描述符fd调用IO函数访问文件</li><li>应用程序可以调用select、poll、epoll等系统调用监听文件变化</li></ul><p>常见的IO函数：</p><ul><li>open</li><li>read</li><li>write</li><li>ioctl</li><li>close</li></ul><h2 id="内核模块" tabindex="-1">内核模块 <a class="header-anchor" href="#内核模块" aria-label="Permalink to &quot;内核模块&quot;">​</a></h2><p>Linux是可扩展架构，允许动态加载和卸载功能模块：</p><ul><li>包括设备驱动程序、文件系统、网络协议栈等</li><li>动态加载通过insmod/modprobe命令</li><li>卸载通过rmmod命令</li></ul><p>内核模块加载后：</p><ul><li>符号空间中的函数不会被加入到操作系统运行的物理内存中</li><li>通过EXPORT_SYMBOL宏导出函数</li><li>只有通过该宏显式导出的函数才能在模块外部可见</li></ul><blockquote><p>内核模块加载区别于动态链接库加载：</p><ul><li>内核模块加载是将二进制目标文件加载到物理内存中</li><li>动态链接库由系统在创建进程时加载到虚拟内存中</li></ul></blockquote><h2 id="文件管理" tabindex="-1">文件管理 <a class="header-anchor" href="#文件管理" aria-label="Permalink to &quot;文件管理&quot;">​</a></h2><p>Linux至少需要一个存储设备来建立文件系统：</p><ul><li>对数据文件进行持久化</li><li>满足&quot;一切皆文件&quot;的设计哲学</li><li>最小Linux机器实例需要挂载硬盘或基于内存的假文件系统</li></ul><h3 id="vfs-虚拟文件系统" tabindex="-1">VFS（虚拟文件系统） <a class="header-anchor" href="#vfs-虚拟文件系统" aria-label="Permalink to &quot;VFS（虚拟文件系统）&quot;">​</a></h3><p>虚拟文件系统的作用：</p><ul><li>实现UNIX环境下&quot;一切皆文件&quot;的具体方式</li><li>为用户空间提供树形结构的文件目录结构</li><li>让用户通过文件路径访问系统资源</li><li>所有资源都被抽象成文件</li><li>用户态程序可以使用统一的操作文件接口</li></ul><h3 id="文件系统" tabindex="-1">文件系统 <a class="header-anchor" href="#文件系统" aria-label="Permalink to &quot;文件系统&quot;">​</a></h3><p>文件系统用于描述磁盘中数据的组织方式和结构：</p><ul><li>磁盘在挂载到虚拟文件系统前需要格式化</li><li>格式化过程就是建立文件系统的过程</li></ul><blockquote><p>注意区分文件系统和VFS：</p><ul><li>文件系统用于管理和描述块设备中的数据</li><li>VFS是Linux中的文件结构抽象</li></ul></blockquote><h2 id="硬件交互" tabindex="-1">硬件交互 <a class="header-anchor" href="#硬件交互" aria-label="Permalink to &quot;硬件交互&quot;">​</a></h2><h3 id="cpu权限级别" tabindex="-1">CPU权限级别 <a class="header-anchor" href="#cpu权限级别" aria-label="Permalink to &quot;CPU权限级别&quot;">​</a></h3><p>现代处理器运行时分为4个权限级别：</p><ul><li>ring0：最高权限，直接访问硬件资源，运行操作系统代码</li><li>ring1</li><li>ring2</li><li>ring3：最低权限，只能通过间接调用系统代码访问硬件资源，运行用户应用程序代码或用户态库</li></ul><h3 id="io设备" tabindex="-1">IO设备 <a class="header-anchor" href="#io设备" aria-label="Permalink to &quot;IO设备&quot;">​</a></h3><p>操作系统内核不直接操作设备：</p><ul><li>通过调用设备的驱动程序完成对设备的读写</li><li>驱动程序由硬件厂商实现</li><li>使用设备时，将驱动程序以内核模块方式加载进内核</li><li>操作系统声明统一的SPI（Service Program Interface），由硬件厂商实现</li></ul><h3 id="可编程io-dma" tabindex="-1">可编程IO/DMA <a class="header-anchor" href="#可编程io-dma" aria-label="Permalink to &quot;可编程IO/DMA&quot;">​</a></h3><p>根据数据传输过程是否需要CPU参与，IO分为两类：</p><ol><li><p>可编程IO</p><ul><li>操作系统通过读写IO设备寄存器控制设备</li><li>分为两种类型： <ul><li>PMIO（Port-Mapped Input/Output）：通过访问IO端口控制设备</li><li>MMIO（Memory-Mapped Input/Output）：设备寄存器和缓冲区映射到物理内存中</li></ul></li></ul></li><li><p>DMA（Direct Memory Access）</p><ul><li>外设与内存之间交换数据的接口技术</li><li>数据传输过程无须CPU控制</li><li>数据拷贝和搬运由外设专用处理器完成</li><li>操作系统通过驱动程序提前告知外设数据拷贝位置</li><li>外设直接访问内存，将数据放到指定位置</li><li>完成后发起中断通知CPU</li></ul></li></ol><h2 id="服务" tabindex="-1">服务 <a class="header-anchor" href="#服务" aria-label="Permalink to &quot;服务&quot;">​</a></h2><p>服务是后台运行或定时运行的任务，帮助系统或其他进程更好地完成任务。</p><h3 id="系统服务" tabindex="-1">系统服务 <a class="header-anchor" href="#系统服务" aria-label="Permalink to &quot;系统服务&quot;">​</a></h3><p>系统服务软件：</p><ul><li>不属于内核层代码</li><li>运行在用户空间中</li><li>协助用户与系统内核交互</li><li>为用户态程序提供基础设施服务</li></ul><p>典型软件包括：</p><ul><li>systemd（服务管理、journald日志服务、udev设备管理）</li><li>bash</li><li>iproute</li><li>grub</li></ul><p>多数Linux发行版自带systemd：</p><ul><li>配置文件位于<code>/etc/systemd</code>、<code>/usr/lib/systemd</code>、<code>~/.config/systemd</code>等文件夹</li><li>使用systemctl命令操作</li><li>使用journalctl命令管理日志内容</li></ul><h3 id="服务单元" tabindex="-1">服务单元 <a class="header-anchor" href="#服务单元" aria-label="Permalink to &quot;服务单元&quot;">​</a></h3><p>在systemd抽象中：</p><ul><li>独立运行的进程服务使用service文件描述</li><li>称为服务单元</li><li>规定服务进程的启动配置</li><li>systemd根据配置文件管理和启动服务</li><li>通过systemctl和journalctl接口管理和控制系统上注册的服务程序</li></ul>`,131)]))}const E=s(h,[["render",e]]);export{c as __pageData,E as default};
