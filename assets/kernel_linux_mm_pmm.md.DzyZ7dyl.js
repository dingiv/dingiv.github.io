import{_ as i,c as l,o as e,ah as s,bh as t}from"./chunks/framework.C5lh6Kkj.js";const k=JSON.parse('{"title":"物理内存管理","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/mm/pmm.md","filePath":"kernel/linux/mm/pmm.md"}'),n={name:"kernel/linux/mm/pmm.md"};function p(r,a,o,d,h,c){return e(),l("div",null,[...a[0]||(a[0]=[s(`<h1 id="物理内存管理" tabindex="-1">物理内存管理 <a class="header-anchor" href="#物理内存管理" aria-label="Permalink to “物理内存管理”">​</a></h1><p>物理内存空间可以看作是一个地址数组，每个地址的大小取决于计算机的位数（32 位、64 位等）。</p><p>主板和 BIOS 程序在上电时：</p><ol><li>检查和扫描设备</li><li>初始化各种设备（内存条和各种 IO 设备的寄存器和缓冲区）</li><li>将这些存储空间拼接成连贯的物理内存空间</li></ol><p>生成的必要信息，这些信息放置在一些可以在后续操作</p><h2 id="内核虚拟地址" tabindex="-1">内核虚拟地址 <a class="header-anchor" href="#内核虚拟地址" aria-label="Permalink to “内核虚拟地址”">​</a></h2><p>在操作系统引导时，BIOS 将物理内存空间信息告知操作系统，包括：内存地址的分区和各个硬件设备的地址范围；操作系统可以在其中确定内存条设备的内存范围从而得知主内存的范围，并建立物理内存的管理结构。</p><p>具体地，在系统启动时，内核通过 BIOS/UEFI 或设备树（Device Tree）获取物理内存布局（如 RAM 范围，存储在 /proc/iomem）。内核构建 <code>mem_map</code> 数组，mem_map 是一个全局数组，使用 struct page 跟踪每个物理页面（4KB）。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 页面状态</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    atomic_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _count;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 引用计数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">virtual;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 对应的虚拟地址（可能为空）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>由于 CPU 访问内存必须经过 MMU，而 MMU 的映射规则由操作系统维护，操作系统需要通过 MMU 将使用的内存页映射到真实的物理内存页上，因此内核访问内存时依然通过虚拟地址进行访问，这个虚拟地址称为内核虚拟地址；内核和用户空间都需要通过虚拟地址访问内存条和设备寄存器，内核虚拟地址通过页表线性映射，而用户虚拟地址通过多级页表映射。</p><h2 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to “内存分配”">​</a></h2><p>内存分配和组织算法是物理内存管理的主要内容，linux 的主内存使用伙伴系统和 slab 分配器进行管理。早期的系统中使用了简单的位图方法。</p><h3 id="位图方法" tabindex="-1">位图方法 <a class="header-anchor" href="#位图方法" aria-label="Permalink to “位图方法”">​</a></h3><p>将物理内存条划分为<strong>头+体</strong>的两块，头使用 bit 位标记了体中的某一块内存是否被分配使用，体中的某块内存可以直接与上层的内存页大小保持一致，采用 4k 为一块进行管理和分配；该算法实现简单，但是在新增分配的时候需要使用 O(n) 时间查找目标，时间效率不高。如今已经基本不再使用。</p><h3 id="伙伴系统" tabindex="-1">伙伴系统 <a class="header-anchor" href="#伙伴系统" aria-label="Permalink to “伙伴系统”">​</a></h3><p>buddy system 使用多级链表数组管理空闲块，是一种用于分配连续物理页框的算法。可以用于解决位图方法在分配内存时的速度问题。内核为分配页框调用 <code>__get_free_pages()</code>、<code>alloc_pages()</code> 等接口时，就会走这个算法。当释放的两个&quot;伙伴&quot;空闲块连续时，可以合并为更大的块。</p><p>系统将空闲页面分组为 11 个块链表，每个块链表分别包含大小为 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页框的页块。最大可以申请 1024 个连续页框，对应 4MB 大小的内存。</p><p><img src="`+t+`" alt=""></p><p>分配过程：</p><ol><li>根据请求大小，找到对应的块链表</li><li>如果链表为空，则向更大的块链表申请</li><li>将大块分割成两个小块，一个用于分配，另一个加入较小的块链表</li><li>如果仍然没有合适的块，则继续向更大的块链表申请</li></ol><p>分配过程：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>空闲块（1024KB）</span></span>
<span class="line"><span>→ 分配 128KB 时 → 找不到正好128KB，就分成两个 512KB → 再分两个 256KB → 再分两个 128KB</span></span>
<span class="line"><span></span></span>
<span class="line"><span>分配成功：128KB</span></span>
<span class="line"><span>其&quot;伙伴&quot;：另一个 128KB 仍空闲</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当释放该 128KB，如果它的&quot;伙伴&quot;也空闲，则两者合并为 256KB，继续向上尝试合并。</span></span></code></pre></div><p>释放过程：</p><ol><li>将释放的块加入对应的块链表</li><li>检查是否有相邻的空闲块</li><li>如果有，则合并成更大的块，并加入更大的块链表</li><li>重复步骤 2-3，直到无法继续合并</li></ol><p>优点：快速分配和释放，有效减少内存碎片，支持大块内存分配；缺点：可能造成内部碎片，合并操作可能较慢，不适合小块内存分配。</p><h3 id="slab-slub-slob-分配器" tabindex="-1">SLAB/SLUB/SLOB 分配器 <a class="header-anchor" href="#slab-slub-slob-分配器" aria-label="Permalink to “SLAB/SLUB/SLOB 分配器”">​</a></h3><p>SLAB系列分配器是 Linux 内核中用于管理小块内存的分配器，主要用于内核对象的分配和释放。它基于以下思想：内核对象在创建和销毁 时，需要频繁地分配和释放内存，如果每次都使用伙伴系统，会造成很大的开销。Linux 内核为适应不同场景和架构，提供了多种内存分配器。</p><ul><li>SLAB 分配器：最早引入的对象缓存分配器。为每种对象类型维护多个 slab 缓存池，采用链表管理部分满、已满和空 slab。优点是分配和释放效率高，支持对象构造/析构函数，适合多处理器并发。缺点是实现复杂，内存碎片相对较多。</li><li>SLUB 分配器：SLAB 的改进版，当前主流内核的默认分配器。简化了 slab 管理结构，取消了链表，采用更高效的 bitmap 管理空闲对象，提升了分配/释放性能，减少了碎片。支持 NUMA 架构，调试和统计信息更丰富。</li><li>SLOB 分配器：面向嵌入式和资源受限设备的极简分配器。实现简单，适合小内存场景，但分配效率和并发能力较弱，不适合高性能服务器。</li></ul><table tabindex="0"><thead><tr><th>分配器</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>SLAB</td><td>通用/多核服务器</td><td>并发高、支持构造析构</td><td>实现复杂、碎片较多</td></tr><tr><td>SLUB</td><td>主流服务器/桌面</td><td>高效、碎片少、易维护</td><td>早期兼容性问题</td></tr><tr><td>SLOB</td><td>嵌入式/小内存设备</td><td>简单、占用资源极低</td><td>性能低、无并发优化</td></tr></tbody></table><p>现代 Linux 内核默认采用 SLUB 分配器，用户可通过内核配置选项选择合适的分配器。</p><p>对于小于一页的内存分配请求，Linux 提供了以下机制：</p><ol><li>kmalloc，基于 SLUB 分配器，支持不同大小的缓存，支持内存对齐要求，适用于内核对象</li><li>vmalloc，分配虚拟内存，不保证物理内存连续，适用于大块内存，性能较低</li><li>内存池，预分配内存块，快速分配和释放，减少内存碎片，适用于特定场景</li></ol><h2 id="内存回收" tabindex="-1">内存回收 <a class="header-anchor" href="#内存回收" aria-label="Permalink to “内存回收”">​</a></h2><p>内存回收是物理内存管理中的重要环节，确保系统在内存紧张时能够及时释放和回收内存资源，避免内存耗尽导致系统崩溃。</p><h3 id="回收对象" tabindex="-1">回收对象 <a class="header-anchor" href="#回收对象" aria-label="Permalink to “回收对象”">​</a></h3><p>当系统内存不足时，内核会尝试回收一部分不再活跃的物理页面。页面回收分为主动回收和被动回收：主动回收：内核定期扫描内存，将长期未被访问的页面移出内存；被动回收：当分配内存失败时，触发回收机制。</p><ol><li>匿名页。主要是进程的堆、栈等私有数据。这类页面不能直接丢弃，只能通过写入 swap（交换分区/文件）后释放物理内存；</li><li>页缓存。用于缓存文件内容、文件映射等。这类页面可以直接丢弃（如果未修改）或回写到磁盘（如果被修改过），回收后可立即释放物理内存；</li><li>内核缓存。即 SLAB 分配器的缓存，包括 dentry（目录项）、inode、内核对象等。这些缓存用于加速内核操作，内存紧张时可以回收部分未被使用的对象。</li><li>除此之外，Linux 还有一些特殊的内存池或缓存（如网络缓冲区、内存池等），但它们本质上也是属于&quot;缓存&quot;类资源，回收方式类似。</li></ol><p>内核通过 LRU（最近最少使用）算法维护活跃页和不活跃页列表，优先回收不活跃页。</p><h3 id="内存交换" tabindex="-1"><a href="./swap">内存交换</a> <a class="header-anchor" href="#内存交换" aria-label="Permalink to “内存交换”">​</a></h3><p>当物理内存不足时，内核会将部分匿名页写入交换分区（swap space），以释放物理内存。被 swap 出的页面在需要时可以重新加载到内存。优点：提升系统的容错能力，防止内存耗尽。缺点：频繁 swap 会导致系统变慢（swap storm）。</p><h3 id="oom-killer-out-of-memory-killer" tabindex="-1">OOM Killer（Out-Of-Memory Killer） <a class="header-anchor" href="#oom-killer-out-of-memory-killer" aria-label="Permalink to “OOM Killer（Out-Of-Memory Killer）”">​</a></h3><p>当所有回收和 swap 手段都无法满足内存需求时，内核会启动 OOM Killer，选择性地终止某些进程以释放内存。</p><ul><li>选择标准：优先杀死占用内存多、优先级低的进程。</li><li>触发时机：分配内存失败且无法回收更多内存时。</li></ul><h3 id="内存回收尝试过程" tabindex="-1">内存回收尝试过程 <a class="header-anchor" href="#内存回收尝试过程" aria-label="Permalink to “内存回收尝试过程”">​</a></h3><ol><li>进程申请内存，系统发现空闲内存不足。</li><li>内核尝试回收页面和缓存。</li><li>仍然不足时，尝试 swap。</li><li>如果 swap 也无法满足，触发 OOM Killer，终止部分进程。</li></ol><p>通过多层次的回收和保护机制，Linux 能够在高负载和内存紧张的情况下保持系统的稳定性。</p><h2 id="内存压缩" tabindex="-1">内存压缩 <a class="header-anchor" href="#内存压缩" aria-label="Permalink to “内存压缩”">​</a></h2><p>当系统内存压力较大时，内核会将部分不活跃的页面进行压缩，压缩后的数据仍然保存在内存中。这样可以在不增加物理内存的情况下，存储更多的页面内容。需要访问被压缩页面时，内核会自动解压还原。</p><ul><li><strong>zswap</strong>：内核自带的压缩后交换缓存。被换出的页面先压缩存放在内存的 zswap 区域，只有当 zswap 区域满了才真正写入 swap 设备。</li><li><strong>zram</strong>：将一块内存虚拟成块设备，作为压缩 swap 区使用。常用于嵌入式、低内存设备。</li></ul><p>通过内存压缩，Linux 能够在不增加物理内存的前提下，提高内存利用率，延缓 swap 到磁盘的时机，减少 I/O，但是这是时间换空间的思路，压缩和解压会消耗 CPU 资源。</p><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to “适用场景”">​</a></h3><ul><li>内存资源有限、磁盘 I/O 成本高的场景（如嵌入式设备、虚拟机）。</li><li>希望提升 swap 性能、减少磁盘写入的服务器和桌面系统。</li></ul><h2 id="内存碎片" tabindex="-1">内存碎片 <a class="header-anchor" href="#内存碎片" aria-label="Permalink to “内存碎片”">​</a></h2><p>内存碎片是指物理内存空间由于频繁分配和释放，导致出现无法被有效利用的小块空闲内存，影响大块内存的分配效率，可能导致分配失败（如驱动、DMA、HugePage 需求）。内存碎片主要分为两类：</p><ul><li>外部碎片：指内存空间中存在许多不连续的小块空闲区域，虽然总空闲内存足够，但无法满足需要大块连续内存的分配请求。</li><li>内部碎片：指分配的内存块大于实际需要，导致块内部有未被使用的空间。</li></ul><h3 id="产生原因" tabindex="-1">产生原因 <a class="header-anchor" href="#产生原因" aria-label="Permalink to “产生原因”">​</a></h3><ul><li>频繁的内存分配和释放，尤其是不同大小的内存块混合分配时。</li><li>长时间运行的系统，内存分配模式复杂。</li><li>大量小对象或大对象交替分配。</li></ul><h3 id="常见的优化措施" tabindex="-1">常见的优化措施 <a class="header-anchor" href="#常见的优化措施" aria-label="Permalink to “常见的优化措施”">​</a></h3><ul><li>伙伴系统：通过合并相邻空闲块，减少外部碎片。</li><li>SLAB/SLUB 分配器：为不同类型和大小的对象建立专用缓存，减少内部碎片。</li><li>内存紧缩（Compaction）：内核支持将分散的空闲页面移动、合并为大块连续空间（如 <code>echo 1 &gt; /proc/sys/vm/compact_memory</code>）。</li><li>大页（HugePage）机制：减少页表项数量，降低碎片化概率。</li></ul><h3 id="内存紧缩" tabindex="-1">内存紧缩 <a class="header-anchor" href="#内存紧缩" aria-label="Permalink to “内存紧缩”">​</a></h3><p>内存紧缩（Memory Compaction）是 Linux 内核为减少外部碎片、提升大块连续物理内存（如大页 HugePage、DMA、设备驱动等场景）分配成功率而引入的机制。其核心思想是将分散的空闲页面移动、合并为更大的连续空闲块。内存紧缩会扫描物理内存，将分散的活跃页面迁移到一侧，将空闲页面集中到另一侧，从而形成大块的连续空闲内存。</p><h4 id="触发时机" tabindex="-1">触发时机 <a class="header-anchor" href="#触发时机" aria-label="Permalink to “触发时机”">​</a></h4><ul><li>自动触发：当内核检测到大块内存分配失败时，会自动尝试内存紧缩。</li><li>手动触发：可以通过写入 <code>/proc/sys/vm/compact_memory</code> 主动请求紧缩，例如：<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>echo 1 &gt; /proc/sys/vm/compact_memory</span></span></code></pre></div></li><li>也可通过 <code>echo 1 &gt; /sys/kernel/mm/compact_memory</code>（不同内核版本路径略有差异）。</li></ul><h2 id="内存监控和调优" tabindex="-1">内存监控和调优 <a class="header-anchor" href="#内存监控和调优" aria-label="Permalink to “内存监控和调优”">​</a></h2><ul><li><p>/proc 文件系统：</p><ul><li><code>/proc/meminfo</code>：显示系统整体内存使用情况。</li><li><code>/proc/buddyinfo</code>：展示各阶空闲内存块分布，便于分析碎片。</li><li><code>/proc/slabinfo</code>：SLAB/SLUB 分配器的缓存对象统计。</li><li><code>/proc/vmstat</code>：虚拟内存统计，包括紧缩、回收等信息。</li></ul></li><li><p>常用命令工具：</p><ul><li><code>free</code>：查看内存和 swap 使用情况。</li><li><code>top</code>/<code>htop</code>：实时监控进程内存占用。</li><li><code>vmstat</code>：虚拟内存、进程、CPU 等多维度统计。</li><li><code>smem</code>、<code>ps</code>、<code>pmap</code>：分析进程级内存分布。</li></ul></li><li><p>内存压力检测：</p><ul><li><code>/proc/pressure/memory</code>（PSI）：内存压力指标（新内核支持）。</li></ul></li><li><p>常见内核参数（可通过 sysctl 或 /proc/sys/vm/ 配置）：</p><ul><li><code>vm.swappiness</code>：控制内存与 swap 的平衡，值越大越倾向于使用 swap。</li><li><code>vm.min_free_kbytes</code>：设置系统预留的最小空闲内存，防止内存耗尽。</li><li><code>vm.dirty_ratio</code>/<code>vm.dirty_background_ratio</code>：控制脏页写回磁盘的阈值。</li><li><code>vm.overcommit_memory</code>/<code>vm.overcommit_ratio</code>：控制内存超分配策略。</li><li><code>vm.compaction_proactiveness</code>：控制内存紧缩的积极性。</li></ul></li></ul><h3 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to “思路”">​</a></h3><ul><li>根据实际业务负载调整 swappiness，避免频繁 swap。</li><li>监控碎片和紧缩效果，合理配置大页和紧缩参数。</li><li>定期分析 slab 缓存，防止内核对象泄漏。</li><li>关注内存压力指标，及时发现和处理内存瓶颈。</li><li>对于高性能场景，合理配置 HugePage、NUMA 策略等。</li></ul><p>通过科学的监控和调优，能够有效提升 Linux 系统的内存利用率和整体性能，降低 OOM 风险，保障关键业务的稳定运行。</p>`,68)])])}const u=i(n,[["render",p]]);export{k as __pageData,u as default};
