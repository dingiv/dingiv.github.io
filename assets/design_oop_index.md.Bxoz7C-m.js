import{_ as e,c as a,ae as l,o}from"./chunks/framework.BzDBnRMZ.js";const p=JSON.parse('{"title":"面向对象编程","description":"","frontmatter":{},"headers":[],"relativePath":"design/oop/index.md","filePath":"design/oop/index.md"}'),t={name:"design/oop/index.md"};function r(n,i,d,s,_,c){return o(),a("div",null,i[0]||(i[0]=[l('<h1 id="面向对象编程" tabindex="-1">面向对象编程 <a class="header-anchor" href="#面向对象编程" aria-label="Permalink to &quot;面向对象编程&quot;">​</a></h1><p>面向对象： 对象：封装、继承、多态</p><h2 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to &quot;SOLID&quot;">​</a></h2><ul><li>S: 单一职责原则，对象应该具有一种单一的功能</li><li>O: 开放封闭原则，对扩展开放，对修改关闭</li><li>L: 里氏替换原则，对象可以在不改变程序正确性的前提下被它的子类所替换的</li><li>I: 接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口</li><li>D: 依赖倒置原则，依赖于抽象而不是一个实例</li></ul><h2 id="具体做法" tabindex="-1">具体做法 <a class="header-anchor" href="#具体做法" aria-label="Permalink to &quot;具体做法&quot;">​</a></h2><ol><li>数据封装：对数据进行封装，限制数据的访问权限，特定数据只能由特定方法进行修改和管理</li><li>划分模块：将代码根据业务逻辑和功能，拆分成一个个小的模块，并且尽量保证功能的单一性，不将不同功能的代码混合到一起</li><li>单向依赖：不同的业务逻辑之间会存在依赖，他们的依赖关系可以形成一个图，这个图应该是一个单向无环图，最好是一棵树</li><li>依赖接口：模块之间进行依赖时，依赖于接口，不依赖于实现类，少用继承，多用实现（该做法在动态语言中可以适当放松）</li><li>依赖注入</li><li>封装数据</li></ol>',6)]))}const u=e(t,[["render",r]]);export{p as __pageData,u as default};
