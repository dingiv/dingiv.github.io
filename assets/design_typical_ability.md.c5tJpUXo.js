import{_ as i,o as s,c as a,ah as h}from"./chunks/framework.BvDvRtye.js";const o=JSON.parse('{"title":"质量属性","description":"","frontmatter":{"title":"质量属性","order":0},"headers":[],"relativePath":"design/typical/ability.md","filePath":"design/typical/ability.md"}'),d={name:"design/typical/ability.md"};function l(n,t,e,r,k,p){return s(),a("div",null,[...t[0]||(t[0]=[h(`<h1 id="软件设计质量属性" tabindex="-1">软件设计质量属性 <a class="header-anchor" href="#软件设计质量属性" aria-label="Permalink to “软件设计质量属性”">​</a></h1><p>软件工程的本质是管理复杂性。随着数字系统规模的指数级增长，开发者面临的最大挑战不再是单纯的逻辑实现，而是如何确保代码在不断变化的需求中保持可维护性、可扩展性和可读性。</p><p>软件设计质量属性（Software Quality Attributes，又称 -ilities）并非教条式的规则，而是经过数十年工业实践总结出的启发式方法论。它们为架构决策提供科学导航，帮助开发团队规避隐性技术债务，防止代码腐化，并提升软件系统的整体生命周期价值。</p><p>在一个成功的软件系统中，维护成本往往占据总成本的 80% 以上。设计原则通过鼓励代码重用、促进模块间的松耦合以及增强代码的透明度，直接降低了后续维护和功能扩展的成本。</p><h2 id="核心质量属性体系" tabindex="-1">核心质量属性体系 <a class="header-anchor" href="#核心质量属性体系" aria-label="Permalink to “核心质量属性体系”">​</a></h2><h3 id="功能与性能" tabindex="-1">功能与性能 <a class="header-anchor" href="#功能与性能" aria-label="Permalink to “功能与性能”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>正确性</td><td>程序按照预期实现了所需要的需求</td><td>需求设计、需求发掘</td></tr><tr><td>效率</td><td>资源利用率（CPU/内存/网络/存储）</td><td>利用率&lt;70%、GC暂停、尾延迟</td></tr><tr><td>极限负载</td><td>系统处理负载增长的能力（用户/数据/流量）</td><td>QPS、吞吐量、水平/垂直扩展、分片</td></tr><tr><td>响应性</td><td>端到端延迟（P50/P95/P99）</td><td>&lt;200ms UI、&lt;50ms API、异步处理</td></tr><tr><td>易用性</td><td>用户交互直观、学习曲线低</td><td>NPS、任务完成率、A/B测试</td></tr><tr><td>国际化</td><td>支持多语言/区域</td><td>i18n、RTL、时区处理</td></tr></tbody></table><h3 id="代码质量" tabindex="-1">代码质量 <a class="header-anchor" href="#代码质量" aria-label="Permalink to “代码质量”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可读性</td><td>代码是否能够被快速读懂</td><td>圈复杂度、命名、注释</td></tr><tr><td>可复用性</td><td>代码能否被复用</td><td>代码重复率、代码冗余</td></tr></tbody></table><h3 id="可用性与容错" tabindex="-1">可用性与容错 <a class="header-anchor" href="#可用性与容错" aria-label="Permalink to “可用性与容错”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>健壮性</td><td>系统在异常输入或环境下持续运行的能力</td><td>输入校验、熔断降级、错误处理边界测试</td></tr><tr><td>可靠性</td><td>系统在规定条件下和时间内执行预期功能且无故障的概率</td><td>MTBF、错误率、SLA达标率</td></tr><tr><td>可用性</td><td>系统正常运行时间比例</td><td>99.99%（&quot;four 9s&quot;）、MTBF/MTTR</td></tr><tr><td>恢复性</td><td>从故障/崩溃中恢复速度</td><td>RPO/RTO、快照回滚、蓝绿部署</td></tr><tr><td>安全性</td><td>抵抗攻击、数据保护、可攻击面</td><td>零信任、加密、RBAC、OWASP Top10</td></tr></tbody></table><h3 id="演进与变更" tabindex="-1">演进与变更 <a class="header-anchor" href="#演进与变更" aria-label="Permalink to “演进与变更”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可维护性</td><td>修复缺陷、添加功能的难易程度</td><td>可读性、圈复杂度、代码重复率、模块耦合度</td></tr><tr><td>可扩展性</td><td>添加新功能而不改核心代码</td><td>插件系统、接口隔离、事件驱动</td></tr><tr><td>可修改性</td><td>修改现有功能成本低</td><td>模块化、SOLID、ADR 记录</td></tr><tr><td>可移植性</td><td>跨环境/平台迁移容易</td><td>容器化、多云支持、标准协议</td></tr></tbody></table><h3 id="操作与部署" tabindex="-1">操作与部署 <a class="header-anchor" href="#操作与部署" aria-label="Permalink to “操作与部署”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可测试性</td><td>代码易于验证和测试的程度</td><td>单元测试覆盖率、依赖注入、接口抽象</td></tr><tr><td>可观测性</td><td>通过外部输出推断系统内部状态的能力</td><td>结构化日志、分布式链路追踪、指标监控</td></tr><tr><td>可部署性</td><td>快速、安全部署</td><td>CI/CD、GitOps、无缝升级</td></tr><tr><td>可配置性</td><td>通过配置调整行为</td><td>外部化配置、环境变量、Feature Flags</td></tr><tr><td>互操作性</td><td>与外部系统集成</td><td>API 标准（gRPC/REST）、Schema 演进</td></tr></tbody></table><h2 id="按生命周期阶段划分" tabindex="-1">按生命周期阶段划分 <a class="header-anchor" href="#按生命周期阶段划分" aria-label="Permalink to “按生命周期阶段划分”">​</a></h2><p>质量属性也可以按照软件生命周期的不同阶段来划分，这种划分有助于理解不同阶段各方的关注点和责任。</p><table tabindex="0"><thead><tr><th>阶段</th><th>主要关注点</th><th>典型质量属性（-ilities）</th></tr></thead><tbody><tr><td>开发</td><td>内部结构、可修改性、可读性、可测试基础</td><td>可维护性、可修改性、可测试性、可重用性、可移植性、可扩展性、可读性、模块化、架构一致性</td></tr><tr><td>测试</td><td>正确性、缺陷发现效率、验证覆盖度</td><td>可测试性、可靠性、正确性、健壮性、可观测性</td></tr><tr><td>运维</td><td>运行稳定性、故障恢复、监控效率</td><td>可用性、可靠性、可观测性、可伸缩性、容错性、恢复性、安全性、性能效率、可部署性</td></tr></tbody></table><p>度量工具</p><table tabindex="0"><thead><tr><th>阶段</th><th>典型度量方式 / 实践</th></tr></thead><tbody><tr><td>开发</td><td>代码审查、SonarQube静态分析、架构决策记录（ADR）、单元测试覆盖率、认知复杂度、耦合/内聚度</td></tr><tr><td>测试</td><td>测试覆盖率（代码/分支/路径）、缺陷密度、缺陷泄漏率、自动化测试通过率、MTTR（缺陷修复时间）</td></tr><tr><td>运维</td><td>SLO/SLI、错误预算、MTBF/MTTR、P99延迟、变更失败率、告警准确率、Chaos工程覆盖</td></tr></tbody></table><h3 id="开发阶段的质量是质量保证的根基" tabindex="-1">开发阶段的质量是质量保证的根基 <a class="header-anchor" href="#开发阶段的质量是质量保证的根基" aria-label="Permalink to “开发阶段的质量是质量保证的根基”">​</a></h3><p>缺陷在开发阶段修复成本最低，越往后（测试→上线→生产）成本呈指数增长（业界常见估算：1:10:100甚至更高）。</p><p>架构是否分层清晰、是否遵守 SOLID/DDD/整洁架构，直接决定可测试性和可维护性。如果开发阶段就把副作用到处散布、状态到处共享，后续测试几乎不可能写出确定性强的用例，运维也无法快速定位。</p><p>可观测性、可测试性等运维阶段关心的属性，必须在开发阶段就设计好。开发阶段的坏决策会让每一次需求变更都变成大手术，测试和运维只能被动救火。</p><ul><li>架构选错 → 测试难写、改一处动全局、运维频繁出故障</li><li>开发阶段缺乏可测试设计 → 测试用例爆炸、mock困难、 flaky 测试多</li><li>开发阶段忽略可观测性 → 故障定位慢、根因难找、反复重启、用户体验差</li></ul><h3 id="shift-left-策略" tabindex="-1">Shift-left 策略 <a class="header-anchor" href="#shift-left-策略" aria-label="Permalink to “Shift-left 策略”">​</a></h3><p>把质量把控前移到开发阶段：</p><ul><li>开发阶段就要写单元测试、契约测试、架构健身函数</li><li>可观测性优先设计：OpenTelemetry、结构化日志、trace 从开发阶段就内置</li><li>架构决策显式化：用 ADR 记录每个重要权衡</li><li>内建质量：CI 包含 lint、静态分析、架构违规检查、测试覆盖门限</li></ul><p>以下 C 代码示例体现了多属性设计思想：</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块化设计：可维护+可测试（接口隔离），容错（错误码）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">init)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfg);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 可配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 纯函数倾向，易测试</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cleanup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ModuleOps;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reliable_module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ModuleOps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ops</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cfg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ops </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ops-&gt;init) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EINVAL;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 健壮性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cfg);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ret) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                     // 恢复性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 核心逻辑：不可变输入，日志副作用隔离</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cfg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 一致错误处理，可观测</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个设计覆盖了 SRP（单一接口）、DIP（ops 抽象）、Fault Tolerance（检查+回滚）等多个原则。</p><h3 id="多角色视角的设计" tabindex="-1">多角色视角的设计 <a class="header-anchor" href="#多角色视角的设计" aria-label="Permalink to “多角色视角的设计”">​</a></h3><p>生命周期的划分正好对应了不同流程上负责不同任务的人。不同的人之间分工合作，但是也需要密切配合。</p><ul><li><p>开发人员视角：对开发人员来说，最好的设计是不言自明。KISS 原则在这里发挥重要作用，复杂的抽象层、过度的设计模式都会增加理解成本。最小惊讶原则要求代码的行为应该和它的名字完全一致。比如一个 <code>getName()</code> 方法绝对不应该在后台偷偷修改数据库。接口设计要符合直觉，如果一个功能需要跳转多层代码才能找到核心逻辑，那就是过度设计。</p></li><li><p>测试人员视角：测试人员最怕的是黑盒和逻辑耦合。依赖注入与解耦是解决之道：代码里到处是 <code>new</code> 出来的对象或单例，导致无法进行 Mock 测试。确定性也很重要，尽量减少代码对系统时间、随机数或外部状态的隐式依赖。一个不可测试的函数，其设计往往存在问题。</p></li><li><p>运维人员视角：对运维来说，代码只是在服务器上跑的进程。坏了怎么办？如何快速定位问题？可观测性设计要求在设计时就考虑结构化日志、链路追踪和健康检查接口。报错只抛出一个 <code>Internal Server Error</code> 而没有任何上下文，是运维人员的噩梦。防御式设计要求引入超时、限流和熔断。运维人员希望系统在压力过大时能优雅降级，而不是直接雪崩。</p></li></ul><p>为了平衡开发、测试、运维三个视角，现代软件设计引入了一些交叉领域的概念。契约测试明确 API 的输入输出规范，开发不用猜接口，测试有据可依。功能开关通过配置决定代码是否生效，运维可以随时关闭出问题的模块，开发可以小步快跑上线。12-Factor App 是一套云原生应用的设计准则（如配置与代码分离），极大降低了运维在不同环境下部署的难度。</p><h2 id="权衡框架" tabindex="-1">权衡框架 <a class="header-anchor" href="#权衡框架" aria-label="Permalink to “权衡框架”">​</a></h2><p>质量属性之间经常存在冲突，需要进行权衡。</p><h3 id="常见冲突" tabindex="-1">常见冲突 <a class="header-anchor" href="#常见冲突" aria-label="Permalink to “常见冲突”">​</a></h3><table tabindex="0"><thead><tr><th>高优先 → 低优先</th><th>冲突示例</th><th>缓解策略</th></tr></thead><tbody><tr><td>可用性</td><td>增加冗余 → 效率下降</td><td>自动缩放 + 监控</td></tr><tr><td>可伸缩性</td><td>分库分表 → 可维护性变差</td><td>CDC + 物化视图</td></tr><tr><td>安全性</td><td>加密/校验 → 性能下降</td><td>硬件加速 + 零拷贝</td></tr><tr><td>可测试性</td><td>依赖注入 → 部署复杂</td><td>容器 mock + 契约测试</td></tr></tbody></table><h3 id="iso-iec-25010-标准" tabindex="-1">ISO/IEC 25010 标准 <a class="header-anchor" href="#iso-iec-25010-标准" aria-label="Permalink to “ISO/IEC 25010 标准”">​</a></h3><p>ISO 25010 将质量属性分为<strong>产品质量</strong>（功能性、性能、兼容性、安全性等）和<strong>使用质量</strong>（可用性、效率等）。这为系统性地评估和权衡质量属性提供了标准框架。</p>`,41)])])}const y=i(d,[["render",l]]);export{o as __pageData,y as default};
