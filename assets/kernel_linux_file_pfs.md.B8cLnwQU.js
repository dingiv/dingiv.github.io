import{_ as o,o as c,c as d,ah as l}from"./chunks/framework.D8J2w7BQ.js";const _=JSON.parse('{"title":"伪文件系统","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/file/pfs.md","filePath":"kernel/linux/file/pfs.md"}'),i={name:"kernel/linux/file/pfs.md"};function s(t,e,r,p,a,u){return c(),d("div",null,[...e[0]||(e[0]=[l('<h1 id="伪文件系统" tabindex="-1">伪文件系统 <a class="header-anchor" href="#伪文件系统" aria-label="Permalink to “伪文件系统”">​</a></h1><p>伪文件系统（Pseudo Filesystems）是 Linux 虚拟文件子系统（VFS）中的一类特殊文件系统，不依赖物理存储设备，而是由内核动态生成，用于暴露内核数据结构、设备信息或系统状态给用户态。它们通过 VFS 提供文件接口，遵循“一切皆文件”的哲学，方便用户和程序访问内核信息。</p><p>文件和目录内容实时反映内核状态，运行时创建；部分伪文件系统（如 <code>/proc</code>）只读，部分（如 <code>/sys</code>）支持写操作以配置内核。</p><h2 id="常见伪文件" tabindex="-1">常见伪文件 <a class="header-anchor" href="#常见伪文件" aria-label="Permalink to “常见伪文件”">​</a></h2><ol><li><p>/proc（procfs）</p><ul><li>作用：提供进程和内核信息的接口，反映系统状态。</li><li>内容： <ul><li>进程信息：如 <code>/proc/[pid]/status</code>（进程状态）、<code>/proc/[pid]/maps</code>（内存映射）。</li><li>系统信息：如 <code>/proc/cpuinfo</code>（CPU 信息）、<code>/proc/meminfo</code>（内存使用）。</li><li>内核参数：如 <code>/proc/sys/kernel/</code>（可读写配置，如 <code>sysctl</code>）。</li></ul></li><li>实现： <ul><li>注册为 <code>proc_fs_type</code>，使用 <code>proc_dir_entry</code> 管理文件和目录。</li><li>通过 <code>proc_ops</code>（类似 <code>file_operations</code>）实现文件操作。</li></ul></li><li>示例：<code>cat /proc/uptime</code> 查看系统运行时间。</li></ul></li><li><p>/sys（sysfs）</p><ul><li>作用：暴露设备、驱动和内核对象的属性，支持设备管理和配置。</li><li>内容： <ul><li>设备拓扑：<code>/sys/devices/</code> 反映硬件层级。</li><li>设备类型：<code>/sys/class/</code>（如网卡 <code>/sys/class/net/</code>）。</li><li>驱动信息：<code>/sys/bus/</code>（如 PCI、USB 设备）。</li></ul></li><li>实现： <ul><li>基于 <code>struct kobject</code>，通过 <code>sysfs_ops</code> 提供读写接口。</li><li>设备驱动通过 <code>kobject</code> 创建 sysfs 条目，映射到文件。</li></ul></li><li>示例：<code>echo 1 &gt; /sys/class/leds/brightness</code> 控制 LED。</li></ul></li><li><p>/dev（devfs 或 udev）</p><ul><li>作用：提供设备文件接口，表示字符设备和块设备。</li><li>内容： <ul><li>字符设备（如 <code>/dev/tty</code>）、块设备（如 <code>/dev/sda</code>）。</li><li>动态管理：由 <code>udev</code>（用户态）或内核动态创建设备文件。</li></ul></li><li>实现： <ul><li>传统 devfs 已废弃，现由 <code>udev</code> 配合 tmpfs 实现。udev 是一个用户态的服务程序，通过监听内核的 uevent 硬件事件，特别是设备的插拔事件，从而来动态为 /dev 目录创建设备的虚拟文件，提供设备的访问接口。其他的伪文件系统是由内核实现的，而 /dev 伪文件由用户态的 udev 服务配合实现，这一点区别于其他的伪文件系统。</li><li>设备驱动通过 <code>register_chrdev</code> 或 <code>cdev_add</code> 注册，VFS 创建 <code>inode</code>（含 <code>i_cdev</code> 或 <code>i_bdev</code>）。</li></ul></li><li>示例：<code>cat /dev/random</code> 获取随机数。</li></ul></li><li><p>/tmpfs（tmpfs）</p><ul><li>作用：基于内存的文件系统，数据存储在 RAM，速度快，断电丢失。</li><li>内容：常用于临时文件或共享内存（如 <code>/dev/shm</code>）。</li><li>实现： <ul><li>注册为 <code>tmpfs_fs_type</code>，数据存储在页面缓存，无需块设备。</li><li>支持 <code>file_operations</code> 和 <code>inode_operations</code>。</li></ul></li><li>示例：<code>mount -t tmpfs tmpfs /mnt</code> 创建内存文件系统。</li></ul></li><li><p>/debug（debugfs）</p><ul><li>作用：提供内核开发者调试接口，暴露内部数据结构。</li><li>内容：自定义调试信息，由驱动或子系统注册（如 <code>/debug/tracing</code>）。</li><li>实现： <ul><li>注册为 <code>debugfs_fs_type</code>，通过 <code>debugfs_create_file</code> 创建文件。</li><li>提供简单接口（如 <code>debugfs_create_u32</code>）添加调试节点。</li></ul></li><li>示例：<code>cat /debug/tracing/trace</code> 查看内核跟踪日志。</li></ul></li></ol><h3 id="伪文件系统的工作原理" tabindex="-1">伪文件系统的工作原理 <a class="header-anchor" href="#伪文件系统的工作原理" aria-label="Permalink to “伪文件系统的工作原理”">​</a></h3><p>伪文件系统首先通过 <code>register_filesystem</code> 向内核注册自己的 <code>struct file_system_type</code>（如 <code>proc_fs_type</code>），并在挂载时（如 <code>mount -t proc proc /proc</code>）由 VFS 创建对应的 <code>struct super_block</code>。伪文件和目录在内核中由 <code>struct inode</code> 和 <code>struct dentry</code> 结构体表示，并绑定特定的操作函数（如 <code>proc_ops</code> 或 <code>sysfs_ops</code>），实现与 VFS 的集成。</p><p>与传统文件系统不同，伪文件系统的文件内容并不存储在磁盘上，而是由内核在访问时动态生成。每个文件的 <code>read</code> 或 <code>write</code> 回调函数会实时从内核数据结构中获取或更新信息，例如 <code>/proc/cpuinfo</code> 的 <code>read</code> 操作会读取当前 CPU 的相关信息。</p><p>用户通过常规的文件操作命令（如 <code>cat</code>、<code>echo</code>）访问这些伪文件，VFS 会调用伪文件系统实现的 <code>file_operations</code>。对于支持写操作的伪文件（如 <code>/sys</code>），写入会触发内核回调，从而实现对设备或内核参数的动态配置和管理。</p>',9)])])}const f=o(i,[["render",s]]);export{_ as __pageData,f as default};
