import{_ as a,c as t,o as r,ae as l}from"./chunks/framework.Dgg8-8ov.js";const c=JSON.parse('{"title":"平台设备","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/embed/bus/platform.md","filePath":"kernel/embed/bus/platform.md"}'),o={name:"kernel/embed/bus/platform.md"};function i(n,e,s,_,d,p){return r(),t("div",null,e[0]||(e[0]=[l('<h1 id="平台设备" tabindex="-1">平台设备 <a class="header-anchor" href="#平台设备" aria-label="Permalink to &quot;平台设备&quot;">​</a></h1><p>由于设备的类型众多，不同的实现五花八门，有的设备并不支持总线协议，需要硬件厂商或者嵌入式开发者自行实现硬件的探测和配置。非标准的设备杂乱无章，探测和描述设备变得困难，为了支持动态的修改设备探测的机制，Linux 提供了设备树机制，支持部分平台设备在不走 ACPI 的条件下，通过自定义设备树，提示内核探测自定义硬件。</p><p><strong>探测</strong>解决的问题是<strong>在物理内存地址空间上的哪一段上存在着一个怎样的设备</strong>？在此之后，操作系统才能初始化这个设备，然后给这个设备绑定驱动。</p><h2 id="设备行为" tabindex="-1">设备行为 <a class="header-anchor" href="#设备行为" aria-label="Permalink to &quot;设备行为&quot;">​</a></h2><ul><li>设备探测：识别平台设备存在及其硬件信息，依赖设备树或 ACPI 描述，无动态扫描；</li><li>资源配置：为设备分配硬件资源（如 MMIO 地址、中断号、时钟），基于设备树/ACPI 提供的信息；</li><li>电源管理：控制设备电源状态（如开启、挂起）；</li><li>数据传输：通过 MMIO 或 GPIO 与设备交换数据；</li><li>中断处理：通过中断机制，异步监听硬件事件，如：DMA、错误处理；</li></ul>',5)]))}const u=a(o,[["render",i]]);export{c as __pageData,u as default};
