import{_ as d,o as r,c as a,ah as o}from"./chunks/framework.BwbIerCg.js";const b=JSON.parse('{"title":"设计模式","description":"","frontmatter":{"title":"设计模式","order":2},"headers":[],"relativePath":"design/oop/pattern.md","filePath":"design/oop/pattern.md"}'),n={name:"design/oop/pattern.md"};function e(s,t,h,g,i,l){return r(),a("div",null,[...t[0]||(t[0]=[o('<h1 id="设计模式概述" tabindex="-1">设计模式概述 <a class="header-anchor" href="#设计模式概述" aria-label="Permalink to “设计模式概述”">​</a></h1><p>设计模式是指在软件设计中，对反复出现的问题提出的通用、可复用的解决方案。它不是具体的代码片段，而是一种经过验证的设计模板或思路，可以根据具体场景进行调整和实现。设计模式是软件开发中常见问题的典型解决方案，目的是让代码更易维护、易扩展、易理解、可复用。</p><h2 id="_23-种经典设计模式全览" tabindex="-1">23 种经典设计模式全览 <a class="header-anchor" href="#_23-种经典设计模式全览" aria-label="Permalink to “23 种经典设计模式全览”">​</a></h2><p>根据 GoF（Gang of Four）的经典分类，设计模式分为创建型、结构型和行为型三大类。</p><h3 id="创建型模式-5-种" tabindex="-1">创建型模式（5 种） <a class="header-anchor" href="#创建型模式-5-种" aria-label="Permalink to “创建型模式（5 种）”">​</a></h3><table tabindex="0"><thead><tr><th>模式名称</th><th>核心思想</th><th>典型应用场景</th><th>现代替代方案</th></tr></thead><tbody><tr><td><strong>单例</strong></td><td>保证一个类仅有一个实例</td><td>配置管理器、日志记录器、数据库连接池</td><td>依赖注入容器、模块化系统</td></tr><tr><td><strong>工厂方法</strong></td><td>定义创建对象的接口，由子类决定实例化</td><td>框架扩展点、插件系统</td><td>依赖注入、函数式工厂</td></tr><tr><td><strong>抽象工厂</strong></td><td>创建产品族，无需指定具体类</td><td>跨平台 UI 组件、数据库驱动</td><td>构建器模式、依赖注入</td></tr><tr><td><strong>建造者</strong></td><td>分步骤构建复杂对象</td><td>配置对象构建、DSL 链式调用</td><td>数据类、命名参数</td></tr><tr><td><strong>原型</strong></td><td>通过复制现有对象创建新对象</td><td>对象池、减少初始化开销</td><td>深拷贝函数、不可变数据结构</td></tr></tbody></table><h3 id="结构型模式-7-种" tabindex="-1">结构型模式（7 种） <a class="header-anchor" href="#结构型模式-7-种" aria-label="Permalink to “结构型模式（7 种）”">​</a></h3><table tabindex="0"><thead><tr><th>模式名称</th><th>核心思想</th><th>典型应用场景</th><th>现代替代方案</th></tr></thead><tbody><tr><td><strong>适配器</strong></td><td>转换不兼容接口</td><td>新旧系统对接、第三方库集成</td><td>函数包装器、中间件</td></tr><tr><td><strong>桥接</strong></td><td>分离抽象与实现</td><td>跨平台渲染、形状与颜色组合</td><td>组合优于继承、函数组合</td></tr><tr><td><strong>组合</strong></td><td>树形结构表示部分-整体层次</td><td>文件系统、UI 组件树</td><td>递归数据结构、代数数据类型</td></tr><tr><td><strong>装饰器</strong></td><td>动态添加功能</td><td>中间件系统、流处理</td><td>高阶函数、函数组合</td></tr><tr><td><strong>外观</strong></td><td>为复杂子系统提供简单接口</td><td>API 网关、库封装</td><td>模块化导出、Facade 函数</td></tr><tr><td><strong>享元</strong></td><td>共享对象减少内存</td><td>对象池、字符串驻留</td><td>不可变数据、结构共享</td></tr><tr><td><strong>代理</strong></td><td>控制对象访问</td><td>远程代理、懒加载、访问控制</td><td>函数包装、惰性求值</td></tr></tbody></table><h3 id="行为型模式-11-种" tabindex="-1">行为型模式（11 种） <a class="header-anchor" href="#行为型模式-11-种" aria-label="Permalink to “行为型模式（11 种）”">​</a></h3><table tabindex="0"><thead><tr><th>模式名称</th><th>核心思想</th><th>典型应用场景</th><th>现代替代方案</th></tr></thead><tbody><tr><td><strong>观察者</strong></td><td>一对多依赖，状态变化通知</td><td>事件驱动架构、响应式 UI</td><td>响应式流、信号机制</td></tr><tr><td><strong>策略</strong></td><td>算法封装，可互换</td><td>支付方式、排序算法、验证规则</td><td>一等函数、模式匹配</td></tr><tr><td><strong>命令</strong></td><td>请求封装为对象</td><td>撤销重做、任务队列、宏命令</td><td>一等函数、代数数据类型</td></tr><tr><td><strong>状态</strong></td><td>状态改变行为</td><td>工作流、订单状态、游戏角色</td><td>状态机、模式匹配</td></tr><tr><td><strong>模板方法</strong></td><td>父类定义算法骨架</td><td>框架设计、钩子方法</td><td>高阶函数、组合</td></tr><tr><td><strong>责任链</strong></td><td>请求沿处理链传递</td><td>日志记录、异常处理、中间件</td><td>函数组合、管道模式</td></tr><tr><td><strong>访问者</strong></td><td>不改变类结构定义新操作</td><td>编译器语法树、文档生成</td><td>模式匹配、多方法</td></tr><tr><td><strong>中介者</strong></td><td>封装对象交互</td><td>聊天室、表单验证</td><td>事件总线、响应式状态</td></tr><tr><td><strong>迭代器</strong></td><td>统一遍历集合接口</td><td>集合遍历、生成器</td><td>惰性序列、for 推导</td></tr><tr><td><strong>备忘录</strong></td><td>捕获对象内部状态</td><td>撤销功能、快照</td><td>不可变数据、时间旅行调试</td></tr><tr><td><strong>解释器</strong></td><td>定义语言文法表示</td><td>配置文件解析、DSL、SQL 解析</td><td>解析器组合子、PEG</td></tr></tbody></table><h2 id="设计模式精选-函数式视角" tabindex="-1">设计模式精选：函数式视角 <a class="header-anchor" href="#设计模式精选-函数式视角" aria-label="Permalink to “设计模式精选：函数式视角”">​</a></h2><p>随着函数式编程思想在主流语言中的普及，许多经典设计模式的存在形式发生了本质变化。一些模式被语言特性直接吸收，一些模式在高阶函数和不可变数据面前显得多余，还有一些模式则以新的面貌继续发挥作用。</p><h3 id="模式的本质是语言缺陷的补丁" tabindex="-1">模式的本质是语言缺陷的补丁 <a class="header-anchor" href="#模式的本质是语言缺陷的补丁" aria-label="Permalink to “模式的本质是语言缺陷的补丁”">​</a></h3><p>设计模式的诞生背景是 C++ 和 Java 这类早期 OOP 语言的局限性：缺乏一等函数、缺乏模式匹配、缺乏不可变数据、缺乏类型推导。当语言本身提供了这些能力后，很多模式就不再需要显式实现。</p><table tabindex="0"><thead><tr><th>经典模式</th><th>函数式替代方案</th><th>本质转变</th></tr></thead><tbody><tr><td>策略模式</td><td>一等函数传参</td><td>从&quot;对象包装函数&quot;到&quot;函数直接传递&quot;</td></tr><tr><td>命令模式</td><td>一等函数</td><td>从&quot;命令对象&quot;到&quot;闭包&quot;</td></tr><tr><td>模板方法</td><td>高阶函数</td><td>从&quot;继承重写&quot;到&quot;函数组合&quot;</td></tr><tr><td>装饰器</td><td>函数组合</td><td>从&quot;包装类&quot;到<code>f ∘ g</code></td></tr><tr><td>迭代器</td><td>惰性序列/for 推导</td><td>从&quot;迭代器对象&quot;到&quot;惰性求值&quot;</td></tr><tr><td>责任链</td><td>函数管道</td><td>从&quot;链式对象&quot;到<code>pipe(f1, f2, f3)</code></td></tr><tr><td>适配器</td><td>函数包装器</td><td>从&quot;适配器类&quot;到&quot;λx. f(g(x))&quot;</td></tr><tr><td>访问者</td><td>模式匹配</td><td>从&quot;双重分发&quot;到&quot;match { case... }&quot;</td></tr></tbody></table><h3 id="_2026-年仍然值得关注的模式" tabindex="-1">2026 年仍然值得关注的模式 <a class="header-anchor" href="#_2026-年仍然值得关注的模式" aria-label="Permalink to “2026 年仍然值得关注的模式”">​</a></h3><p>并非所有模式都消失了。以下模式在现代开发中依然重要，只是实现方式更简洁。</p><p><strong>观察者模式/响应式</strong>：Vue 和 React 的响应式系统本质是观察者模式的自动化实现，但开发者无需手动维护订阅列表。Signals（如 Preact Solid）将这一模式进一步推向声明式。</p><p><strong>依赖注入</strong>：本质是工厂模式、策略模式和代理模式的组合。现代 DI 容器（如 Spring、.NET Core）通过类型推导和装饰器实现了极简的使用体验。</p><p><strong>状态机</strong>：XState 等库将状态模式推向新高度，配合 TypeScript 的类型推导，可以做到状态转换的编译期检查。</p><p><strong>组合模式</strong>：React/Vue 的组件树是组合模式的应用，配合函数式组件和 hooks，实现方式比传统的 OOP 更加简洁。</p><p><strong>中间件模式</strong>：Express、Koa、Redux 的中间件本质是装饰器模式和责任链模式的结合，通过函数链式调用实现。</p><p><strong>构建器模式</strong>：数据类（data class）、命名参数、解构赋值等语言特性使得构建复杂对象不再需要繁琐的 Builder 类。</p><h3 id="被时代淘汰的模式" tabindex="-1">被时代淘汰的模式 <a class="header-anchor" href="#被时代淘汰的模式" aria-label="Permalink to “被时代淘汰的模式”">​</a></h3><p>以下模式在函数式编程背景下逐渐淡出：简单工厂/工厂方法/抽象工厂被依赖注入容器接管、模块化系统提供了天然的工厂机制；迭代器被 for 推导、惰性序列、数组方法取代；模板方法被高阶函数和组合取代；访问者被模式匹配和代数数据类型取代；备忘录被不可变数据结构取代，天然支持时间旅行调试。</p><h2 id="反模式" tabindex="-1">反模式 <a class="header-anchor" href="#反模式" aria-label="Permalink to “反模式”">​</a></h2><p>反模式是指那些看似合理但实际上会导致负面效果的设计或实践。识别反模式比学习正面模式同样重要。</p><h3 id="架构层面的反模式" tabindex="-1">架构层面的反模式 <a class="header-anchor" href="#架构层面的反模式" aria-label="Permalink to “架构层面的反模式”">​</a></h3><table tabindex="0"><thead><tr><th>反模式名称</th><th>表现特征</th><th>负面影响</th><th>正确做法</th></tr></thead><tbody><tr><td><strong>大泥球</strong></td><td>缺乏清晰结构，代码纠缠在一起</td><td>难以维护、难以测试</td><td>按业务领域划分模块，建立清晰边界</td></tr><tr><td><strong>面条代码</strong></td><td>控制流混乱，大量 goto 或深层嵌套</td><td>难以理解、容易出错</td><td>使用结构化编程，提取函数，提前返回</td></tr><tr><td><strong>黄金锤</strong></td><td>用一种技术解决所有问题</td><td>技术选型不当，过度设计</td><td>根据问题特性选择合适工具</td></tr><tr><td><strong>造轮子</strong></td><td>重复实现已有功能</td><td>浪费时间、质量不如成熟方案</td><td>优先使用成熟库和框架</td></tr></tbody></table><h3 id="面向对象特有的反模式" tabindex="-1">面向对象特有的反模式 <a class="header-anchor" href="#面向对象特有的反模式" aria-label="Permalink to “面向对象特有的反模式”">​</a></h3><table tabindex="0"><thead><tr><th>反模式名称</th><th>表现特征</th><th>负面影响</th><th>正确做法</th></tr></thead><tbody><tr><td><strong>上帝对象</strong></td><td>一个类承担过多职责</td><td>难以理解、难以测试、难以维护</td><td>单一职责原则，拆分职责</td></tr><tr><td><strong>贫血模型</strong></td><td>领域对象只有数据没有行为</td><td>业务逻辑散落，丢失 OOP 优势</td><td>充血模型，行为与数据绑定</td></tr><tr><td><strong>紧耦合</strong></td><td>类之间依赖关系复杂</td><td>改一处牵动全身</td><td>依赖倒置，面向接口编程</td></tr><tr><td><strong>滥用继承</strong></td><td>为复用代码而继承</td><td>层次过深，脆弱基类问题</td><td>组合优于继承</td></tr><tr><td><strong>循环依赖</strong></td><td>A 依赖 B，B 依赖 A</td><td>编译失败、初始化困难</td><td>重新设计模块边界，引入中间层</td></tr><tr><td><strong>单例滥用</strong></td><td>到处使用单例</td><td>隐式依赖、难以测试、全局状态</td><td>依赖注入，限定作用域</td></tr></tbody></table><h3 id="代码层面的反模式" tabindex="-1">代码层面的反模式 <a class="header-anchor" href="#代码层面的反模式" aria-label="Permalink to “代码层面的反模式”">​</a></h3><p><strong>魔法数字</strong>：直接使用未命名常量，用命名常量或枚举替代。</p><p><strong>过长参数列表</strong>：函数参数超过 5 个，使用参数对象或选项模式。</p><p><strong>深层嵌套</strong>：缩进层级过深，使用提前返回和提取函数。</p><p><strong>重复代码</strong>：相同逻辑出现多次，提取函数或模板。</p><p><strong>过早优化</strong>：在未确认性能瓶颈前优化，先测量再优化。</p><p><strong>注释掉代码</strong>：保留注释掉的旧代码，用版本控制管理历史。</p><p><strong>捕获所有异常</strong>：空的 catch 块或捕获 Exception，精确捕获可处理的异常。</p>',39)])])}const c=d(n,[["render",e]]);export{b as __pageData,c as default};
