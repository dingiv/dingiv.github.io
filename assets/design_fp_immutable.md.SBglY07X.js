import{_ as i,o as a,c as n,ah as l,b2 as h}from"./chunks/framework.BvDvRtye.js";const g=JSON.parse('{"title":"不可变","description":"","frontmatter":{},"headers":[],"relativePath":"design/fp/immutable.md","filePath":"design/fp/immutable.md"}'),e={name:"design/fp/immutable.md"};function t(p,s,k,r,d,E){return a(),n("div",null,[...s[0]||(s[0]=[l('<h1 id="不可变" tabindex="-1">不可变 <a class="header-anchor" href="#不可变" aria-label="Permalink to “不可变”">​</a></h1><h2 id="函数式编程的四个概念" tabindex="-1">函数式编程的四个概念 <a class="header-anchor" href="#函数式编程的四个概念" aria-label="Permalink to “函数式编程的四个概念”">​</a></h2><p>函数式的世界围绕四个基本概念展开：常量、纯函数、变量、脏函数。要理解这些概念，需要先建立对生命周期和作用域的认知。</p><ul><li>生命周期：在程序运行期间，一个对象或者数据从创建到销毁的那一段时间。创建 -&gt; 读取* n / 更新* n -&gt; 销毁，（6 个 hook）。常量只会经历创建、读取和销毁，而变量会经历更新。</li><li>作用域：全局作用域和局部作用域，全局作用域对程序的所有部分可见，生命周期贯穿整个程序运行期间，一次程序运行期间只会被展开一次，由此导致了其作用域中的状态只能经历一次创建和销毁；局部作用域对某个部分的程序和代码可见。</li><li>所有权：状态具有所有权归属，往往是声明这个状态的最近一级作用域拥有其所有权。作用域需要资源的释放。</li><li>副作用：一个函数在运行的时候，与外界发生了交互，对外界产生了影响。</li></ul><p><img src="'+h+`" alt=""></p><p>基于这些基础概念，函数式编程对变量的使用提出了明确约束：</p><ul><li>优先使用常量而非变量，避免使用全局变量（只有常量才能全局）;</li><li>当需要改变值时，销毁旧值并创建新值；</li><li>程序中的函数应当尽可能保持纯净；</li></ul><h3 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to “常量”">​</a></h3><p>常量是指一经创建就不再改变值的量，具有可确定性、可复用性和可组合性，这些特性使其适合被放置在全局作用域中，拥有广泛的可见性和较长的生命周期。在实际工程中，合理使用常量可以减少状态管理的复杂度，让程序的行为更加可预测。</p><h3 id="纯函数" tabindex="-1">纯函数 <a class="header-anchor" href="#纯函数" aria-label="Permalink to “纯函数”">​</a></h3><p>纯函数是函数式编程的核心概念，它接受输入并返回输出，输出仅依赖于输入参数而不受外部状态影响。相同的输入永远产生相同的输出，这种一一对应关系赋予纯函数纯洁性、可复用性、可组合性、可测试性和高可维护性，使其适合放置在全局作用域中拥有广泛的可见性和较长的生命周期。</p><p>纯函数的优势：</p><ul><li>可确定性：具有可控的行为和确定的输入输出；这使得程序员可以轻松地理解和预测纯函数的行为，便于使用和维护；</li><li>可测试性：不依赖于外界环境，可以方便地测试；而脏函数，在测试前需要对环境进行初始化，测试后需要对环境进行清理，增加了测试的复杂度；</li><li>可移植性和可复用性：不依赖外界环境，可以轻松移植到不同的平台，这里说的外界环境，包括全局变量、IO操作、网络请求等常见的程序操作；同时，由于依赖少，可以轻松地被复用，减少了代码的重复性；</li><li>可重入性和可并行性：不会改变外部状态，可以随意并行，简化了<strong>多线程编程</strong>的难度；同时，可重入性，带来了<strong>响应式编程</strong>的便利性，因为要无痛响应，保持函数行为的可控是一个重要前提；</li><li>可缓存性：可以轻松进行缓存，主要用于耗时任务，加快程序的速度；</li></ul><h3 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to “变量”">​</a></h3><p>变量是相对于常量而言的概念，具有<strong>不确定性和 update 生命周期</strong>，在函数式编程中通常被称为状态。在大型的应用程序中，程序的复杂性往往因为变量的不可控而大大增加。</p><p>当我们需要对变量进行操作时，由于变量的不确定性，必须先校验变量的合法性才能执行操作。当一个程序依赖多个变量时，校验的复杂度会随之飙升，而当多个程序模块共享变量时，每个模块都需要重复进行校验。更复杂的是，当变量之间存在依赖关系时，一个或多个变量的变化会引发连锁反应，同步依赖变量的状态变化成为复杂而繁琐的问题，在多线程环境下还可能引入资源竞争问题。</p><p>因此，工程实践中应当尽量缩短变量的生命周期，限制其作用域，从而降低程序复杂度并保证可维护性。对于变量间的依赖同步问题，响应式编程提供了有效的解决方案。</p><h3 id="脏函数" tabindex="-1">脏函数 <a class="header-anchor" href="#脏函数" aria-label="Permalink to “脏函数”">​</a></h3><p>脏函数是相对于纯函数而言的概念，如果一个函数与外界发生交互并造成了意想不到的影响，就称为脏函数或副作用。副作用主要通过四种途径产生：</p><ul><li>函数直接依赖或引用了<strong>外部作用域中的变量</strong>，从而形成了隐式参数；</li><li>函数通过传入的参数指针修改了指针指向的数据，从而对其参数进行了修改；</li><li>函数执行了 IO 操作，如读写文件、网络请求等，其本质是修改外界数据的状态；</li><li>调用了其他脏函数（脏函数的传染性）；</li></ul><p>总结下来，脏函数主要有三种类型：隐参函数、写参函数和 IO 函数。</p><blockquote><p><strong>JS 中的隐性副作用</strong></p><p>除去一些常见的副作用，JS 中有一些隐性副作用可能会被忽略，如：</p><ol><li><code>async/await</code> 和 Promise 的使用；</li><li><code>setTimeout</code>、<code>setInterval</code> 的使用；</li><li><code>Math.random()</code> 和 <code>Date.now()</code> 的使用；</li><li><code>console.log()</code> 的使用；</li><li>多数 Web API 的使用；</li><li>......</li></ol></blockquote><h2 id="状态管理" tabindex="-1">状态管理 <a class="header-anchor" href="#状态管理" aria-label="Permalink to “状态管理”">​</a></h2><p>对于变量而言，我们无法完全避免其副作用，但可以通过一些手段来减少副作用的影响范围，从而降低程序复杂度并保证程序的可维护性。<a href="./state">状态管理</a>就是致力于解决这个问题的方案，其核心思路是使用容器维护变量的生命周期，并向下游提供统一的API，下游不再直接操作数据而是通过状态管理容器的API来访问。</p><h2 id="io-处理" tabindex="-1">IO 处理 <a class="header-anchor" href="#io-处理" aria-label="Permalink to “IO 处理”">​</a></h2><p>程序与外界交互时不可避免会产生副作用，<a href="./io">IO处理</a>提供了将这些副作用隔离和管理的机制。通过声明式IO和响应式编程，我们可以将IO操作转化为状态修改的操作，使用统一的编码模型去管理IO和状态。</p><h2 id="脏函数和副作用" tabindex="-1">脏函数和副作用 <a class="header-anchor" href="#脏函数和副作用" aria-label="Permalink to “脏函数和副作用”">​</a></h2><p>在程序设计中，我们无法完全避免副作用，但可以通过一些手段来减少副作用的影响范围，从而降低程序复杂度并保证可维护性。程序的入口函数main通常是一个脏函数，它接受输入、调用函数并输出结果，一个程序最理想的状态是除了main函数外，其他函数都是纯函数。</p><h3 id="脏函数的延迟执行" tabindex="-1">脏函数的延迟执行 <a class="header-anchor" href="#脏函数的延迟执行" aria-label="Permalink to “脏函数的延迟执行”">​</a></h3><p>脏函数在不被调用之前可以认为是无害的，但一旦被调用就会产生副作用。函数式编程并非要完全消除副作用，而是将副作用局限在尽可能小的范围内，或将副作用的发生延迟到尽可能后期，最迟是在用户输入数据（前端）或对外界进行访问（后端）的时候，因为此时发生的副作用是无可避免的。我们可以采用惰性求值和声明式副作用来延迟副作用的发生。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Dirty</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Pure</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, env.encoding);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReadAction</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 read 这个 IO 动作抽象为一个数据结构或者说是配置，使用纯函数定义配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: path,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    encoding : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用接受某种配置，然后执行一个 IO 操作的执行器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> executeAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action.path, action.encoding);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="脏函数的可原谅性" tabindex="-1">脏函数的可原谅性 <a class="header-anchor" href="#脏函数的可原谅性" aria-label="Permalink to “脏函数的可原谅性”">​</a></h3><p>在实际开发中，我们无法完全避免副作用，但可以选择原谅一些副作用以获得更高的开发自由度。</p><ol><li><strong>私有闭包</strong>，一个<strong>闭包函数</strong>独享了一个外部变量，这个外部变量除了这个函数，其他函数都不能访问。可以认为这个外部变量是函数私有的，这个副作用是可原谅的；典型例子：随机数生成器、节流函数、单例函数、函数缓存；在 JS 中，由于是单线程的，所以私有闭包不需要考虑并发问题；</li><li><strong>局部变量</strong>，如果一个函数在内部创建了一个变量，即拥有一个变量的<strong>创造权</strong>，可以认为这是在<strong>初始化</strong>阶段，那么在函数的内部修改该变量或者调用<strong>写参函数</strong>修改它，不会被传染；</li><li><strong>独立 IO</strong>，在函数中，调用了一些独立性较强的 IO 模块，这些模块对程序的主体功能没有直接影响，并且不会抛出错误，如日志打印、调试信息等，这些方法往往独立于程序的主体逻辑，不容易增加程序的逻辑复杂度，这些副作用是可原谅的；</li></ol>`,34)])])}const c=i(e,[["render",t]]);export{g as __pageData,c as default};
