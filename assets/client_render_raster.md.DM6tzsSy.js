import{_ as i,c as a,o as e,ae as r}from"./chunks/framework.BQlYxExx.js";const p=JSON.parse('{"title":"光栅化管线","description":"","frontmatter":{},"headers":[],"relativePath":"client/render/raster.md","filePath":"client/render/raster.md"}'),t={name:"client/render/raster.md"};function n(o,l,u,d,s,h){return e(),a("div",null,[...l[0]||(l[0]=[r('<h1 id="光栅化管线" tabindex="-1">光栅化管线 <a class="header-anchor" href="#光栅化管线" aria-label="Permalink to &quot;光栅化管线&quot;">​</a></h1><p>光栅化管线由多个有序阶段组成，每个阶段专注于特定的处理任务，共同协作完成渲染。管线运行于 GPU，充分利用其并行计算能力，达到实时渲染的性能要求（通常 30-60 帧每秒）。光栅化管线的设计兼顾了速度与质量，适用于游戏、虚拟现实、实时可视化等场景。</p><p>光栅化管线与光线追踪管线不同，前者基于几何投影和像素填充，快速生成近似光照效果；后者模拟真实光路，追求物理真实感，但计算成本较高。光栅化管线的优势在于硬件优化和实时性，使其成为现代图形渲染的基石。</p><h2 id="主要流程" tabindex="-1">主要流程 <a class="header-anchor" href="#主要流程" aria-label="Permalink to &quot;主要流程&quot;">​</a></h2><p>光栅化管线由以下主要阶段组成，分为 CPU 端的应用程序阶段和 GPU 端的渲染阶段。每个阶段功能明确，协同完成从几何到像素的转换。</p><h3 id="应用程序阶段-application-stage" tabindex="-1">应用程序阶段（Application Stage） <a class="header-anchor" href="#应用程序阶段-application-stage" aria-label="Permalink to &quot;应用程序阶段（Application Stage）&quot;">​</a></h3><ul><li>功能：运行于 CPU，由开发者控制，负责准备渲染所需的数据和逻辑。</li><li>任务： <ul><li>场景管理：组织三维场景中的物体（模型、相机、光源）。</li><li>数据准备：生成顶点数据（位置、法向量、纹理坐标）、索引缓冲区、纹理、变换矩阵（模型、视图、投影）。</li><li>动画与物理：计算物体运动、骨骼动画、碰撞检测等。</li><li>剔除优化：执行视锥剔除（Frustum Culling）、遮挡剔除（Occlusion Culling），减少无效物体提交。</li><li>绘制命令：通过 API（如 <code>glDrawArrays</code>）提交渲染指令。</li></ul></li><li>优化点： <ul><li>批量提交数据，减少 CPU-GPU 通信。</li><li>使用顶点缓存（Vertex Buffer Objects, VBO）高效传输几何。</li></ul></li></ul><h3 id="顶点着色-vertex-shading" tabindex="-1">顶点着色（Vertex Shading） <a class="header-anchor" href="#顶点着色-vertex-shading" aria-label="Permalink to &quot;顶点着色（Vertex Shading）&quot;">​</a></h3><ul><li>功能：GPU 上运行的可编程阶段，处理每个顶点的几何变换和属性计算。</li><li>任务： <ul><li>坐标变换：将顶点从模型空间依次变换到世界空间、观察空间（视图矩阵）、裁剪空间（投影矩阵）。</li><li>属性计算：处理法向量（用于光照）、纹理坐标、顶点颜色等。</li><li>输出：裁剪空间坐标（<code>gl_Position</code>）和其他属性，传递给后续阶段。</li></ul></li><li>优化点：使用统一变量（Uniforms）传递矩阵，减少重复计算。</li></ul><h3 id="图元组装与裁剪-primitive-assembly-clipping" tabindex="-1">图元组装与裁剪（Primitive Assembly &amp; Clipping） <a class="header-anchor" href="#图元组装与裁剪-primitive-assembly-clipping" aria-label="Permalink to &quot;图元组装与裁剪（Primitive Assembly &amp; Clipping）&quot;">​</a></h3><ul><li>功能：将顶点组织为图元（如三角形、线段、点），并进行裁剪优化。</li><li>任务： <ul><li>图元组装：根据绘制命令（如 <code>GL_TRIANGLES</code>）和索引，将顶点连接为三角形。</li><li>背面剔除：根据顶点顺序（逆时针 CCW 为正面，顺时针 CW 为反面）移除不可见三角形（<code>glEnable(GL_CULL_FACE)</code>）。</li><li>视锥裁剪：剔除位于视锥体外的图元，裁剪部分可见图元。</li></ul></li><li>与背景联系： <ul><li>你的三角面正反面问题：CCW 顺序定义正面，影响背面剔除。</li><li>GLFW 示例中，<code>glBegin(GL_TRIANGLES)</code> 指定三角形图元。</li></ul></li><li>优化点：提前剔除减少光栅化负担。</li></ul><h3 id="光栅化-rasterization" tabindex="-1">光栅化（Rasterization） <a class="header-anchor" href="#光栅化-rasterization" aria-label="Permalink to &quot;光栅化（Rasterization）&quot;">​</a></h3><ul><li>功能：将连续的图元转换为离散的像素片段（Fragments）。</li><li>任务： <ul><li>扫描转换：确定三角形覆盖的像素，使用扫描线算法。</li><li>属性插值：插值顶点属性（如颜色、法线、纹理坐标），生成每个片段的数据。</li><li>透视校正：对纹理坐标等属性进行透视校正，避免失真。</li></ul></li><li>优化点：使用多级纹理（Mipmaps）优化纹理采样。</li></ul><h3 id="片段着色-fragment-shading" tabindex="-1">片段着色（Fragment Shading） <a class="header-anchor" href="#片段着色-fragment-shading" aria-label="Permalink to &quot;片段着色（Fragment Shading）&quot;">​</a></h3><ul><li>功能：为每个片段计算最终颜色，决定像素外观。</li><li>任务： <ul><li>光照模型：实现环境光、漫反射（Lambert）、镜面反射（Phong）等。</li><li>纹理采样：从纹理中获取颜色或法线（法线贴图）。</li><li>高级效果：阴影贴图、环境光遮蔽（SSAO）、基于物理的渲染（PBR）。</li></ul></li><li>优化点：延迟渲染（Deferred Shading）减少光照计算。</li></ul><h3 id="测试与混合-testing-blending" tabindex="-1">测试与混合（Testing &amp; Blending） <a class="header-anchor" href="#测试与混合-testing-blending" aria-label="Permalink to &quot;测试与混合（Testing &amp; Blending）&quot;">​</a></h3><ul><li>功能：决定片段是否写入帧缓冲区，以及如何与现有像素合成。</li><li>任务： <ul><li>深度测试：比较片段深度（<code>glEnable(GL_DEPTH_TEST)</code>），剔除被遮挡的片段。</li><li>模板测试：用于特殊效果（如轮廓、镜像）。</li><li>混合：处理透明效果（<code>glBlendFunc</code>），如玻璃、烟雾。</li><li>抗锯齿：如多重采样抗锯齿（MSAA），平滑边缘。</li></ul></li><li>优化点：早期深度测试（Early-Z）减少片段着色开销。</li></ul><h3 id="输出与显示-framebuffer-output" tabindex="-1">输出与显示（Framebuffer Output） <a class="header-anchor" href="#输出与显示-framebuffer-output" aria-label="Permalink to &quot;输出与显示（Framebuffer Output）&quot;">​</a></h3><ul><li>功能：将帧缓冲区的像素数据显示到屏幕。</li><li>任务： <ul><li>双缓冲交换（<code>glfwSwapBuffers</code>），避免闪烁。</li><li>输出到渲染目标（Render Target），用于后处理或离屏渲染。</li></ul></li></ul><h2 id="光照模型" tabindex="-1">光照模型 <a class="header-anchor" href="#光照模型" aria-label="Permalink to &quot;光照模型&quot;">​</a></h2><ul><li>光照模型： <ul><li>环境光：全局亮度，模拟间接光照。</li><li>漫反射：基于法向量和光方向（如 Lambert）。</li><li>镜面反射：高光效果（如 Phong，考虑视角）。</li><li>PBR：基于 BSDF（如 GGX），结合微表面、菲涅耳效应。</li></ul></li><li>法线贴图：增强表面细节，无需增加几何复杂度。</li><li>纹理优化：Mipmaps、纹理压缩（如 BC7）减少内存占用。</li></ul><h2 id="抗锯齿" tabindex="-1">抗锯齿 <a class="header-anchor" href="#抗锯齿" aria-label="Permalink to &quot;抗锯齿&quot;">​</a></h2><ul><li>抗锯齿： <ul><li>MSAA：多重采样，平滑边缘。</li><li>FXAA/TAA：后处理抗锯齿，适用于动态场景。</li></ul></li></ul><h2 id="后处理" tabindex="-1">后处理 <a class="header-anchor" href="#后处理" aria-label="Permalink to &quot;后处理&quot;">​</a></h2><ul><li>后处理： <ul><li>景深：模拟相机焦距效果。</li><li>运动模糊：增强动态感。</li><li>色调映射：调整亮度和对比度，模拟 HDR。</li></ul></li></ul><p>后处理增强：景深、SSAO、TAA 弥补光栅化局限。</p>',26)])])}const m=i(t,[["render",n]]);export{p as __pageData,m as default};
