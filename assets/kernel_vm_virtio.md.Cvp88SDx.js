import{_ as i,c as a,o as e,ae as r}from"./chunks/framework.Dgg8-8ov.js";const c=JSON.parse('{"title":"Virtio","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/vm/virtio.md","filePath":"kernel/vm/virtio.md"}'),o={name:"kernel/vm/virtio.md"};function t(u,l,p,n,h,d){return e(),a("div",null,l[0]||(l[0]=[r('<h1 id="virtio" tabindex="-1">Virtio <a class="header-anchor" href="#virtio" aria-label="Permalink to &quot;Virtio&quot;">​</a></h1><p>Virtio 是一套实现虚拟化设备的通用协议，它是 hypervisor 和操作系统驱动之间沟通的桥梁。只要遵循 virtio 协议进行设备模拟，就能坐享海量生态资源，实现虚拟设备自由。</p><h2 id="架构概述" tabindex="-1">架构概述 <a class="header-anchor" href="#架构概述" aria-label="Permalink to &quot;架构概述&quot;">​</a></h2><p>Virtio 采用前后端分离的架构设计：</p><ul><li>前端（Frontend）：运行在 Guest OS 中的驱动程序</li><li>后端（Backend）：运行在 Hypervisor 中的设备模拟实现</li><li>通信机制：通过 virtqueue 实现前后端的数据交换</li></ul><h3 id="前后端分离" tabindex="-1">前后端分离 <a class="header-anchor" href="#前后端分离" aria-label="Permalink to &quot;前后端分离&quot;">​</a></h3><p>Virtio 设备的通信是侵入式的，它要求 Guest OS 支持和安装 virtio 设备的驱动。</p><blockquote><p>Linux 默认自带了 virtio 协议族的驱动，使用 virtio 模型可以复用大量的驱动代码；QEMU 支持了大量的 virtio 设备，使用 virtio 模型可以复用大量的设备虚拟化代码。</p></blockquote><h2 id="virtqueue-和-vring" tabindex="-1">Virtqueue 和 Vring <a class="header-anchor" href="#virtqueue-和-vring" aria-label="Permalink to &quot;Virtqueue 和 Vring&quot;">​</a></h2><p>Virtio 通过 virtqueue 数据结构进行前后端的交互，其核心机制是内部的 vring 数据结构。一个 virtqueue 对应一个 vring，一个 vring 是一个数组，被分成三个独立部分：</p><ol><li><p>Descriptor Table（描述符表）</p><ul><li>数据准备区</li><li>只能由前端写入交互信息</li><li>后端只读</li><li>包含数据缓冲区的地址和长度信息</li></ul></li><li><p>Available Ring（可用环）</p><ul><li>前端通知区</li><li>前端可写，后端只读</li><li>用于前端通知后端有新的请求待处理</li></ul></li><li><p>Used Ring（已用环）</p><ul><li>后端通知区</li><li>后端可写，前端只读</li><li>用于后端通知前端请求处理完成</li></ul></li></ol><h3 id="环形缓冲区机制" tabindex="-1">环形缓冲区机制 <a class="header-anchor" href="#环形缓冲区机制" aria-label="Permalink to &quot;环形缓冲区机制&quot;">​</a></h3><ol><li><p>索引管理</p><ul><li>Available Ring 和 Used Ring 各自有一个 idx（索引）</li><li>分别由前端和后端维护</li><li>这些索引像&quot;指针&quot;，标记环形缓冲区的写入位置</li><li>确保前后端不会覆盖彼此的数据</li></ul></li><li><p>环形设计</p><ul><li>Available Ring 和 Used Ring 采用环形设计</li><li>前后端可以在各自的环中独立推进</li><li>前端可以在 Available Ring 中填入新请求</li><li>后端在 Used Ring 中标记已完成的任务</li></ul></li><li><p>通知机制</p><ul><li>前端通过&quot;kick&quot;（通知后端）触发处理</li><li>后端通过中断（通知前端）反馈结果</li><li>这种异步通知避免了忙等待</li><li>提升并发效率</li></ul></li></ol><h2 id="多队列支持" tabindex="-1">多队列支持 <a class="header-anchor" href="#多队列支持" aria-label="Permalink to &quot;多队列支持&quot;">​</a></h2><p>一个设备可以创建多个队列，每个队列彼此独立，由前后端在通信时并行使用，从而提高设备的吞吐效率。</p><h3 id="队列类型" tabindex="-1">队列类型 <a class="header-anchor" href="#队列类型" aria-label="Permalink to &quot;队列类型&quot;">​</a></h3><ol><li><p>单队列</p><ul><li>简单的设备采用单队列即可完成基本需求</li><li>一个 virtqueue 是半双工的</li></ul></li><li><p>双队列</p><ul><li>为了提高数据传输效率</li><li>一个作为 tx_queue（发送队列）</li><li>一个作为 rx_queue（接收队列）</li><li>实现双向的全双工数据传输</li></ul></li><li><p>多队列</p><ul><li>采用负载均衡的分发策略</li><li>提高设备和驱动之间的吞吐能力</li><li>特别适合高性能网络设备</li></ul></li></ol><blockquote><p>注意：对于网络设备，传输速度取决于整条链路上的瓶颈点，单一一处的吞吐量大不能保证网速的提升。</p></blockquote><h2 id="设备初始化流程" tabindex="-1">设备初始化流程 <a class="header-anchor" href="#设备初始化流程" aria-label="Permalink to &quot;设备初始化流程&quot;">​</a></h2><ol><li><p>设备发现</p><ul><li>Guest OS 通过 PCI 或 MMIO 发现 virtio 设备</li><li>读取设备配置空间获取设备信息</li></ul></li><li><p>设备配置</p><ul><li>协商特性（Feature bits）</li><li>设置设备参数</li><li>分配 virtqueue</li></ul></li><li><p>驱动加载</p><ul><li>加载对应的 virtio 驱动</li><li>初始化驱动数据结构</li><li>建立与设备的通信通道</li></ul></li><li><p>设备就绪</p><ul><li>完成所有初始化步骤</li><li>设备进入工作状态</li><li>可以开始处理 I/O 请求</li></ul></li></ol><h2 id="前后端通信流程" tabindex="-1">前后端通信流程 <a class="header-anchor" href="#前后端通信流程" aria-label="Permalink to &quot;前后端通信流程&quot;">​</a></h2><ol><li><p>数据发送流程</p><ul><li>前端准备数据缓冲区</li><li>将缓冲区信息写入 Descriptor Table</li><li>更新 Available Ring 的索引</li><li>发送 kick 通知后端</li></ul></li><li><p>数据接收流程</p><ul><li>后端处理请求</li><li>将结果写入 Used Ring</li><li>发送中断通知前端</li><li>前端处理完成通知</li></ul></li></ol><h2 id="数据面和控制面" tabindex="-1">数据面和控制面 <a class="header-anchor" href="#数据面和控制面" aria-label="Permalink to &quot;数据面和控制面&quot;">​</a></h2><h3 id="数据面" tabindex="-1">数据面 <a class="header-anchor" href="#数据面" aria-label="Permalink to &quot;数据面&quot;">​</a></h3><ol><li><p>数据传输</p><ul><li>通过 virtqueue 进行批量数据传输</li><li>支持零拷贝技术</li><li>高效的内存映射机制</li></ul></li><li><p>性能优化</p><ul><li>批量处理请求</li><li>异步通知机制</li><li>多队列并行处理</li></ul></li></ol><h3 id="控制面" tabindex="-1">控制面 <a class="header-anchor" href="#控制面" aria-label="Permalink to &quot;控制面&quot;">​</a></h3><ol><li><p>设备管理</p><ul><li>设备状态监控</li><li>配置更新</li><li>错误处理</li></ul></li><li><p>特性协商</p><ul><li>前后端特性协商</li><li>协议版本管理</li><li>扩展功能支持</li></ul></li></ol><h2 id="virtio-设备类型" tabindex="-1">Virtio 设备类型 <a class="header-anchor" href="#virtio-设备类型" aria-label="Permalink to &quot;Virtio 设备类型&quot;">​</a></h2><ol><li><p>网络设备（virtio-net）</p><ul><li>虚拟网卡</li><li>支持多队列</li><li>支持 TSO/GSO</li></ul></li><li><p>块设备（virtio-blk）</p><ul><li>虚拟磁盘</li><li>支持多队列</li><li>支持 DISCARD/WRITE_ZEROES</li></ul></li><li><p>控制台设备（virtio-console）</p><ul><li>虚拟串口</li><li>支持多端口</li><li>支持流控制</li></ul></li><li><p>输入设备（virtio-input）</p><ul><li>虚拟键盘/鼠标</li><li>支持事件上报</li><li>支持多点触控</li></ul></li><li><p>GPU 设备（virtio-gpu）</p><ul><li>虚拟显卡</li><li>支持 2D/3D 加速</li><li>支持显示输出</li></ul></li></ol><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><ol><li><p>批处理</p><ul><li>合并多个 I/O 请求</li><li>减少前后端交互次数</li><li>提高吞吐量</li></ul></li><li><p>零拷贝</p><ul><li>避免数据在内存中的复制</li><li>直接使用共享内存</li><li>降低 CPU 开销</li></ul></li><li><p>中断合并</p><ul><li>合并多个中断为一个</li><li>减少中断处理开销</li><li>提高系统响应性</li></ul></li><li><p>轮询模式</p><ul><li>在特定场景下使用轮询</li><li>减少中断开销</li><li>提高低延迟场景性能</li></ul></li></ol><h2 id="安全考虑" tabindex="-1">安全考虑 <a class="header-anchor" href="#安全考虑" aria-label="Permalink to &quot;安全考虑&quot;">​</a></h2><ol><li><p>内存隔离</p><ul><li>前后端内存空间隔离</li><li>防止越界访问</li><li>保护敏感数据</li></ul></li><li><p>权限控制</p><ul><li>设备访问权限管理</li><li>资源配额限制</li><li>防止资源耗尽</li></ul></li><li><p>数据加密</p><ul><li>敏感数据传输加密</li><li>密钥管理</li><li>安全协议支持</li></ul></li></ol>',33)]))}const q=i(o,[["render",t]]);export{c as __pageData,q as default};
