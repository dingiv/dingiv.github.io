import{_ as e,c as s,o as n,ae as t}from"./chunks/framework.CBTkueSR.js";const u=JSON.parse('{"title":"CPU 拓扑","description":"","frontmatter":{},"headers":[],"relativePath":"basic/hardware/topo.md","filePath":"basic/hardware/topo.md"}'),i={name:"basic/hardware/topo.md"};function p(r,a,l,o,c,h){return n(),s("div",null,[...a[0]||(a[0]=[t(`<h1 id="cpu-拓扑" tabindex="-1">CPU 拓扑 <a class="header-anchor" href="#cpu-拓扑" aria-label="Permalink to &quot;CPU 拓扑&quot;">​</a></h1><p>在同一个系统中，CPU 往往有多个层级的设计，以实现复杂的实际业务需求。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>board</span></span>
<span class="line"><span>   |- numa node</span></span>
<span class="line"><span>      |- socket</span></span>
<span class="line"><span>         |- die</span></span>
<span class="line"><span>            |- cluster</span></span>
<span class="line"><span>               |- core</span></span>
<span class="line"><span>                  |- thread</span></span></code></pre></div><p>在现代的计算机主板上，可以支持同时插多块芯片/处理器，其中每有一个插槽就能多插一块芯片，称之为 socket。而每一块芯片上有可能内部还会分为多个核心，称之为 core。一般地，普通的消费级 PC，只会有一块芯片，在同一个主板上安装多块芯片往往出现在企业级场景中。</p><p>在此基础上，又出现了多个层次。这些层次之间的主要区别在通信成本和资源共享的程度各不相同，从上到下，通信成本降低而资源共享变强。</p><h2 id="smp" tabindex="-1">SMP <a class="header-anchor" href="#smp" aria-label="Permalink to &quot;SMP&quot;">​</a></h2><p>SMP（Symmetric Multi-Processing，对称多处理器）是一种多处理器（socket 级别）系统架构，指系统中有多个等价的处理器（CPU），它们共享同一主内存和 I/O 资源，操作系统可以将任务调度到任意一个处理器上。早期的定义是在 socket 级别，但是，而来多核计算机的发展，这个层级已经下落到了 core 级别。</p><p>在 SMP 架构下，所有核心（core）地位对等，共享统一的内存地址空间和资源，操作系统统一负责调度和负载均衡，无需关心任务具体运行在哪个处理器上。其优点是能显著提升系统并行处理能力和吞吐量，资源利用率高，扩展性好，且主流操作系统（如 Linux、Windows、Unix）均有良好支持；但缺点在于多处理器间需维持缓存一致性，增加了硬件和协议的复杂性，并且在大规模扩展时容易受到内存带宽和总线瓶颈的限制。</p><h2 id="numa" tabindex="-1">NUMA <a class="header-anchor" href="#numa" aria-label="Permalink to &quot;NUMA&quot;">​</a></h2><p>NUMA（Non-Uniform Memory Access，非一致性内存访问）是一种多处理器系统的内存架构。在 NUMA 系统中，多个处理器（或处理器芯片）各自拥有本地内存，访问本地内存的速度远快于访问其他处理器的内存。这样设计的目的是提升多核/多路系统的可扩展性和整体性能。</p><p>NUMA 的原理是每个 CPU 或芯片拥有自己的本地内存，访问本地内存时延迟低、带宽高，而访问其他 CPU 的内存则需要跨芯片通信，导致延迟高、带宽低。这样的架构提升了多核系统的内存带宽和可扩展性，非常适合大规模服务器和高性能计算等场景。但与此同时，NUMA 也带来了新的挑战：操作系统和应用程序需要感知 NUMA 拓扑，合理分配任务和内存，避免频繁的远程访问带来的性能损失。NUMA 架构广泛应用于 x86 服务器、数据中心和 HPC 集群等领域。</p><h2 id="die" tabindex="-1">Die <a class="header-anchor" href="#die" aria-label="Permalink to &quot;Die&quot;">​</a></h2><p>Die（芯片裸片）指的是一块硅片上经过光刻、蚀刻等工艺形成的独立功能单元。在现代 CPU 设计中，一个 Die 通常包含多个核心（Core）、缓存（Cache）等模块。</p><p>为提升性能和良品率，现代高端处理器常常采用多 Die 封装（如 Chiplet 技术），即在一个封装内集成多个 Die，并通过高速互连实现协作。这种设计便于扩展核心数量、提升产能、降低制造成本，已广泛应用于如 AMD 的 Ryzen/Epyc 处理器以及部分高端 GPU 等产品中。</p><p>Die 层级的提升和多 Die 封装技术，为 SMP（对称多处理器）系统提供了更高的扩展性。在现代服务器中，SMP 架构下的每个处理器封装可能包含多个 Die，每个 Die 又集成多个核心，极大提升了系统的并行处理能力和资源利用率</p><h2 id="cluster" tabindex="-1">Cluster <a class="header-anchor" href="#cluster" aria-label="Permalink to &quot;Cluster&quot;">​</a></h2><p>Cluster（核心簇）是指在一个 CPU Die 内部，将多个核心（Core）按照功能或性能分组，形成的逻辑或物理单元。</p><p>通常每个 Cluster 内的核心会共享二级缓存（L2）或更高级别的缓存，以及部分互连和调度单元等硬件资源，这样可以提升缓存和互连的利用率，支持异构多核设计，灵活应对不同计算需求，同时降低功耗、提升能效比。不过，Cluster 之间的通信延迟高于内部，操作系统和调度器需要感知 Cluster 拓扑，合理分配任务以发挥其优势。</p><h2 id="超线程" tabindex="-1">超线程 <a class="header-anchor" href="#超线程" aria-label="Permalink to &quot;超线程&quot;">​</a></h2><p>超线程（Hyper-Threading，HT）是 Intel 提出的同时多线程（SMT, Simultaneous Multi-Threading）技术。它允许一个物理核心在同一时刻处理多个线程（通常为 2 个），通过共享大部分硬件资源（如执行单元、缓存），提升核心利用率和并发能力。</p><p>超线程的原理是让每个物理核心对外表现为多个逻辑核心，操作系统和应用程序可以将多个线程分配到同一个物理核心的不同逻辑核心上。在 I/O 密集或分支较多的场景下，这种设计能够有效提升系统的吞吐量和响应速度。不过，超线程并非在所有场景下都能带来明显收益，对于部分计算密集型任务提升有限，且可能引入如侧信道攻击等安全性隐患。目前，Intel 绝大多数桌面和服务器 CPU 都支持超线程技术，部分 AMD 处理器也实现了类似的同时多线程（SMT）功能。</p><h2 id="cpu-缓存" tabindex="-1">CPU 缓存 <a class="header-anchor" href="#cpu-缓存" aria-label="Permalink to &quot;CPU 缓存&quot;">​</a></h2><p>CPU 缓存（Cache）是位于处理器与主内存（RAM）之间的高速存储器，用于缓解 CPU 与内存之间的速度差异，减少内存访问延迟。</p><p>层级结构：现代 CPU 通常采用多级缓存结构，通常是 3 级。缓存通常采用 SRAM 存储器，由缓存控制器管理数据的读写和一致性。</p><ul><li>L1 缓存：每个核心独享，容量最小（一般为几十 KB），速度最快，分为指令缓存和数据缓存。</li><li>L2 缓存：每个核心独享或小范围共享，容量较大（几百 KB 到几 MB），速度略慢于 L1。</li><li>L3 缓存：多个核心共享，容量最大（几 MB 到几十 MB），速度慢于 L1/L2，但远快于主内存。</li></ul><p>缓存通过存储最近或频繁访问的数据和指令，极大提升了数据访问速度。CPU 首先访问 L1 缓存，若未命中则访问 L2，依次类推，最后才访问主内存。缓存命中率越高，CPU 性能越好。程序的局部性原理（时间局部性、空间局部性）对缓存友好性有重要影响。</p><p>但是，多核系统中，为保证各核心缓存数据一致，需采用缓存一致性协议（如 MESI）。缓存失效（Cache Miss）会导致访问更低层级缓存或主内存，影响性能。</p><h2 id="tlb-缓存" tabindex="-1">TLB 缓存 <a class="header-anchor" href="#tlb-缓存" aria-label="Permalink to &quot;TLB 缓存&quot;">​</a></h2><p>TLB（Translation Lookaside Buffer）快表，是一种专门缓存虚拟地址到物理地址映射的高速缓存，减少地址转换延迟。</p>`,29)])])}const P=e(i,[["render",p]]);export{u as __pageData,P as default};
