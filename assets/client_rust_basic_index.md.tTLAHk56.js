import{_ as t,c as i,o as s,ah as e}from"./chunks/framework.C5lh6Kkj.js";const c=JSON.parse('{"title":"语言基础","description":"","frontmatter":{"title":"语言基础","order":10},"headers":[],"relativePath":"client/rust/basic/index.md","filePath":"client/rust/basic/index.md"}'),n={name:"client/rust/basic/index.md"};function r(l,a,h,d,p,k){return s(),i("div",null,[...a[0]||(a[0]=[e(`<h1 id="语言基础" tabindex="-1">语言基础 <a class="header-anchor" href="#语言基础" aria-label="Permalink to “语言基础”">​</a></h1><h2 id="基本语法" tabindex="-1">基本语法 <a class="header-anchor" href="#基本语法" aria-label="Permalink to “基本语法”">​</a></h2><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to “数据类型”">​</a></h3><h3 id="操作符" tabindex="-1">操作符 <a class="header-anchor" href="#操作符" aria-label="Permalink to “操作符”">​</a></h3><p>操作符的本质是一些内置函数的语法糖，允许开发者使用简洁的符号调用一个全局可见的、常用的函数。</p><h3 id="流程控制" tabindex="-1">流程控制 <a class="header-anchor" href="#流程控制" aria-label="Permalink to “流程控制”">​</a></h3><h4 id="if-else" tabindex="-1">if-else <a class="header-anchor" href="#if-else" aria-label="Permalink to “if-else”">​</a></h4><h4 id="while-for-loop" tabindex="-1">while/for/loop <a class="header-anchor" href="#while-for-loop" aria-label="Permalink to “while/for/loop”">​</a></h4><h4 id="模式匹配-match" tabindex="-1">模式匹配 match <a class="header-anchor" href="#模式匹配-match" aria-label="Permalink to “模式匹配 match”">​</a></h4><p>模式匹配是一种高级的 if-else 语句和 switch 的语法糖，它支持匹配一个变量的类型、结构，并提取和解构一个变量，相较于 if-else 更加方便，同时简化了丑陋的 switch 语句。</p><h3 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to “函数”">​</a></h3><h3 id="面向数据-方法绑定" tabindex="-1">面向数据 + 方法绑定 <a class="header-anchor" href="#面向数据-方法绑定" aria-label="Permalink to “面向数据 + 方法绑定”">​</a></h3><p>面向对象是一个火爆的特性，常见的语言几乎都或多或少地支持。Rust 中采取的是函数式编程语言中的思路，提供一种使用面向数据和方法绑定的机制来实现面向对象的封装，但是不支持继承。这种将数据和行为分离的书写方式，相较于直接在类里面定义数据和方法的写法，更加强调数据面和管理面的分离，同时也易于扩展某个数据类型的行为，同时默认将面向对象中的<strong>组合</strong>概念进行深刻地贯彻。</p><blockquote><p>C 语言中不支持面向对象的特性，但是提供基础的面向数据和面向过程的能力，在 C 语言中，允许用户定义 struct 结构来封装一个复杂的纯数据，并且 C 的开发这会书写一系列以该结构体为第一个参数的函数，从而来模拟方法绑定的效果。</p><p>Go 语言中，也提供了类似 Rust 的面向数据 + 方法绑定的方式来管理一些复杂的数据类型</p></blockquote><h4 id="结构体" tabindex="-1">结构体 <a class="header-anchor" href="#结构体" aria-label="Permalink to “结构体”">​</a></h4><p>在 rust 中，使用 struct 关键字定义一个纯数据结构，同时可以使用 enum 关键字定义一类纯数据结构。struct 可以是字典结构体，也可以是一个元组结构体，</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDataStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> u32</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPointTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDataEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEnum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  TypeEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  TypeTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  TypeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> u32</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="impl-伴生结构体" tabindex="-1">impl 伴生结构体 <a class="header-anchor" href="#impl-伴生结构体" aria-label="Permalink to “impl 伴生结构体”">​</a></h4><h4 id="trait-特性-vs-interface-接口" tabindex="-1">trait（特性）vs interface（接口） <a class="header-anchor" href="#trait-特性-vs-interface-接口" aria-label="Permalink to “trait（特性）vs interface（接口）”">​</a></h4><p>在 Rust 中，提供一种名叫 trait 的机制来实现类似面向对象中的 interface 的功能，</p><h4 id="内置-trait" tabindex="-1"><a href="./trait">内置 trait</a> <a class="header-anchor" href="#内置-trait" aria-label="Permalink to “内置 trait”">​</a></h4><p>内置的 trait 作为语言的基础设施，广泛用于实现大家经常遇到的功能和需求，规定语言中的一些标准，甚至能够影响编译器的编译行为。</p><h3 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to “泛型”">​</a></h3><p>泛型是一个<strong>迫切求值</strong>类型函数，它可以通过泛型函数自动生成多种组合类型，其表现为一个数据类型的参数，通过 <code>Type&lt;T&gt;</code> 中的尖括号进行声明和调用。</p><blockquote><p>数据类型包括简单类型和复杂类型，如 i32、f64，复杂类型使用 struct、enum、union 进行定义；</p></blockquote><p>rust 具有强大的泛型系统，它支持类型修饰、泛型组合、关联类型等强大特性。</p><h4 id="类型修饰" tabindex="-1">类型修饰 <a class="header-anchor" href="#类型修饰" aria-label="Permalink to “类型修饰”">​</a></h4><p>在数据类型的基础上对类型进行额外修饰，这些修饰包括：</p><ul><li>可变引用修饰与不可变引用修饰，&amp;、&amp;mut</li><li>可变裸指针修饰和不可变裸指针修饰，*mut、*const</li><li>生命周期修饰，&#39;a、&#39;static</li><li>动态派发修饰，dyn trait_name</li></ul><h4 id="泛型组合-trait-bound" tabindex="-1">泛型组合 trait bound <a class="header-anchor" href="#泛型组合-trait-bound" aria-label="Permalink to “泛型组合 trait bound”">​</a></h4><h4 id="关联类型" tabindex="-1">关联类型 <a class="header-anchor" href="#关联类型" aria-label="Permalink to “关联类型”">​</a></h4><p>在 Haskell 等函数式的语言中，存在一种名叫<strong>高阶类型</strong>的特性，高阶类型对标的是高阶函数，普通的函数接受值然后输出值，高阶函数接受函数并且可以输出新函数，高阶类型接受高阶类型并可以输出新的高阶类型。</p><table tabindex="0"><thead><tr><th>值空间</th><th>类型空间</th></tr></thead><tbody><tr><td>值</td><td>类型</td></tr><tr><td>二等函数</td><td>泛型</td></tr><tr><td>一等函数+高阶函数</td><td>一等类型+高阶类型</td></tr><tr><td>闭包</td><td>?</td></tr></tbody></table><p>二等函数和一等函数区别在于，一等函数可以被看做数据一样被传递，二等函数不能，因为二等函数是<strong>迫切求值</strong>的，它必须以调用的形式出现，而不能被当作值来使用和传递；闭包意味着能够动态生成一个函数，并且引用局部作用域中的变量。泛型意味着可以使用泛型生成一个新的类型，但是泛型本身不能作为类型来传递，因为泛型是<strong>迫切求值</strong>的。</p><p>在 rust 中，没有选择实现高阶类型，但是选择实现了关联类型，来在一定程度上解决泛型迫切求值的问题。</p><h2 id="属性标记和宏" tabindex="-1">属性标记和宏 <a class="header-anchor" href="#属性标记和宏" aria-label="Permalink to “属性标记和宏”">​</a></h2><p>宏是生成代码的代码，特别是对于不能够进行动态解释的语言，为了简化编写代码的复杂性，使用宏可以加速我们的开发。</p><h2 id="所有权和借用机制" tabindex="-1">所有权和借用机制 <a class="header-anchor" href="#所有权和借用机制" aria-label="Permalink to “所有权和借用机制”">​</a></h2><h3 id="所有权" tabindex="-1">所有权 <a class="header-anchor" href="#所有权" aria-label="Permalink to “所有权”">​</a></h3><p>在 rust 中，所有权是指一个保存在内存中的<strong>数据</strong>，需要<em>有且仅有一个</em><strong>所有者</strong>。所谓所有者，本质就是一个<strong>指针</strong>，通常表现为一个<strong>变量名</strong>，或者是一个实例化对象的名字符号；</p><blockquote><ul><li>每个值都有且只有一个所有者，但是一个值的所有者可以改变，也就是移动语义；</li><li>当所有者离开作用域时，其拥有的值会被释放；</li><li>赋值操作具有默认的移动语义，即旧变量赋值给新变量时，旧变量不再拥有该值；</li></ul></blockquote><p>借用机制意味着，一个值可以被指针 A 所有，但却可以被 B 借用，其核心规则是任意时刻，一个值只能有一个可变指针指向该值，或者同时有多个不可变指针指向该值，两种情况选择其一；</p><blockquote><ul><li>一个可变指针</li><li>多个不可变指针</li></ul></blockquote><h3 id="移动和借用" tabindex="-1">移动和借用 <a class="header-anchor" href="#移动和借用" aria-label="Permalink to “移动和借用”">​</a></h3><p>移动，说明一个值的所有权发生了转移，原先的指针失效了，不能再通过原指针访问数据；借用，意味着新建了一个新的指针指向了该值，但是这个指针是一个<strong>引用</strong>，引用类型和原类型相差一个 <strong>&amp;</strong> 符号，他们都属于指针，不带 &amp; 是所有者，带 &amp; 是借用者。</p><h3 id="隐式-所有权-移动" tabindex="-1">隐式(所有权)移动 <a class="header-anchor" href="#隐式-所有权-移动" aria-label="Permalink to “隐式(所有权)移动”">​</a></h3><p>在 rust 中，除了赋值符号 <code>=</code>，当对<strong>函数传入参数</strong>的时候、还有<strong>函数结束并返回值</strong>的时候、还有<strong>声明闭包函数</strong>的时候，同样也会发生所有权的移动，除非将函数的参数或者返回值声明为一个 <code>&amp;</code> 符号的引用，这表明函数只是希望借用，本质上是一个指针。</p><h3 id="智能指针" tabindex="-1">智能指针 <a class="header-anchor" href="#智能指针" aria-label="Permalink to “智能指针”">​</a></h3><p>rust 中的默认指针，即引用，需要受到严格的借用检查的约束限制，在一些需要灵活的场景下无法满足业务需求，因此需要使用一些智能指针来管理内存，从而同时获得<strong>自由和安全</strong>，但是需要一定的<strong>开销</strong>。</p><table tabindex="0"><thead><tr><th>智能指针</th><th>特性</th><th>所有权共享</th><th>线程安全性</th><th>备注</th></tr></thead><tbody><tr><td>Box&lt;T&gt; Deref</td><td>堆分配</td><td>❌</td><td>❌</td><td>递归结构、大对象</td></tr><tr><td>Rc&lt;T&gt; Deref</td><td>共享所有权</td><td>✅</td><td>❌</td><td>单线程共享数据</td></tr><tr><td>Arc&lt;T&gt; Deref</td><td>共享所有权</td><td>✅</td><td>✅</td><td>多线程共享数据</td></tr><tr><td>Weak&lt;T&gt; Deref</td><td>防止循环引用</td><td>✅</td><td>❓</td><td>适用于树结构</td></tr><tr><td>Cell&lt;T&gt; ?Deref</td><td>轻量内部可变</td><td>❌</td><td>❌</td><td>适用于 Copy 类型</td></tr><tr><td>RefCell&lt;T&gt; ?Deref</td><td>内部可变性</td><td>❌</td><td>❌</td><td>运行时可变借用</td></tr><tr><td>Mutex&lt;T&gt;</td><td>内部可变性</td><td>❌</td><td>✅</td><td>运行时可变借用</td></tr><tr><td>RwLock&lt;T&gt;</td><td>内部可变性</td><td>❌</td><td>✅</td><td>运行时可变借用</td></tr><tr><td>Atomic&lt;T&gt;</td><td>原子操作</td><td>❌</td><td>✅</td><td>运行时可变借用</td></tr></tbody></table><h2 id="作用域和生命周期" tabindex="-1">作用域和生命周期 <a class="header-anchor" href="#作用域和生命周期" aria-label="Permalink to “作用域和生命周期”">​</a></h2><p>rust 中有块作用域、函数作用域和全局作用域，作用域会随着程序的执行而展开，同时随着程序的执行结束而关闭。一个变量往往在一个作用域中被声明，此时，我们称这个变量属于这个作用域，当这个作用域被关闭的时候，从属于该作用域的变量将会被清除，rust 将会自动调用这些变量的 drop 方法释放资源。</p><h3 id="生命周期泛型" tabindex="-1">生命周期泛型 <a class="header-anchor" href="#生命周期泛型" aria-label="Permalink to “生命周期泛型”">​</a></h3><p>生命周期是<strong>对一个引用类型的描述</strong>，它表现为一个类型的<strong>泛型</strong>，</p><h2 id="unsafe" tabindex="-1">unsafe <a class="header-anchor" href="#unsafe" aria-label="Permalink to “unsafe”">​</a></h2><p>unsafe 是 rust 特性子集，通过使用 unsafe 关键可以将一个函数或者 trait 中方法的标记为 unsafe，从而开启 unsafe 特性：</p><ul><li>解引用裸指针</li><li>解析 union 的字段</li></ul><h2 id="异步编程" tabindex="-1"><a href="/design/async/">异步编程</a> <a class="header-anchor" href="#异步编程" aria-label="Permalink to “异步编程”">​</a></h2><p>在 IO 密集型的程序中，程序的瓶颈出现在程序执行无法避免的 IO 等待，这将导致程序因为进行阻塞 IO 而被操作系统挂起，从而使得程序不能充分占用 CPU，出现了资源利用不充分的情况。</p><h2 id="模块系统和包管理" tabindex="-1"><a href="./mod">模块系统和包管理</a> <a class="header-anchor" href="#模块系统和包管理" aria-label="Permalink to “模块系统和包管理”">​</a></h2><p>rust 的模块系统有三个主要抽象，package, crate, mod。理解模块是建构大型应用和复用社区生态的前提。</p>`,61)])])}const g=t(n,[["render",r]]);export{c as __pageData,g as default};
