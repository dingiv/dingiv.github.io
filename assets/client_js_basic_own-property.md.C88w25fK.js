import{_ as i,c as a,o as e,ae as n}from"./chunks/framework.Dgg8-8ov.js";const t="/assets/own-p.BA_uTr85.png",y=JSON.parse('{"title":"属性的可枚举性和所有者","description":"","frontmatter":{},"headers":[],"relativePath":"client/js/basic/own-property.md","filePath":"client/js/basic/own-property.md"}'),l={name:"client/js/basic/own-property.md"};function p(r,s,h,o,k,d){return e(),a("div",null,s[0]||(s[0]=[n('<h1 id="属性的可枚举性和所有者" tabindex="-1">属性的可枚举性和所有者 <a class="header-anchor" href="#属性的可枚举性和所有者" aria-label="Permalink to &quot;属性的可枚举性和所有者&quot;">​</a></h1><p><img src="'+t+`" alt="alt text"></p><h2 id="自有属性——own-properties" tabindex="-1">自有属性——Own properties <a class="header-anchor" href="#自有属性——own-properties" aria-label="Permalink to &quot;自有属性——Own properties&quot;">​</a></h2><p>hasOwnProperty、Object.getOwnPropertyNames…… 凡是强调 <strong>Own</strong> 指的是在对象本身上定义的属性，而不是从原型链上继承而来的。</p><h3 id="展开操作符——浅拷贝语义" tabindex="-1">... 展开操作符——浅拷贝语义 <a class="header-anchor" href="#展开操作符——浅拷贝语义" aria-label="Permalink to &quot;... 展开操作符——浅拷贝语义&quot;">​</a></h3><p>该操作符的目的是浅拷贝。</p><p>它主要分成两个场景，一个是在方括号 <code>[]</code> 里面展开，一个是在花括号 <code>{}</code> 里面展开；前者遵从可迭代协议，使用对象的迭代器展开一个可迭代对象。但是，它还实现了一些扩展能力，它可以展开一个普通对象，其展开逻辑是可以认为是浅拷贝</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr2]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zs&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="key-类型——name、symbol、" tabindex="-1">key 类型——name、symbol、# <a class="header-anchor" href="#key-类型——name、symbol、" aria-label="Permalink to &quot;key 类型——name、symbol、#&quot;">​</a></h2><p>对象的 key 可以有三种属性，key 类型为字符串的属性，key 类型为 symbol 类型的，而完全私有的 <code>#</code> 开头的属性，只有谷歌浏览器的控制台能够访问，其他的方法访问不了 🐶</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertyNames</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertySymbols</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertyDescriptors</span></span></code></pre></div><h2 id="可枚举属性——enumerable" tabindex="-1">可枚举属性——Enumerable <a class="header-anchor" href="#可枚举属性——enumerable" aria-label="Permalink to &quot;可枚举属性——Enumerable&quot;">​</a></h2><p>可枚举属性是指那些内部“可枚举”标志设置为 true 的属性，而平常我们在使用一些内置方法的时候，会默认将对象设置一些初始值</p><ul><li>对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true；</li><li>对于通过 <code>Object.defineProperty</code> 等定义的属性，该标识值默认为 false；</li><li>对于原型链上的方法默认为 false，而访问器默认为 true；这是由于使用 class 语法定义的类，其原型链上的方法默认是不可枚举的，该行为是根据 ES 规范决定的；</li><li>Symbol 类型的 key 值的属性，默认为 false；</li></ul><h3 id="for-in-循环" tabindex="-1">for..in 循环 <a class="header-anchor" href="#for-in-循环" aria-label="Permalink to &quot;for..in 循环&quot;">​</a></h3><p>对象的可枚举属性且为 string key，可以通过 for...in 循环进行遍历，该遍历包括对象自身的和继承的可枚举属性。</p><h2 id="descriptor" tabindex="-1">Descriptor <a class="header-anchor" href="#descriptor" aria-label="Permalink to &quot;Descriptor&quot;">​</a></h2><p>用于描述一个对象的某个 key 值所代表的属性的配置对象。</p><ul><li>value。该值表示该 key 值的属性的值。</li><li>get。该函数使用一个空的参数列表，以便有权对值执行访问时，获取属性值。参见 getter。可能是 undefined。</li><li>set。使用包含分配值的参数调用的函数。每当尝试更改指定属性时执行。参见 setter。可能是 undefined。</li><li>enumerable。一个布尔值，表示是否可以通过 for...in 循环来枚举属性。另请参阅枚举性和属性所有权，以了解枚举属性如何与其他函数和语法交互。</li><li>configurable</li></ul><h2 id="对象的私有属性实现方法" tabindex="-1">对象的私有属性实现方法 <a class="header-anchor" href="#对象的私有属性实现方法" aria-label="Permalink to &quot;对象的私有属性实现方法&quot;">​</a></h2><ol><li>使用 <code>_</code> 开头的属性名，表示该属性是私有的，但是这种方式并不是真正的私有属性，只是约定俗成的，几乎没有限制，完全依赖于开发人员的意识，并且在使用 <code>for...in</code> 时，<code>_</code> 开头的属性也会被遍历出来，这种行为很可能是我们不希望的。因此，<strong>不推荐使用</strong>。</li><li>使用 <code>Symbol</code> 类型作为属性名，因为 <code>Symbol</code> 类型的属性名不会被 <code>for...in</code> 遍历出来，并且 <code>Object.getOwnPropertyNames</code> 也无法获取到 <code>Symbol</code> 类型的属性名，但是 <code>Object.getOwnPropertySymbols</code> 可以获取到 <code>Symbol</code> 类型的属性名。比较<strong>推荐使用</strong>。</li><li>使用 <code>WeakMap</code> 类型实现，将一个类和一个 <code>WeakMap</code> 实例关联起来，将类的实例作为 <code>WeakMap</code> 的 key，将类的私有属性作为 <code>WeakMap</code> 的 value，这样就可以实现类的私有属性，除了能够获得该 <code>WeakMap</code>，否则完全无法获取相应的属性，但是在实现上略微复杂，<strong>推荐使用</strong>。</li><li>使用 <code>#</code> 开头的属性名，这是 ES6 中新增的语法，表示该属性是私有的，并且该属性无法被 <code>for...in</code> 遍历出来，也无法被 <code>Object.getOwnPropertyNames</code> 获取到，但是 <code>Object.getOwnPropertyDescriptors</code> 可以获取到 <code>#</code> 开头的属性，但是即使 key 被获取到也无法在 class 外部访问。该种方式在和 Proxy、Reflect 一起使用时，非常容易发生错误，因此，<strong>不推荐使用</strong>。</li></ol>`,21)]))}const E=i(l,[["render",p]]);export{y as __pageData,E as default};
