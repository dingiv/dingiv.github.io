import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.Dgg8-8ov.js";const g=JSON.parse('{"title":"调度","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/process/schd.md","filePath":"kernel/linux/process/schd.md"}'),h={name:"kernel/linux/process/schd.md"};function p(t,s,k,e,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="调度" tabindex="-1">调度 <a class="header-anchor" href="#调度" aria-label="Permalink to &quot;调度&quot;">​</a></h1><p>调度系统是进程管理的核心组件，负责决定哪个进程在何时运行，以及运行多长时间。</p><p>调度的目标有</p><ul><li>高效性，调度算法高效快速，开销小</li><li>实时性，对于一些时间敏感的任务，需要能够在要求的时间内完成</li><li>公平性，不同的任务都能够获得调度，并且得到应有的执行时间</li></ul><p>在不同的使用场景下，调度的目标优先级会有所不同，但是主要矛盾是<strong>实时性</strong>和<strong>公平性</strong>之间的矛盾，因为重要的进程它需要特权和优先，但是公平要求的是每个进程都能够得到充分的执行。linux 中采用多级优先级处理器来缓解实时性和公平性之间的矛盾。</p><h2 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-label="Permalink to &quot;任务&quot;">​</a></h2><p>任务是调度的基本单位，本质上是进程或线程（在 Linux 内核中，线程和进程本质相同，都是 <code>task_struct</code>。线程在 linux 中本质上是共享同一组资源的进程，从内核层面上，线程和进程的并没有什么太大的不同。这一点和其他系统例如 Windows 有显著的不同。这是一种巧妙的实现思路，使得进程的系统调用 API 相较于 Windows 等系统显得非常的简洁，同时在性能角度考虑也更加的轻量。</p><h2 id="调度器" tabindex="-1">调度器 <a class="header-anchor" href="#调度器" aria-label="Permalink to &quot;调度器&quot;">​</a></h2><p>调度器是决定哪个任务获得 CPU 的组件。Linux 内核支持多种调度器，每种调度器针对不同的应用场景设计，使用不同的调度策略和算法。Linux 内核中的调度器按调度类（Scheduling Class）组织，主要包括：</p><ol><li>CFS 调度器：用于普通进程，追求公平性，基于虚拟运行时间，使用红黑树组织就绪队列</li><li>实时调度器：用于实时进程（SCHED_FIFO/SCHED_RR），基于优先级抢占，保证实时性要求</li><li>截止时间调度器：用于 SCHED_DEADLINE 策略，基于任务截止时间调度，适合硬实时应用</li><li>空闲调度器：当系统无其他可运行任务时使用，执行 CPU 空闲循环</li></ol><h3 id="cfs-调度器" tabindex="-1">CFS 调度器 <a class="header-anchor" href="#cfs-调度器" aria-label="Permalink to &quot;CFS 调度器&quot;">​</a></h3><p>CFS（完全公平调度器）是 Linux 默认的普通进程调度器，其核心思想是通过时间记账，让运行时间最少的任务先执行，从而让每个进程获得公平的 CPU 时间。</p><p>核心概念：</p><ul><li>虚拟运行时间（vruntime）：记录每个进程已经运行的虚拟运行时间</li><li>调度延迟（sched_latency）：所有可运行进程应该在一个调度延迟内至少运行一次</li><li>最小粒度（min_granularity）：进程的最小运行时间片</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_entity {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> load_weight load;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 进程权重</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rb_node run_node;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 红黑树节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 vruntime;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 虚拟运行时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 sum_exec_runtime;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 实际运行时间</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... 其他字段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>调度算法：</p><ol><li>选择虚拟运行时间 vruntime 最小的进程运行</li><li>进程运行时，其虚拟运行时间按权重递增</li><li>当进程的虚拟运行时间超过其他进程时，发生调度</li></ol><p>权重计算时使用 nice 来计算权重，用户态设置的进程优先级指标，范围从 -20（最高优先级）到 19（最低优先级），默认值为 0。nice 值通过影响进程的调度权重（weight），决定 CPU 时间分配比例。nice 值每降低 1，权重增加约 10%，高权重进程获得更多 CPU 时间。</p><h3 id="实时调度器" tabindex="-1">实时调度器 <a class="header-anchor" href="#实时调度器" aria-label="Permalink to &quot;实时调度器&quot;">​</a></h3><p>实时调度器用于满足实时性要求的进程，支持两种调度策略：</p><p>SCHED_FIFO（先进先出）：</p><ul><li>高优先级进程可以抢占低优先级进程</li><li>同优先级进程按 FIFO 顺序运行</li><li>进程会一直运行直到主动让出 CPU 或被更高优先级进程抢占</li></ul><p>SCHED_RR（轮转调度）：</p><ul><li>类似 SCHED_FIFO，但同优先级进程按时间片轮转</li><li>每个进程运行一个时间片后被放到队列末尾</li><li>时间片长度可配置</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_rq {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_prio_array active;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 活跃优先级数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_prio_array expired;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 过期优先级数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_nr_running;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 运行中的实时进程数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="截止时间调度器" tabindex="-1">截止时间调度器 <a class="header-anchor" href="#截止时间调度器" aria-label="Permalink to &quot;截止时间调度器&quot;">​</a></h3><p>截止时间调度器基于任务的截止时间进行调度，适合硬实时应用。</p><p>核心概念：</p><ul><li>运行时间（runtime）：任务需要的 CPU 时间</li><li>截止时间（deadline）：任务必须完成的时间点</li><li>周期（period）：任务的执行周期</li></ul><p>调度算法：</p><ol><li>选择截止时间最早的任务运行</li><li>任务运行时消耗其运行时间配额</li><li>当运行时间用完时，任务被挂起直到下一个周期</li></ol><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_dl_entity {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rb_node rb_node;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 红黑树节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 dl_runtime;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 运行时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 dl_deadline;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 截止时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 dl_period;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // 周期</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 dl_bw;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                      // 带宽</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="调度器选择" tabindex="-1">调度器选择 <a class="header-anchor" href="#调度器选择" aria-label="Permalink to &quot;调度器选择&quot;">​</a></h3><p>Linux 使用调度类（Scheduling Class）来组织不同的调度器，每个调度类都有不同的优先级：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调度类优先级（数字越小优先级越高）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_DEADLINE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 截止时间调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_RT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 实时调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_FAIR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // CFS调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_IDLE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 空闲调度器</span></span></code></pre></div><p>调度选择流程：</p><ol><li>从最高优先级的调度类开始检查</li><li>如果该调度类有可运行任务，选择该调度类的任务</li><li>否则检查下一个优先级的调度类</li><li>重复直到找到可运行任务</li></ol><h2 id="调度流程" tabindex="-1">调度流程 <a class="header-anchor" href="#调度流程" aria-label="Permalink to &quot;调度流程&quot;">​</a></h2><p>调度流程是调度器工作的核心机制，包括调度时机、调度决策、上下文切换等关键步骤。</p><h3 id="调度时机" tabindex="-1">调度时机 <a class="header-anchor" href="#调度时机" aria-label="Permalink to &quot;调度时机&quot;">​</a></h3><p>调度可能发生在以下时机：</p><ul><li>主动调度/进程主动让出 CPU <ul><li>进程调用 <code>sched_yield()</code> 主动让出 CPU</li><li>进程进入阻塞状态（等待 I/O、信号量、事件等）</li></ul></li></ul><ul><li>进程退出（正常、异常、信号终止）<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主动让出 CPU</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sched.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sched_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进程阻塞示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, O_RDONLY);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果文件没有数据可读，进程会阻塞</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ssize_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bytes_read </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fd, buffer, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer));</span></span></code></pre></div></li></ul><ul><li><p>被动调度/时钟中断触发</p><ul><li>时间片耗尽（CFS 中为虚拟运行时间超过阈值）</li><li>统计信息更新</li><li>调度检查</li></ul></li><li><p>抢占调度/优先级抢占</p><ul><li>高优先级进程变为可运行状态</li><li>实时进程抢占普通进程</li><li>内核抢占（如果启用，需要内核编译时启用 <code>CONFIG_PREEMPT</code>）</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置进程优先级</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sched.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_param param;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">param.sched_priority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 实时优先级</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sched_setscheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SCHED_FIFO, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><h3 id="调度决策过程" tabindex="-1">调度决策过程 <a class="header-anchor" href="#调度决策过程" aria-label="Permalink to &quot;调度决策过程&quot;">​</a></h3><p>总体先选调度器，然后让调度器选进程，然后分时间片大小。</p><ol><li><p>调度器选择<br> Linux 使用调度类优先级来选择调度器：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调度类优先级（数字越小优先级越高）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_DEADLINE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 截止时间调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_RT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 实时调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_FAIR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // CFS调度器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SCHED_CLASS_IDLE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 空闲调度器</span></span></code></pre></div><ol><li>从最高优先级的调度类开始检查</li><li>如果该调度类有可运行任务，选择该调度类的任务</li><li>否则检查下一个优先级的调度类</li><li>重复直到找到可运行任务</li></ol></li><li><p>进程选择<br> 进入不同的调度器之后，不同的调度器使用自身的策略来选择要运行的进程</p><ul><li>CFS 进程选择</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CFS 选择虚拟运行时间最小的进程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pick_next_task_fair</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_entity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">se;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rb_node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 从红黑树最左节点选择（vruntime 最小）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rb_first_cached</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rq-&gt;cfs.tasks_timeline);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   se </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rb_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(left, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_entity, run_node);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> task_of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(se);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>实时进程选择</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实时调度器选择最高优先级进程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pick_next_task_rt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rt_rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rq-&gt;rt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rt_prio_array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 从活跃数组中查找最高优先级进程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rt_rq-&gt;active;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array-&gt;queue[array-&gt;highest_prio];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>时间片分配<br> 不同的调度器使用各自的时间片分配规则。</p><p>CFS 时间片计算：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新当前进程的运行时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update_curr_fair</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_entity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rq-&gt;curr-&gt;se;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   u64 now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rq_clock_task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rq);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   u64 delta_exec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curr-&gt;exec_start;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新实际运行时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   curr-&gt;sum_exec_runtime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delta_exec;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新虚拟运行时间（考虑权重）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   curr-&gt;vruntime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calc_delta_fair</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(delta_exec, curr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   curr-&gt;exec_start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>上下文切换<br> 在选择好调度的参数的参数，正式开始进行调度的动作，主要包括<strong>保存当前进程状态</strong>和<strong>恢复目标进程状态</strong>。</p><ol><li>保存当前进程的执行状态，包括通用寄存器、浮点寄存器、程序计数器（PC）、栈指针（SP）以及页表基地址等关键信息到进程控制块 task_struct 中，确保下次调度时能够准确恢复进程的执行环境。</li><li>恢复目标进程的执行状态，将目标进程控制块中保存的寄存器状态加载到 CPU 中，切换页表以访问目标进程的内存空间，并恢复执行上下文，使目标进程能够从上次中断的地方继续执行。</li></ol><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简化的上下文切换伪代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> context_switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mm_struct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mm, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldmm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 切换内存管理上下文</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   mm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next-&gt;mm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   oldmm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev-&gt;active_mm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldmm) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       switch_mm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldmm, mm, next);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 切换寄存器上下文</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   switch_to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prev, next, prev);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上下文切换开销主要包括寄存器保存/恢复（~100-200个时钟周期）、页表切换（~1000-2000个时钟周期）、缓存失效和 TLB 失效，可通过延迟 TLB 失效、缓存亲和性优化和进程迁移限制等策略进行优化。</p></li></ol><h2 id="调度优化策略" tabindex="-1">调度优化策略 <a class="header-anchor" href="#调度优化策略" aria-label="Permalink to &quot;调度优化策略&quot;">​</a></h2><p>Linux 内核采用一些常见的优化手段来确保调度的优化。</p><h3 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h3><p>多核负载均衡通过进程迁移机制实现，当检测到某个 CPU 负载过重时，调度器会将进程从负载重的 CPU 迁移到负载较轻的 CPU 上。负载计算主要基于运行队列长度和进程权重进行，同时设置迁移阈值来避免频繁迁移造成的性能开销。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 负载均衡触发条件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> should_we_balance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lb_env </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_domain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> env-&gt;sd;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 检查负载差异是否超过阈值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> env-&gt;imbalance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sd-&gt;imbalance_pct;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>多核负载需要考虑 NUMA 架构的影响，通过 NUMA 感知，调度通过优先在本地 NUMA 节点进行进程调度，同时考虑内存访问延迟的影响，并尽量避免跨节点的进程迁移，从而减少内存访问开销并提高系统整体性能。</p><h3 id="缓存优化" tabindex="-1">缓存优化 <a class="header-anchor" href="#缓存优化" aria-label="Permalink to &quot;缓存优化&quot;">​</a></h3><p>缓存亲和性是指进程优先在之前运行的 CPU 上执行，通过减少缓存失效来提高内存访问效率的优化策略。</p><p>CPU 亲和性设置：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sched.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置进程的 CPU 亲和性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cpu_set_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpuset;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPU_ZERO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPU_SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 绑定到 CPU 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sched_setaffinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cpuset), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="实时性优化" tabindex="-1">实时性优化 <a class="header-anchor" href="#实时性优化" aria-label="Permalink to &quot;实时性优化&quot;">​</a></h3><p>实时进程配置：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置实时调度策略</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_param param;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">param.sched_priority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 最高实时优先级</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sched_setscheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SCHED_FIFO, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 CPU 隔离（避免其他进程干扰）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cpu_set_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpuset;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPU_ZERO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CPU_SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 绑定到隔离的 CPU</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sched_setaffinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cpuset), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cpuset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="调度问题诊断" tabindex="-1">调度问题诊断 <a class="header-anchor" href="#调度问题诊断" aria-label="Permalink to &quot;调度问题诊断&quot;">​</a></h2><p>在高度性能敏感的开发中，需要调优系统调度器，从而优化调度性能。</p><h3 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h3><ol><li>进程饥饿是指低优先级进程长时间无法获得 CPU 执行时间的问题。<br> 当系统中存在大量高优先级进程时，低优先级进程可能会被无限期延迟，导致其任务无法及时完成。为了解决这个问题，调度器通常会采用动态优先级调整机制，随着等待时间的增加逐步提升进程优先级，或者通过时间片补偿的方式确保所有进程都能获得基本的执行机会。</li><li>优先级反转是另一个常见的调度问题，发生在低优先级进程持有高优先级进程所需资源的情况下。<br> 当高优先级进程等待低优先级进程释放资源时，中等优先级的进程可能会抢占 CPU，导致高优先级进程被进一步延迟。为了解决这个问题，系统通常采用优先级继承机制，让持有资源的低优先级进程临时继承等待进程的优先级，或者使用优先级天花板技术，预先设置资源访问的最高优先级。</li><li>调度延迟过高是指进程从就绪状态到实际开始运行的时间间隔过长，这通常是由于系统负载过高或调度器配置不当导致的。<br> 当系统中运行进程过多时，调度器需要更多时间来做出调度决策，同时频繁的上下文切换也会增加调度开销。为了诊断和解决这个问题，系统管理员需要监控调度延迟指标，优化调度器参数配置，并在必要时进行负载均衡或资源扩容。</li></ol><h3 id="调度统计与监控" tabindex="-1">调度统计与监控 <a class="header-anchor" href="#调度统计与监控" aria-label="Permalink to &quot;调度统计与监控&quot;">​</a></h3><p>内核在调度过程中会执行调度数据统计，开发者可以通过系统接口访问调度数据。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_statistics {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 wait_start;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 等待开始时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 wait_max;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 最大等待时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 wait_count;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 等待次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 wait_sum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 等待时间总和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 iowait_count;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // IO 等待次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 iowait_sum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // IO 等待时间总和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 sleep_start;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 睡眠开始时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 sleep_max;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 最大睡眠时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 sum_sleep_runtime;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 睡眠时间总和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 block_start;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 阻塞开始时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 block_max;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 最大阻塞时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 exec_max;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 最大执行时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 slice_max;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 最大时间片</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    u64 nr_migrations_cold;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 冷迁移次数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="诊断工具" tabindex="-1">诊断工具 <a class="header-anchor" href="#诊断工具" aria-label="Permalink to &quot;诊断工具&quot;">​</a></h3><p>内核态监控接口：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取进程调度统计</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_statistics </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stats </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">task</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">se.statistics;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取运行队列统计</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cpu_rq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cpu);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u64 nr_running </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nr_running;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u64 load </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load.weight;</span></span></code></pre></div><p>用户态监控数据接口：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看进程调度信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/[pid]/schedstat</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看调度器统计</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/schedstat</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/schedstat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;cpu&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看 CPU 调度信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sched_debug</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 监控调度延迟</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sched_debug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;avg_delay&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 ftrace 跟踪调度事件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> function_graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/kernel/debug/tracing/current_tracer</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sched</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/kernel/debug/tracing/trace_options</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 perf 分析调度性能</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sched:sched_switch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [pid]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> report</span></span></code></pre></div>`,72)]))}const c=i(h,[["render",p]]);export{g as __pageData,c as default};
