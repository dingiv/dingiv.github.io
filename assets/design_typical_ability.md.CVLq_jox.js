import{_ as i,o as s,c as a,ah as h}from"./chunks/framework.D8J2w7BQ.js";const o=JSON.parse('{"title":"质量属性","description":"","frontmatter":{"title":"质量属性","order":0},"headers":[],"relativePath":"design/typical/ability.md","filePath":"design/typical/ability.md"}'),d={name:"design/typical/ability.md"};function n(e,t,l,r,k,p){return s(),a("div",null,[...t[0]||(t[0]=[h(`<h1 id="软件设计质量属性" tabindex="-1">软件设计质量属性 <a class="header-anchor" href="#软件设计质量属性" aria-label="Permalink to “软件设计质量属性”">​</a></h1><p>软件工程的本质是管理复杂性。随着数字系统规模的指数级增长，开发者面临的最大挑战不再是单纯的逻辑实现，而是如何确保代码在不断变化的需求中保持可维护性、可扩展性和可读性。</p><p>软件设计质量属性（Software Quality Attributes，又称 -ilities）并非教条式的规则，而是经过数十年工业实践总结出的启发式方法论。它们为架构决策提供科学导航，帮助开发团队规避隐性技术债务，防止代码腐化，并提升软件系统的整体生命周期价值。</p><p>在一个成功的软件系统中，维护成本往往占据总成本的 80% 以上。设计原则通过鼓励代码重用、促进模块间的松耦合以及增强代码的透明度，直接降低了后续维护和功能扩展的成本。</p><h2 id="核心质量属性体系" tabindex="-1">核心质量属性体系 <a class="header-anchor" href="#核心质量属性体系" aria-label="Permalink to “核心质量属性体系”">​</a></h2><h3 id="核心质量属性" tabindex="-1">核心质量属性 <a class="header-anchor" href="#核心质量属性" aria-label="Permalink to “核心质量属性”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可靠性</td><td>系统在规定条件下和时间内执行预期功能的能力</td><td>MTBF、错误率、SLA达标率</td></tr><tr><td>可观测性</td><td>通过外部输出推断系统内部状态的能力</td><td>结构化日志、分布式链路追踪、指标监控</td></tr><tr><td>可测试性</td><td>代码易于验证和测试的程度</td><td>单元测试覆盖率、依赖注入、接口抽象</td></tr><tr><td>可维护性</td><td>修复缺陷、添加功能的难易程度</td><td>圈复杂度、代码重复率、模块耦合度</td></tr><tr><td>健壮性</td><td>系统在异常输入或环境下持续运行的能力</td><td>输入校验、熔断降级、错误处理边界测试</td></tr></tbody></table><h3 id="性能相关" tabindex="-1">性能相关 <a class="header-anchor" href="#性能相关" aria-label="Permalink to “性能相关”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可伸缩性</td><td>系统处理负载增长的能力（用户/数据/流量）</td><td>QPS、吞吐量、水平/垂直扩展、分片</td></tr><tr><td>效率</td><td>资源利用率（CPU/内存/网络/存储）</td><td>利用率&lt;70%、GC暂停、尾延迟</td></tr><tr><td>响应性</td><td>端到端延迟（P50/P95/P99）</td><td>&lt;200ms UI、&lt;50ms API、异步处理</td></tr></tbody></table><h3 id="可用性与容错" tabindex="-1">可用性与容错 <a class="header-anchor" href="#可用性与容错" aria-label="Permalink to “可用性与容错”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可用性</td><td>系统正常运行时间比例</td><td>99.99%（&quot;four 9s&quot;）、MTBF/MTTR</td></tr><tr><td>容错性</td><td>故障时继续提供服务</td><td>熔断、重试、降级、混沌工程</td></tr><tr><td>恢复性</td><td>从故障/崩溃中恢复速度</td><td>RPO/RTO、快照回滚、蓝绿部署</td></tr></tbody></table><h3 id="演进与变更" tabindex="-1">演进与变更 <a class="header-anchor" href="#演进与变更" aria-label="Permalink to “演进与变更”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可扩展性</td><td>添加新功能而不改核心代码</td><td>插件系统、接口隔离、事件驱动</td></tr><tr><td>可修改性</td><td>修改现有功能成本低</td><td>模块化、SOLID、ADR记录</td></tr><tr><td>可移植性</td><td>跨环境/平台迁移容易</td><td>容器化、多云支持、标准协议</td></tr></tbody></table><h3 id="操作与部署" tabindex="-1">操作与部署 <a class="header-anchor" href="#操作与部署" aria-label="Permalink to “操作与部署”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>可部署性</td><td>快速、安全部署</td><td>CI/CD、GitOps、无缝升级</td></tr><tr><td>可配置性</td><td>通过配置调整行为</td><td>外部化配置、环境变量、Feature Flags</td></tr><tr><td>安全性</td><td>抵抗攻击、数据保护</td><td>零信任、加密、RBAC、OWASP Top10</td></tr></tbody></table><h3 id="用户与业务" tabindex="-1">用户与业务 <a class="header-anchor" href="#用户与业务" aria-label="Permalink to “用户与业务”">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>定义</th><th>关键指标/实践</th></tr></thead><tbody><tr><td>易用性</td><td>用户交互直观、学习曲线低</td><td>NPS、任务完成率、A/B测试</td></tr><tr><td>互操作性</td><td>与外部系统集成</td><td>API标准（gRPC/REST）、Schema演进</td></tr><tr><td>国际化</td><td>支持多语言/区域</td><td>i18n、RTL、时区处理</td></tr></tbody></table><h2 id="按生命周期阶段划分" tabindex="-1">按生命周期阶段划分 <a class="header-anchor" href="#按生命周期阶段划分" aria-label="Permalink to “按生命周期阶段划分”">​</a></h2><p>质量属性也可以按照软件生命周期的不同阶段来划分，这种划分有助于理解不同阶段各方的关注点和责任。</p><table tabindex="0"><thead><tr><th>阶段</th><th>主要关注点</th><th>典型质量属性（-ilities）</th><th>谁最关心</th><th>典型度量方式 / 实践</th><th>如果前期阶段差，后续代价示例</th></tr></thead><tbody><tr><td><strong>开发阶段</strong></td><td>内部结构、可修改性、可理解性、可测试基础</td><td>可维护性、可修改性、可测试性、可重用性、可移植性、可扩展性、可读性、模块化、架构一致性</td><td>开发团队、架构师、后续维护者</td><td>代码审查、SonarQube静态分析、架构决策记录（ADR）、单元测试覆盖率、认知复杂度、耦合/内聚度</td><td>架构选错 → 测试难写、改一处动全局、运维频繁出故障</td></tr><tr><td><strong>测试阶段</strong></td><td>正确性、缺陷发现效率、验证覆盖度</td><td>可测试性、可靠性、正确性（功能符合度）、健壮性、可观测性（日志/trace易分析）</td><td>测试/QA团队、产品/业务</td><td>测试覆盖率（代码/分支/路径）、缺陷密度、缺陷泄漏率、自动化测试通过率、MTTR（缺陷修复时间）</td><td>开发阶段缺乏可测试设计 → 测试用例爆炸、mock困难、 flaky 测试多</td></tr><tr><td><strong>运维阶段</strong></td><td>运行稳定性、故障恢复、监控效率</td><td>可用性、可靠性、可观测性、可伸缩性、容错性、恢复性、安全性、性能效率、可部署性</td><td>运维/SRE、用户、业务方</td><td>SLO/SLI、错误预算、MTBF/MTTR、P99延迟、变更失败率、告警准确率、Chaos工程覆盖</td><td>开发阶段忽略可观测性 → 故障定位慢、根因难找、反复重启、用户体验差</td></tr></tbody></table><h3 id="为什么开发阶段影响最大" tabindex="-1">为什么开发阶段影响最大 <a class="header-anchor" href="#为什么开发阶段影响最大" aria-label="Permalink to “为什么开发阶段影响最大”">​</a></h3><p>缺陷在开发阶段修复成本最低，越往后（测试→上线→生产）成本呈指数增长（业界常见估算：1:10:100甚至更高）。</p><p>架构是否分层清晰、是否遵守 SOLID/DDD/整洁架构，直接决定可测试性和可维护性。如果开发阶段就把副作用到处散布、状态到处共享，后续测试几乎不可能写出确定性强的用例，运维也无法快速定位。</p><p>可观测性、可测试性等运维阶段关心的属性，必须在开发阶段就设计好。开发阶段的坏决策会让每一次需求变更都变成大手术，测试和运维只能被动救火。</p><h2 id="权衡框架" tabindex="-1">权衡框架 <a class="header-anchor" href="#权衡框架" aria-label="Permalink to “权衡框架”">​</a></h2><p>质量属性之间经常存在冲突，需要进行权衡。</p><h3 id="常见冲突" tabindex="-1">常见冲突 <a class="header-anchor" href="#常见冲突" aria-label="Permalink to “常见冲突”">​</a></h3><table tabindex="0"><thead><tr><th>高优先 → 低优先</th><th>冲突示例</th><th>缓解策略</th></tr></thead><tbody><tr><td>可用性</td><td>增加冗余 → 效率下降</td><td>自动缩放 + 监控</td></tr><tr><td>可伸缩性</td><td>分库分表 → 可维护性变差</td><td>CDC + 物化视图</td></tr><tr><td>安全性</td><td>加密/校验 → 性能下降</td><td>硬件加速 + 零拷贝</td></tr><tr><td>可测试性</td><td>依赖注入 → 部署复杂</td><td>容器 mock + 契约测试</td></tr></tbody></table><h3 id="iso-iec-25010-标准" tabindex="-1">ISO/IEC 25010 标准 <a class="header-anchor" href="#iso-iec-25010-标准" aria-label="Permalink to “ISO/IEC 25010 标准”">​</a></h3><p>ISO 25010 将质量属性分为<strong>产品质量</strong>（功能性、性能、兼容性、安全性等）和<strong>使用质量</strong>（可用性、效率等）。这为系统性地评估和权衡质量属性提供了标准框架。</p><h2 id="现代实践" tabindex="-1">现代实践 <a class="header-anchor" href="#现代实践" aria-label="Permalink to “现代实践”">​</a></h2><h3 id="云原生视角" tabindex="-1">云原生视角 <a class="header-anchor" href="#云原生视角" aria-label="Permalink to “云原生视角”">​</a></h3><p><strong>12因子App</strong> 扩展了这些质量属性的要求：配置外部化、快速启动、无状态设计、日志流式处理。</p><p><strong>架构决策记录（ADR）</strong>：每个设计都应记录权衡理由，例如&quot;选择 Kafka 提升可用性，但接受更高的延迟&quot;。</p><p><strong>度量工具</strong>：</p><table tabindex="0"><thead><tr><th>属性群</th><th>工具示例</th></tr></thead><tbody><tr><td>性能/可用</td><td>Prometheus + Grafana</td></tr><tr><td>可观测</td><td>OpenTelemetry（traces/metrics/logs）</td></tr><tr><td>测试/维护</td><td>SonarQube、Mutation Testing</td></tr><tr><td>安全</td><td>Trivy、Falco</td></tr></tbody></table><h3 id="shift-left-策略" tabindex="-1">Shift-left 策略 <a class="header-anchor" href="#shift-left-策略" aria-label="Permalink to “Shift-left 策略”">​</a></h3><p>把质量前移到开发阶段：</p><ul><li>开发阶段就要写单元测试、契约测试、架构健身函数</li><li>可观测性优先设计：OpenTelemetry、结构化日志、trace 从开发阶段就内置</li><li>架构决策显式化：用 ADR 记录每个重要权衡</li><li>内建质量：CI 包含 lint、静态分析、架构违规检查、测试覆盖门限</li></ul><h2 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to “代码示例”">​</a></h2><p>以下 C 代码示例体现了多属性设计思想：</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块化设计：可维护+可测试（接口隔离），容错（错误码）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">init)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfg);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 可配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">process)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 纯函数倾向，易测试</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cleanup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ModuleOps;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reliable_module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ModuleOps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ops</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cfg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ops </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ops-&gt;init) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EINVAL;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 健壮性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cfg);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ret) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                     // 恢复性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 核心逻辑：不可变输入，日志副作用隔离</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cfg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ops-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 一致错误处理，可观测</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个设计覆盖了 SRP（单一接口）、DIP（ops 抽象）、Fault Tolerance（检查+回滚）等多个原则。</p>`,43)])])}const g=i(d,[["render",n]]);export{o as __pageData,g as default};
