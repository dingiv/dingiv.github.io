import{_ as s,c as a,o as t,ae as l}from"./chunks/framework.CBTkueSR.js";const E=JSON.parse('{"title":"IO","description":"","frontmatter":{},"headers":[],"relativePath":"design/fp/io.md","filePath":"design/fp/io.md"}'),n={name:"design/fp/io.md"};function e(h,i,p,k,r,d){return t(),a("div",null,[...i[0]||(i[0]=[l(`<h1 id="io" tabindex="-1">IO <a class="header-anchor" href="#io" aria-label="Permalink to &quot;IO&quot;">​</a></h1><p>冯诺依曼机器的工作模式，是 CPU 和 内存作为数据计算的核心，IO 设备是数据输入输出的外围设备。其基本工作模式是：</p><ol><li>从 IO 设备中的输入通道读取数据到内存</li><li>CPU 处理内存中的数据</li><li>将处理后的数据写到 IO 设备中的输出通道</li></ol><p>这些工作由操作系统来控制协调，但上层的应用程序也是基于类似的工作流程对数据进行处理，只不过上层的程序不会直接操作硬件，而是通过操作系统和应用程序标准库提供的程序接口进行操作。</p><p>根据 C 语言生态的程序特性，一个程序往往可以被抽象成一个 main 函数，main 函数接受两个参数，分别是 int 类型的 argc 和 <code>char**</code> 类型的 argv，并有一个 int 类型的返回值。main 函数的返回值表示程序执行的结果，argc 表示命令行参数的数量，argv 是一个字符串数组，表示命令行参数的值。这个输入输出的接口，是 C 语言程序的标准接口，也是操作系统和应用程序标准库提供的接口，被称为程序的标准输入输出接口。</p><p>一个程序除了标准输入和标准输出，往往需要处理其他的 IO 设备，和多个 IO 设备进行交互。操作系统和应用程序标准库需要提供一套接口，让上层程序可以方便地进行 IO 调用。</p><h2 id="io-接口" tabindex="-1">IO 接口 <a class="header-anchor" href="#io-接口" aria-label="Permalink to &quot;IO 接口&quot;">​</a></h2><p>一个程序有标准输入输出接口，还有其他 IO 接口。一个程序如果只是对于标准输入输出进行操作，那么这个程序一般就是一个控制台程序，但是现代的程序，往往是一个 GUI 程序或者 Web 服务器，需要和多个 IO 设备进行交互，比如磁盘、网卡、显示器、鼠标键盘等。程序的数据流，往往是从一个 IO 设备中持续读取数据，经过处理，再写入到另一个 IO 设备中。此时，程序的不止一个标准流，而是多条流。</p><p>典型的流有：</p><ul><li>标准 IO 流</li><li>UI 交互流 (键盘鼠标 -&gt; 显示器流)</li><li>socket 网络流</li><li>磁盘文件流</li></ul><blockquote><p>前端程序中的 IO 流</p><ul><li>键盘鼠标-&gt;显示器流</li><li>网络流</li><li>文件流</li></ul><p>其中，前端框架帮助我们处理了键盘鼠标-&gt;显示器流，极大地简化了前端管理页面的难度。</p></blockquote><h2 id="声明式-io" tabindex="-1">声明式 IO <a class="header-anchor" href="#声明式-io" aria-label="Permalink to &quot;声明式 IO&quot;">​</a></h2><p>声明式 IO，程序员无需进行具体的 IO 操作，只需要声明需要从外界获得一个怎样的数据，并且声明一定的描述信息，框架会自动处理 IO 操作，将数据返回给程序员。由于 IO 操作往往是命令式的，而其是异步的，进行这些操作是非常不纯的操作，在函数式编程中，我们需要采取特定的手段来处理这些不纯的操作。</p><h2 id="响应式编程和数据驱动-io" tabindex="-1">响应式编程和数据驱动 IO <a class="header-anchor" href="#响应式编程和数据驱动-io" aria-label="Permalink to &quot;响应式编程和数据驱动 IO&quot;">​</a></h2><p><strong>IO 就是 state，state 就是 IO</strong>。使用数据驱动 IO 就是将 IO 操作转化为一个 state 修改的操作，这样，在编码的角度上来看，我们就可以使用统一的编码模型去管理 IO 和 state。</p><p>具体地，将一个 IO 行为与一个状态关联起来，当状态改变时，IO 行为自动执行，是响应式编程的一个子集。本质上 IO 操作其实就是一个异步的外界数据和状态，我们需要将外界的数据获取到当前的程序内存中进行暂存，而在编程语言中，内存中的数据往往由该语言的数据类型和变量构成。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/users/&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上述的例子中，在内存中有一个变量 id，它映射成为一个 User 对象，只要 id 发生了变化，那么 User 对象也会重新获取。只要将 id 做成响应式对象，并让 getUser 订阅 id 的变化，然后自己执行，便可以拿到新的 User 值。</p><p>另外，对于一个数据驱动的 IO 系统，依然需要考虑普通的 IO 请求，它有什么需求和操作，例如：</p><ul><li>生命周期管理，数据不是全部一起加载进来的，也不是一直驻留在内存中，使用懒加载技术减少服务器的压力；</li><li>幂等性和可撤销，一个接口相同的调用得到相同的结果；一般地，GET 是幂等的，PUT 和 DELETE 大概率是，POST 不是；同样地，在内存中地操作中，get，set，delete 一个变量的值往往是幂等的，而 add 和 update 往往不是；</li><li>回滚和事务，当一次请求多个接口时，如果需要保证多个接口同时完成，或者同时失败；</li><li>故障重试；</li><li>缓存、限流、防抖；</li></ul>`,20)])])}const g=s(n,[["render",e]]);export{E as __pageData,g as default};
