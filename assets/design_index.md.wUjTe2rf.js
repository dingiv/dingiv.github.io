import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.Cthp9TdA.js";const t="/assets/structure.dio.CNp6WHyH.svg",E=JSON.parse('{"title":"软件设计","description":"","frontmatter":{"title":"软件设计","order":20},"headers":[],"relativePath":"design/index.md","filePath":"design/index.md"}'),e={name:"design/index.md"};function h(p,s,r,k,o,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="软件设计" tabindex="-1">软件设计 <a class="header-anchor" href="#软件设计" aria-label="Permalink to &quot;软件设计&quot;">​</a></h1><p>软件设计的基础意义是根据实际的业务需求编写软件进行实现。但是，在实际的环境中，事情往往没有想象中的那么简单，我们需要额外面临更多考验。</p><ul><li>可行性问题，这是最基本的要求，要求软件的实现能够切实解决需求；</li><li>成本问题，要求使用尽量低的时间成本、金钱成本；</li><li>可维护问题，软件需求持续服役，新增功能、修复 bug、回滚修改等；</li><li>质量问题，拥有较好的性能、健壮性、可用性、稳定性；</li></ul><h2 id="程序结构" tabindex="-1">程序结构 <a class="header-anchor" href="#程序结构" aria-label="Permalink to &quot;程序结构&quot;">​</a></h2><p>常见程序的结构可以分成两种：one-shot 和 deamon；one-shot 程序读取命令行参数后，一下子从前执行到尾，处理完数据后，直接退出程序；而 deamon 程序会在解析完命令行参数和配置文件后进入死循环，并通过阻塞式系统调用监听和等待它感兴趣的下层响应，并在响应发生时被操作系统唤醒，然后执行业务逻辑，除非触发关闭命令或者异常，否则将会按照期望一直运行下去。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// deamon 程序</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(argc, argv);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞式调用，监听客户端的请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 业务层寻找处理该请求的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, incoming);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 分发该请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> distribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, incoming, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 响应请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incoming, result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>前者，较为简单，略；后者是我们平时编写多数程序的结构，包括前端的 GUI 客户端程序和后端的 server 程序。</p><h3 id="deamon" tabindex="-1">deamon <a class="header-anchor" href="#deamon" aria-label="Permalink to &quot;deamon&quot;">​</a></h3><p>deamon 程序的结构可以被概括为一个“前中后”三层结构——前端视图层、中间业务层、后端持久层。视图层面向自己的客户端，监听客户端的请求和操作，解析和翻译操作，并将请求的任务分发给中间业务层；中间层负责进行主体复杂逻辑的实现和繁重工作的处理，它在处理业务的过程中可能需要依赖外界的持久化数据，或者将数据进行持久化，它会选择性地调用后端持久层，进行数据持久化的操作；后端持久层通过系统 IO 调用，向进程外发送和获取数据，或是作为数据的直接管理者，代替进程中的其他部分管理数据。</p><p><img src="`+t+'" alt=""></p><h3 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h3><p>进一步向更小的粒度分析，我们发现，一个程序往往由一个个<strong>子程序</strong>构成，或者直白点，在多数的编程语言中，它叫做<strong>函数</strong>。然而我们需要从更底层的 C 语言和汇编的角度去分析函数是什么？函数是进程的内存空间中的一段数据，它记录的是一段 CPU 可执行的机器指令序列，我们可以告知 CPU 这段内存中的数据是指令，并应当读取并执行它；同时，在执行之前，可以携带一定的指针，指向一些数据，并要求令这些数据作为函数执行时的一部分上下文，函数在执行期间，可以访问他们，最后函数应当将处理数据的结果，保留到一个指定的 Return 指针中进行返回，让函数的调用者能够通过调用函数进行自己想要的数据和结果。这个过程可以被抽象成一个管道，它从进口端接受一些数据，并使用这些数据进行计算，产生一个返回值，并从管道的出口端返回。</p><p>函数有如下几个重要特点：</p><ul><li><p>函数嵌套调用，函数内部可以调用另一个函数，从而形成嵌套，大大减少重复代码的书写；为了实现这个特性，大多数的编译器采用<strong>调用栈</strong>来实现；</p></li><li><p>系统调用，系统调用不是用户自己编写的，它存在于进程中，在进程创建的时候就被操作系统一同加载到了进程的内存空间，用户可以直接调用这些函数实现逻辑复用和受限资源的访问；这些函数区别于用户自行实现的函数，他们是系统层提供的 API 接口；</p><p>系统调用有一个特点那就是外界交互。程序期望和外界发生交互，或者说 IO 操作。IO 操作有一个非常大的特点就是，<strong>可能是失败的</strong>，它可能返回一个程序无法处理的结果或者没有结果，那么程序将会就此崩溃，或者是主动退出；</p></li><li><p>函数复用，函数的目的就是为了复用程序逻辑，避免重复书写相同的代码。</p></li></ul><h3 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h3><p>进程从操作系统那里申请一个块巨大的内存空间，它是一个简洁的字节数组，但是却也非常的简陋，我们需要对内存进行划分使用和管理，而不是随意使用，其中一个重要的手段便是<strong>作用域</strong>。作用域是为了<strong>划分和隔离</strong>子程序，拆解问题，提供资源的隔离。</p><h4 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h4><p>我们在一个内存区域中<strong>划分</strong>一小块进行使用，在区域存放了一些数据，然后再区域中进行了一些计算，然后释放和关闭了这个作用域，不同的作用域在不同的时期被展开和闭合，并且彼此之间的数据资源存在一定的隔离性。作用域需要程序设计时被<strong>声明</strong>，在运行时依照声明被<strong>展开</strong>；展开时，可以将状态传入一个域，在域展开的过程当中，状态可以被改变，在域使用完毕时，可以将<strong>闭合</strong>，释放资源，同时传出一些状态。此时，作用域完成了它的使命。</p><h4 id="父子作用域" tabindex="-1">父子作用域 <a class="header-anchor" href="#父子作用域" aria-label="Permalink to &quot;父子作用域&quot;">​</a></h4><p>我们划分并隔离不同的子程序，但是最后却又要让子程序之间发生交互和数据交换，发生父子嵌套和兄弟并列，这体现了<strong>封装和接口</strong>的思想。父作用域只需调用一个接口，便可以完成一个复杂动作，而无需关系其底层细节。从一定角度看，程序就是<strong>状态 + 作用域</strong>的管理。</p><p>作用域可以被分为，全局作用域和局部作用域。</p><ul><li>全局作用域中的内容被整个程序可见，并且早于所有局部作用域被展开，晚于所有局部作用域被闭合。全局作用域只有一个。全局作用域是所有作用域的父代。</li><li><strong>函数调用产生一个局部作用域</strong>，</li></ul><p>在不同的语言中，提供了不同的作用域抽象，拥有更多的层级，包括<strong>模块作用域</strong>、<strong>类作用域</strong>、<strong>块作用域</strong>。但是不管如何，我们需要着重关注的是父作用域和子作用域之间的关系——<strong>父作用域依赖于子作用域</strong>。</p><ul><li>当一个作用域依赖于其他作用域的时候，它的功能就受到了别人的影响，为了让这个作用域正常工作，就需要保证它依赖的所有作用域正常工作；</li><li>作用域之间的接口应该保持稳定，当接口更变时，需求同时改变依赖者的逻辑；</li><li>作用域之间应该避免<strong>循环依赖</strong>，因为循环依赖往往是程序划分不正确的外在体现，或者从哲理的角度讲，循环依赖其实是在解决“蛋生鸡”的问题，但是这是没有办法解决的；</li></ul><h2 id="复杂软件" tabindex="-1">复杂软件 <a class="header-anchor" href="#复杂软件" aria-label="Permalink to &quot;复杂软件&quot;">​</a></h2><p>一些运行在用户态的软件承担着较为底层的基础工作，并且需要具有极高的运行性能，编写这些软件需要深刻理解领域内的专业知识和良好的工程设计，例如：</p><ul><li>模拟器，用于模拟和虚拟化硬件平台，从而在一个操作系统上运行另一个独立的操作系统。QEMU、VirtualBox、VMWare...</li><li>编译器/运行时，用于将一个语言的源码文件编译成另一种语言并可以在不同的平台上进行执行，GCC、MSVC、汇编器、V8、JVM...</li><li>浏览器，用于实现 Web 标准和渲染 Web 程序，Chrome、FireFox、Safari...</li><li>数据库，用于高效管理磁盘数据，并对外提供数据服务，包括数据查询和修改等，MySQL、Redis...</li><li>游戏引擎，用于提供复杂的游戏渲染和一站式开发能力，Unity、Unreal、Godot...</li><li>AI 基架，用于训练和驱动 AI 模型，Pytorh...</li></ul>',27)]))}const c=i(e,[["render",h]]);export{E as __pageData,c as default};
