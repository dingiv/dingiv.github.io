import{_ as e,c as l,o as t,ae as a}from"./chunks/framework.CBTkueSR.js";const n="/assets/z-index.CSRIOjeU.png",h=JSON.parse('{"title":"层叠上下文与 z-index","description":"","frontmatter":{},"headers":[],"relativePath":"client/web/css/trick/z-index.md","filePath":"client/web/css/trick/z-index.md"}'),o={name:"client/web/css/trick/z-index.md"};function r(s,i,d,c,p,x){return t(),l("div",null,[...i[0]||(i[0]=[a('<h1 id="层叠上下文与-z-index" tabindex="-1">层叠上下文与 z-index <a class="header-anchor" href="#层叠上下文与-z-index" aria-label="Permalink to &quot;层叠上下文与 z-index&quot;">​</a></h1><p>两个元素的图层决定着元素显示的上下关系，上层的元素将覆盖下层的元素进行显示。决定图层关系的 CSS 属性为 z-index，z-index 越大，元素的显示优先级越高。</p><h2 id="z-index-比较方法" tabindex="-1">z-index 比较方法 <a class="header-anchor" href="#z-index-比较方法" aria-label="Permalink to &quot;z-index 比较方法&quot;">​</a></h2><ul><li>首先先看要比较的两个元素是否处于同一个 SC 中，如果是，谁的层叠等级大，谁在上面；</li><li>如果两个元素不在同一 SC 中，先比较他们的父 SC，当两个元素层叠水平相同、层叠顺序相同时，在 DOM 结构中后面的元素层叠等级在前面元素之上；</li><li>如果一个元素拥有 CS 则在普通元素之上</li></ul><p>普通的元素层级如图示： <img src="'+n+'" alt="image"></p><h2 id="层叠上下文的产生" tabindex="-1">层叠上下文的产生 <a class="header-anchor" href="#层叠上下文的产生" aria-label="Permalink to &quot;层叠上下文的产生&quot;">​</a></h2><p>层叠上下文的创建有两种情况，一种是强制创建，一种是可选创建。</p><ul><li>强制创建： <ol><li>文档的根元素，如 html；</li><li>position 设置为 fix、sticky；</li><li>opacity &lt; 1；</li><li>mix-blend-mode 不为 normal；</li><li>isolation=isolate；</li><li>使用了 CSS3 的动画特性，例如：filter、transform、will-change、clip-path……</li></ol></li><li>可选创建：指定 z-index 不为 auto，那么可以进一步执行一下的操作，使其创建一个层叠上下文 <ol><li>position 设置为 relative、absolute；</li><li>flexbox 和 grid 的子元素；</li></ol><blockquote><p>ps：position 不为 none 的时候同时会创建一个<strong>偏移上下文</strong>。</p></blockquote></li></ul>',8)])])}const m=e(o,[["render",r]]);export{h as __pageData,m as default};
