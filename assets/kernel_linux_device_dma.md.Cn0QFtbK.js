import{_ as l,c as a,o as e,ae as s}from"./chunks/framework.CBTkueSR.js";const u=JSON.parse('{"title":"DMA","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/device/dma.md","filePath":"kernel/linux/device/dma.md"}'),t={name:"kernel/linux/device/dma.md"};function d(o,i,n,h,p,r){return e(),a("div",null,[...i[0]||(i[0]=[s('<h1 id="dma" tabindex="-1">DMA <a class="header-anchor" href="#dma" aria-label="Permalink to &quot;DMA&quot;">​</a></h1><p>DMA 技术是用于加速 IO 操作速度，卸载 CPU 工作负载的硬件级技术。通过该技术，访问 IO 设备时，无需 CPU 在内存和设备寄存器之间进行数据拷贝工作，而是由 DMA IO 设备的内置专用处理器负责设备数据的拷贝工作。</p><p>CPU 仅设置和结束传输，空闲时可执行其他任务，减轻了 CPU 的工作量，让 CPU 专注于更高级的逻辑处理，而不是简单的数据拷贝。</p><blockquote><p>可编程 IO，是相较于 DMA 技术的 IO 读写，即相对较老的技术，操作系统通过读写 IO 设备寄存器控制设备，目前市面上的设备已经广泛支持 DMA 技术，以提供 IO 访问速度；</p><ul><li>PMIO（Port-Mapped Input/Output）：通过访问 IO 端口控制设备</li><li>MMIO（Memory-Mapped Input/Output）：设备寄存器和缓冲区映射到物理内存中</li></ul></blockquote><h2 id="基本流程" tabindex="-1">基本流程 <a class="header-anchor" href="#基本流程" aria-label="Permalink to &quot;基本流程&quot;">​</a></h2><p>DMA 功能往往只需要驱动层关注即可，由驱动负责发起 DMA 硬件操作。</p><ul><li>CPU 通过驱动发起 IO 操作，配置 DMA 相关的控制器，从而指定传输参数（如源地址、目标地址、数据长度），立即返回；</li><li>设备直接通过总线并经由 IOMMU 的地址翻译访问内存，传输数据；</li><li>传输完成后，DMA 控制器通过中断通知 CPU；</li><li>CPU 收到通知，接管后续逻辑，到指定好的目标地址上获取拷贝完成的数据结果；</li></ul><h2 id="iommu" tabindex="-1">IOMMU <a class="header-anchor" href="#iommu" aria-label="Permalink to &quot;IOMMU&quot;">​</a></h2><p>CPU 是不能直接访问内存的，必须通过 MMU。IO 设备更不能直接访问内存，必须通过 IOMMU（IO 设备内存空间管理单元）。相较于 MMU 是 CPU 的一个硬件单元，IOMMU 可以视为一个独立的设备，需要安装驱动。</p><h3 id="核心功能" tabindex="-1">核心功能 <a class="header-anchor" href="#核心功能" aria-label="Permalink to &quot;核心功能&quot;">​</a></h3><ul><li>地址转换：将设备使用的虚拟地址（IOVA，I/O Virtual Address）映射到物理内存地址。允许设备通过 DMA 访问内存，无需了解物理内存布局。</li><li>设备隔离：为每个设备分配独立的地址空间，防止未经授权的内存访问。增强虚拟化场景的安全性（如虚拟机隔离）。</li><li>中断重映射：管理设备中断，确保中断信号正确路由到目标 CPU 或虚拟机。</li><li>性能优化：减少 DMA 传输的内存拷贝开销。支持大页面映射，降低地址转换开头的 TLB（Translation Lookaside Buffer）开销。</li></ul><h3 id="关键数据结构" tabindex="-1">关键数据结构 <a class="header-anchor" href="#关键数据结构" aria-label="Permalink to &quot;关键数据结构&quot;">​</a></h3><ol><li>struct iommu_domain： <ul><li>表示设备的地址空间，类似虚拟机的内存上下文。</li><li>字段： <ul><li><code>type</code>：域类型（如 <code>IOMMU_DOMAIN_DMA</code> 用于标准 DMA 映射）。</li><li><code>ops</code>：<code>struct iommu_ops</code>，定义 IOMMU 硬件操作（如地址映射）。</li></ul></li><li>作用：为设备分配独立的虚拟地址空间。</li></ul></li><li>struct iommu_group： <ul><li>表示一组共享 IOMMU 的设备（如 PCIe 设备的同一组）。</li><li>字段： <ul><li><code>devices</code>：关联的设备列表。</li><li><code>domain</code>：指向当前使用的 <code>iommu_domain</code>。</li></ul></li><li>作用：确保同一组设备共享相同的地址空间和隔离策略。</li></ul></li><li>struct iommu_ops： <ul><li>定义 IOMMU 硬件驱动的操作，如 <code>map</code>（映射 IOVA 到物理地址）、<code>unmap</code>（解除映射）。</li><li>由具体 IOMMU 硬件驱动实现（如 Intel VT-d、AMD-Vi）。</li></ul></li></ol><h3 id="工作流程-以-dma-读操作为例" tabindex="-1">工作流程（以 DMA 读操作为例） <a class="header-anchor" href="#工作流程-以-dma-读操作为例" aria-label="Permalink to &quot;工作流程（以 DMA 读操作为例）&quot;">​</a></h3><ol><li>设备驱动初始化： <ul><li>驱动（如同 NVMe 驱动 <code>drivers/nvme/host/core.c</code>）调用 <code>iommu_map</code> 或 <code>dma_map_single</code> 分配 IOVA。</li><li>源码示例（<code>include/linux/dma-mapping.h</code>）：<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dma_addr_t</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dma_map_single</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> device </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dma_data_direction </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li>内核通过 <code>struct device-&gt;dma_ops</code> 调用 IOMMU 驱动（如 <code>intel_iommu_map</code>）。</li></ul></li><li>IOMMU 配置： <ul><li>IOMMU 硬件驱动更新页表，将 IOVA 映射到物理地址。</li><li>页表存储在 IOMMU 硬件中，类似 CPU 的 MMU 页表。</li></ul></li><li>DMA 传输： <ul><li>设备（如磁盘）使用 IOVA 发起 DMA 传输，IOMMU 自动转换为物理地址。</li><li>数据直接写入页面缓存（<code>bio-&gt;bi_io_vec</code> 的页面）。</li></ul></li><li>中断与完成： <ul><li>传输完成后，设备触发中断，IOMMU 重映射中断信号到正确 CPU。</li><li>驱动调用 <code>bio_endio</code>，通知文件系统（如 ext4）。</li></ul></li><li>解除映射： <ul><li>驱动调用 <code>dma_unmap_single</code>，释放 IOVA，更新 IOMMU 页表。</li></ul></li></ol>',15)])])}const k=l(t,[["render",d]]);export{u as __pageData,k as default};
