import{_ as o,c as e,o as r,ae as t}from"./chunks/framework.BHrE6nLq.js";const h=JSON.parse('{"title":"Rust","description":"","frontmatter":{},"headers":[],"relativePath":"front/rust/index.md","filePath":"front/rust/index.md"}'),d={name:"front/rust/index.md"};function s(i,a,l,c,n,u){return r(),e("div",null,a[0]||(a[0]=[t('<h1 id="rust" tabindex="-1">Rust <a class="header-anchor" href="#rust" aria-label="Permalink to &quot;Rust&quot;">​</a></h1><p>Rust 是一门年轻而现代的系统级编程语言，它的目标是填补 C 语言和高级应用层编程语言之间的空白，类似于 C++，即在需要高性能的同时，也需要高级语言特性支持的领域。为了达成这一目标，Rust 基于前人的经验教训，抛弃了历史的包袱，并提供了一套独特、安全、统一且强大的编程工具。</p><ul><li>内存安全：Rust 关注解决 C 语言和 C++ 的内存安全问题，借鉴了 C++ 的 RAII（资源获取即初始化）特性，并引入了独特的生命周期和所有权机制，采用自动化、非垃圾回收的内存管理方法。在内存安全和内存管理的矛盾之间，Rust 取得了一个卓越的平衡。</li><li>无畏并发：Rust 利用其所有权和借用机制，在很大程度上避免了并发编程中的数据竞争和资源冲突，确保了并发操作的安全性。</li><li>高效 I/O：Rust 支持协程和异步编程，这些特性允许程序在执行时暂停并将控制权交给调用者，从而避免 I/O 操作引起的 CPU 阻塞，提高了 CPU 的利用率和程序的响应性。</li><li>性能卓越：Rust 遵循零成本抽象的理念，即你所不需要的特性无需支付任何性能代价，你所需要的功能，编译器提供的实现往往也难以被超越。</li><li>双重范式：Rust 融合了函数式编程和面向对象编程的核心思想，吸取了二者的优点：例如数据不可变、闭包、函子、组合优于继承、泛型等；并摒弃了那些容易引发问题的特性，如传统的继承、异常处理（如 try-catch）和空指针等。这为开发者提供了优雅且高效的抽象能力，同时避免了开发者误入语言陷阱。</li><li>面向工程：Rust 拥有现代化的包管理系统和构建工具链，使得代码复用和管理变得更加简单。开发者能够专注于业务逻辑的实现，而不必耗费精力在配置和环境管理上。</li></ul><h2 id="基本语法" tabindex="-1">基本语法 <a class="header-anchor" href="#基本语法" aria-label="Permalink to &quot;基本语法&quot;">​</a></h2><h3 id="操作符" tabindex="-1">操作符 <a class="header-anchor" href="#操作符" aria-label="Permalink to &quot;操作符&quot;">​</a></h3><p>操作符的本质是一些内置函数的语法糖，允许开发者使用简洁的符号调用一个全局可见的、常用的函数。</p><h2 id="所有权和借用机制" tabindex="-1">所有权和借用机制 <a class="header-anchor" href="#所有权和借用机制" aria-label="Permalink to &quot;所有权和借用机制&quot;">​</a></h2><p>所有权是指，在 rust 中，一个保存在内存中的数据，需要<strong>有且仅有一个所有者</strong>，所有者本质就是一个<strong>指针</strong>，通常变现为一个变量的名字符号，或者是一个实例化对象的名字符号；</p><ul><li>每个值都有且只有一个所有者</li><li>当所有者离开作用域时，值会被释放</li><li>赋值给新变量时，旧变量不再拥有该值（赋值运算符具有默认的移动语义）</li></ul><p>借用机制意味着，一个值可以被指针 A 所有，但却可以被 B 借用，其核心规则是任意时刻，一个值只能有一个可变指针指向该值，或者同时有多个不可变指针指向该值；</p><ul><li>一个可变指针</li><li>多个不可变指针</li></ul><h3 id="隐式-所有权-移动" tabindex="-1">隐式(所有权)移动 <a class="header-anchor" href="#隐式-所有权-移动" aria-label="Permalink to &quot;隐式(所有权)移动&quot;">​</a></h3><p>在 rust 中，除了赋值符号 <code>=</code>，当对<strong>函数传入参数</strong>的时候，还有<strong>函数结束并返回值</strong>的时候，同样也会发生所有权的移动，除非你将函数的参数或者返回值声明为一个 <code>&amp;</code> 符号的引用，这表明函数只是希望借用</p><h3 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h3><p>rust 中有块作用域、函数作用域和全局作用域，一个变量的生命周期和其所有者有关，</p><h2 id="模块和包管理" tabindex="-1">模块和包管理 <a class="header-anchor" href="#模块和包管理" aria-label="Permalink to &quot;模块和包管理&quot;">​</a></h2><p>rust 的模块系统有三个主要抽象，package, crate, mod。</p><h3 id="package" tabindex="-1">package <a class="header-anchor" href="#package" aria-label="Permalink to &quot;package&quot;">​</a></h3><p>一个 rust package/project 通常是一个文件夹，内部包含一个 Cargo.toml，它是 Cargo 包管理的基本单位。一个 package 通常至少含有一个 crate。</p><h3 id="crate" tabindex="-1">crate <a class="header-anchor" href="#crate" aria-label="Permalink to &quot;crate&quot;">​</a></h3><p>一个二进制的构建单元，在编译之后，就是一个二进制的可执行文件。crate 有两种，一种是独立执行二进制，其代码入口通常是 <code>&lt;package&gt;/src/main.rs</code> 文件；另一种是链接库二进制文件，其代码入口是 <code>&lt;package&gt;/src/lib.rs</code>。往往，我们的实际工程程序入口就是 main.rs，如果我们要发布链接库，那么入口就是 lib.rs。</p><h3 id="mod" tabindex="-1">mod <a class="header-anchor" href="#mod" aria-label="Permalink to &quot;mod&quot;">​</a></h3><p>一个 mod 模块是 Rust 代码的一个逻辑单元，可以用来组织和封装功能。Rust 模块可以在 crate 内部进行嵌套和组织。</p><p>程序的编译入口是 src/main.rs 文件，这是程序的根模块。你可以在这个文件中使用 <code>mod mod_name {}</code> 关键字进行模块声明，模块定义支持嵌套。</p><h4 id="模块拆分" tabindex="-1">模块拆分 <a class="header-anchor" href="#模块拆分" aria-label="Permalink to &quot;模块拆分&quot;">​</a></h4><p>当代码量变大的时候，我们需要将模块的代码拆分到不同的文件中进行保存。如何拆分？在一个模块文件中，可以将 <code>mod mod_name {}</code> 中的实现部分，拆分到<strong>与该文件同目录</strong>中的 mod_name.rs 文件中，然后留下 <code>mod mod_name;</code>，此语句表示，模块的实现被拆分到了同目录下的 <code>mod_name.rs</code> 文件中了，编译器将自行寻找它。</p><p>嵌套拆分，如果 mod_name.rs 中的代码还是多，那么还可以继续拆分。现在，将该文件变成 <code>mod_name/mod.rs</code> 文件，然后，将 mod.rs 文件中的子模块mod_a, mod_b 使用同样的方式，拆到同目录 mod_name 中的 mod_a.rs 和 mod_b.rs 文件中。</p><blockquote><p>mod_name/mod.rs 文件类似于 JavaScript 当中的 mod_name/index.js 文件，不过，JavaScript 当中的模块不存在和目录结构捆绑的父子关系，而 rust 中，还有其他的语言，如 Java、Python、Golang 等，有这样的关系。而像 JavaScript、C 语言、C++ 就没有模块和目录的捆绑。</p></blockquote><h4 id="访问控制和模块导入" tabindex="-1">访问控制和模块导入 <a class="header-anchor" href="#访问控制和模块导入" aria-label="Permalink to &quot;访问控制和模块导入&quot;">​</a></h4><p>使用 <code>pub</code> 关键字控制内容对于其所属模块外部代码的可见性。对于一个模块内部的代码，其默认对外不可见，但是对于该模块内部的同级内容可见。</p><p>如果是子模块 a，那么，哪怕模块 a 本身被 pub 修饰，子模块内部的代码页不会被兄弟模块 b 可见，兄弟模块 b 只是知道有这么个兄弟 a，而不知道 a 的内部有什么。</p><p>使用 <code>use</code> 关键字进行模块导入</p><ul><li><code>use foo;</code> 导入子模块 foo；</li><li><code>use foo::bar;</code> 导入子模块 foo 中的 bar，具体是什么不知道；</li><li><code>use foo::{bar1,bar2};</code> 导入子模块 foo 中的 bar1 和 bar2，具体是什么不知道；</li><li><code>use foo::*;</code> 导入子模块 foo 中的所有东西，具体是什么不知道；</li><li><code>use super::foo;</code> 导入兄弟模块 foo，即同目录下的 foo.rs 文件或者 foo/mod.rs 文件，或者是同文件中的 mod foo 声明；</li><li><code>use crate::foo;</code> 导入 src 目录下的文件，即 src/foo.rs 或者 src/foo/mod.rs 文件，或者 main.rs 中 mod foo 声明；</li></ul>',33)]))}const p=o(d,[["render",s]]);export{h as __pageData,p as default};
