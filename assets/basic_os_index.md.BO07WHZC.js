import{_ as e,c as i,o as t,ae as l}from"./chunks/framework.Cd-3tpCq.js";const r="/assets/platform.dio.DI-kKQAF.svg",u=JSON.parse('{"title":"操作系统","description":"","frontmatter":{"title":"操作系统","order":21},"headers":[],"relativePath":"basic/os/index.md","filePath":"basic/os/index.md"}'),o={name:"basic/os/index.md"};function s(n,a,d,c,h,p){return t(),i("div",null,a[0]||(a[0]=[l('<h1 id="操作系统" tabindex="-1">操作系统 <a class="header-anchor" href="#操作系统" aria-label="Permalink to &quot;操作系统&quot;">​</a></h1><p>操作系统理论为工程中实现操作系统提供理论基础。 <img src="'+r+'" alt="os platform"></p><h2 id="操作系统结构" tabindex="-1">操作系统结构 <a class="header-anchor" href="#操作系统结构" aria-label="Permalink to &quot;操作系统结构&quot;">​</a></h2><h3 id="宏内核" tabindex="-1">宏内核 <a class="header-anchor" href="#宏内核" aria-label="Permalink to &quot;宏内核&quot;">​</a></h3><p>整个系统分为内核和用户程序两部分，内核负责管理系统资源，运行特权级代码，用户程序负责使用业务逻辑，运行用户级代码，并可以通过系统调用访问底层资源。</p><p>宏内核拥有丰富的社区沉淀和积累，但是，宏内核在安全性和隔离性方面存在短板，内核模块之间没有隔离；另外，宏内核的实时性支持较弱，无法满足实时系统的需求。</p><h3 id="微内核" tabindex="-1">微内核 <a class="header-anchor" href="#微内核" aria-label="Permalink to &quot;微内核&quot;">​</a></h3><p>微内核是一种轻量级的操作系统内核，它只包含最基本的功能，如进程管理、内存管理、文件系统等。微内核通过提供一组基本的服务接口，为上层应用程序提供服务。 微内核的优点是：</p><ul><li>轻量级：代码量相对较小，启动速度较快，占用的资源也较少。</li><li>模块化：采用模块化的方式，每个模块都可以独立地进行开发和测试。</li><li>可扩展性：新的模块可以很容易地添加到系统中，而不需要对整个系统进行修改。</li><li>安全隔离性：每个模块都有自己的权限和访问控制机制。</li></ul><p>微内核的缺点是复杂性，微内核的模块化设计使得系统的复杂性提高，同时引入了模块间的通信和同步问题，带来了性能开销。微内核的应用场景包括，嵌入式系统，实时系统，分布式系统。</p><h3 id="其他内核" tabindex="-1">其他内核 <a class="header-anchor" href="#其他内核" aria-label="Permalink to &quot;其他内核&quot;">​</a></h3><ul><li>混合内核：宏内核和微内核的结合，宏内核提供基础功能，微内核提供上层应用程序的服务。</li><li>外核：宏内核和微内核的结合，宏内核提供基础功能，微内核提供上层应用程序的服务。</li><li>多内核：多个内核的结合，每个内核提供不同的功能。</li></ul>',12)]))}const m=e(o,[["render",s]]);export{u as __pageData,m as default};
