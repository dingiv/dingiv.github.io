import{_ as e,o as r,c as i,ah as n}from"./chunks/framework.B_34VmgG.js";const b=JSON.parse('{"title":"依赖管理","description":"","frontmatter":{},"headers":[],"relativePath":"design/arch/dependency.md","filePath":"design/arch/dependency.md"}'),h={name:"design/arch/dependency.md"};function l(t,a,o,d,p,c){return r(),i("div",null,[...a[0]||(a[0]=[n('<h1 id="依赖管理" tabindex="-1">依赖管理 <a class="header-anchor" href="#依赖管理" aria-label="Permalink to “依赖管理”">​</a></h1><p>程序产生的 bug 中，有相当一部分来自于依赖管理错误。</p><h2 id="获取依赖之难" tabindex="-1">获取依赖之难 <a class="header-anchor" href="#获取依赖之难" aria-label="Permalink to “获取依赖之难”">​</a></h2><p>在程序中，一个依赖可以被理解成当前的程序内存所存在的一个变量，亦或者是磁盘上存在的某个文件数据，亦或者是远程服务器上保存的一个数据。不论如何，当我们的程序在某个函数中希望获取某个信息来进行计算的时候，就不得不</p><p>blog补充状态管理 从业务代码中抽离生命周期，让容器托管创建和销毁，补充声明式思维和声明式状态</p><p>单例模式与全局变量，单例终结。 如何将全局变量重构为局部变量</p><p>依赖管理，在软件设计中添加</p><h2 id="依赖显式化" tabindex="-1">依赖显式化 <a class="header-anchor" href="#依赖显式化" aria-label="Permalink to “依赖显式化”">​</a></h2><p>程序的美德，自己尽全力解决依赖，提高健壮性</p><p>高内聚低耦合，solid，DRY，单元测试，代码即文档， 函数式，分布式系统</p><p>程序复杂的一个重要原因是外部依赖的不确定性</p><p>软件开发，不怕修改全局变量，怕的是你整个项目到处都在修改全局变量</p><h2 id="问题的本质" tabindex="-1">问题的本质 <a class="header-anchor" href="#问题的本质" aria-label="Permalink to “问题的本质”">​</a></h2><p>软件失败的根因，往往不是逻辑错误，而是对环境与依赖的假设过强。系统在启动或运行时对某个外部依赖做&quot;强定位&quot;，一旦定位失败，系统整体拒绝运行。这是一个过度确定性建模问题：依赖被建模为必然存在，定位方式是确定性路径或单点 key，失败策略是 fail-fast 加全局崩溃。</p><h2 id="依赖的定位方式" tabindex="-1">依赖的定位方式 <a class="header-anchor" href="#依赖的定位方式" aria-label="Permalink to “依赖的定位方式”">​</a></h2><p>不同系统采用不同的依赖定位策略，从简单到复杂形成演化轴：Map Lookup → Filtered Collection → Pattern Query。</p><p>Java IoC 容器使用简单的 Map 结构（BeanName → Bean），这是&quot;直接定位&quot;而非&quot;查询&quot;。这种设计是有意为之的，因为 IoC 是组件装配系统，不是组件查询系统，确定性比表达能力更重要。</p><p>相比之下，文件系统使用 glob 模式<code>（src/**/*.c）</code>匹配路径集合，CSS 使用选择器在 DOM 树上进行结构模式匹配，响应式配置中心则支持查询式的订阅规则。这些系统都引入了一层间接性，允许多解和运行期决策。</p><h2 id="健壮性的解决方向" tabindex="-1">健壮性的解决方向 <a class="header-anchor" href="#健壮性的解决方向" aria-label="Permalink to “健壮性的解决方向”">​</a></h2><h3 id="解耦身份与定位" tabindex="-1">解耦身份与定位 <a class="header-anchor" href="#解耦身份与定位" aria-label="Permalink to “解耦身份与定位”">​</a></h3><p>文件路径同时承担了身份、位置和加载策略三种角色，这三者被错误地压缩成一个字符串。更健壮的方式是用逻辑名代替物理路径，例如用 config:main 而非 /etc/myapp/config.yaml，然后通过环境变量、搜索路径列表、默认值和用户覆盖等策略解析。PATH、LD_LIBRARY_PATH、DNS 和 pkg-config 等系统早已验证了这种模式的有效性。</p><h3 id="从必需依赖到能力检测" tabindex="-1">从必需依赖到能力检测 <a class="header-anchor" href="#从必需依赖到能力检测" aria-label="Permalink to “从必需依赖到能力检测”">​</a></h3><p>不问&quot;你在哪里&quot;，而问&quot;你能做什么&quot;。反模式是必须存在 /usr/lib/libssl.so，改为检测是否支持 TLS、AES-GCM 等能力。这是接口驱动而非实现驱动，定位结果是一个候选集而非单点绑定。</p><h3 id="弱化失败语义" tabindex="-1">弱化失败语义 <a class="header-anchor" href="#弱化失败语义" aria-label="Permalink to “弱化失败语义”">​</a></h3><p>失败不等于退出，而是降级、禁用功能、警告并继续执行。工程上要点是功能模块可独立失效，核心路径最小化，启动成功优先于完美状态。</p><h3 id="声明式依赖解析" tabindex="-1">声明式依赖解析 <a class="header-anchor" href="#声明式依赖解析" aria-label="Permalink to “声明式依赖解析”">​</a></h3><p>从硬编码转向依赖声明，系统行为变为收集候选、按策略匹配、产出一个绑定结果。这本质上是把依赖解析做成一个查询问题，允许可选依赖、多候选路径和运行期决策。</p><h2 id="响应式与依赖追踪" tabindex="-1">响应式与依赖追踪 <a class="header-anchor" href="#响应式与依赖追踪" aria-label="Permalink to “响应式与依赖追踪”">​</a></h2><h3 id="信号与依赖自动传播" tabindex="-1">信号与依赖自动传播 <a class="header-anchor" href="#信号与依赖自动传播" aria-label="Permalink to “信号与依赖自动传播”">​</a></h3><p>信号是带有通知能力的变量，本质是封装了 getter/setter 的可追踪值。当信号变化时，所有依赖它的函数会自动重新运行。这种方式将依赖追踪自动化，副作用函数无需手动管理，适合轻量级的状态管理和 UI 层。</p><h3 id="跨进程响应式" tabindex="-1">跨进程响应式 <a class="header-anchor" href="#跨进程响应式" aria-label="Permalink to “跨进程响应式”">​</a></h3><p>在分布式环境中，状态隔离、跨网络通知和一致性延迟成为核心挑战。基本模式包括发布/订阅（Pub/Sub）、分布式状态同步（CRDT/OT）和响应式 API 层。微服务之间的响应式通信通过事件总线或流式接口实现，类似前端信号机制，但用跨进程通信代替内存调用。</p><h3 id="响应式配置中心" tabindex="-1">响应式配置中心 <a class="header-anchor" href="#响应式配置中心" aria-label="Permalink to “响应式配置中心”">​</a></h3><p>配置中心作为信号源，每个配置项都是可追踪的信号。服务订阅自己关心的配置信号，当信号变化时自动触发更新逻辑。配置中心主动推送而非服务轮询，实现实时性、解耦和集中管理。</p>',34)])])}const f=e(h,[["render",l]]);export{b as __pageData,f as default};
