import{_ as i,o as a,c as n,ah as l,b6 as e}from"./chunks/framework.CJUjh4G6.js";const E=JSON.parse('{"title":"单进程","description":"","frontmatter":{"title":"单进程","order":10},"headers":[],"relativePath":"design/spacetime/process/single.md","filePath":"design/spacetime/process/single.md"}'),t={name:"design/spacetime/process/single.md"};function h(p,s,k,r,d,g){return a(),n("div",null,[...s[0]||(s[0]=[l(`<h1 id="单进程程序结构" tabindex="-1">单进程程序结构 <a class="header-anchor" href="#单进程程序结构" aria-label="Permalink to “单进程程序结构”">​</a></h1><p>从单进程程序的结构上看，常见程序的结构可以分成两种：one-shot 和 daemon。</p><p>One-shot 程序读取命令行参数后，从前到后一次性执行，处理完数据后直接退出。这类程序通常较为简单，如命令行工具、批处理脚本等。这种程序可以认为是一次 IO 请求。</p><p>Daemon 程序在解析完命令行参数和配置文件后进入死循环，通过阻塞式系统调用监听和等待它感兴趣的事件，并在事件发生时被操作系统唤醒，然后执行业务逻辑。除非触发关闭命令或者异常，否则会按照期望一直运行下去。这是我们平时编写多数程序的结构，包括前端的 GUI 客户端程序和后端的 server 程序。这种程序可以认为是一个持续运行的状态机。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// daemon 程序</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 读取命令行参数，形成启动参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(argc, argv);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 读取配置文件，形成程序配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 查找配置中的监听任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 阻塞式调用，根据配置信息按照要求监听客户端的请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incoming </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 业务层寻找处理该请求的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config, incoming);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 分发该请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> distribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config, incoming, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 响应请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incoming, result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 释放程序的所有资源</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cleanAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 清除监听任务的请求处理器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleShutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ...) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cleanTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, config);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="daemon-程序" tabindex="-1">Daemon 程序 <a class="header-anchor" href="#daemon-程序" aria-label="Permalink to “Daemon 程序”">​</a></h2><p>从纵向来看，程序需要在开始时解析配置和参数，然后进入循环，从配置和参数中寻找需要监听和处理的任务。如果找到了，则根据任务的类型，将具体任务分发给相应的处理函数，得到处理结果，然后把结果返回给客户端，往复循环。</p><p>何时停止？当需要监听的事件和任务被处理完了，或者触发了清理监听任务的处理器的时候，由于没有任务，则程序 break 出循环，程序结束。</p><p>同时，在处理任务的过程中，可能由于监听到了新的事件发生，从而向任务队列中添加了新的任务，也就是任务是可增可减、动态变化的，形如一个<strong>状态机</strong>的结构。</p><p>从横向看，daemon 程序的结构可以被概括为一个&quot;前中后&quot;三层结构——<strong>前端视图层</strong>、<strong>中间业务层</strong>、<strong>后端持久层</strong>。</p><p><img src="`+e+`" alt=""></p><ul><li><strong>视图层</strong>：面向自己的客户端，监听客户端的请求和操作，解析和翻译操作，并将请求的任务分发给中间业务层</li><li><strong>中间层</strong>：负责进行主体复杂逻辑的实现和繁重工作的处理，它在处理业务的过程中可能需要依赖外界的持久化数据，或者将数据进行持久化，它会选择性地调用后端持久层，进行数据持久化的操作</li><li><strong>后端持久层</strong>：通过系统 IO 调用，向进程外发送和获取数据，或是作为数据的直接管理者，代替进程中的其他部分管理数据</li></ul><p>在横向的三层中，必须要保持单向依赖，以简化程序的结构，让层间的功能保持独立。</p><h3 id="客户端-daemon-程序" tabindex="-1">客户端 Daemon 程序 <a class="header-anchor" href="#客户端-daemon-程序" aria-label="Permalink to “客户端 Daemon 程序”">​</a></h3><p>相较于服务端的 server 程序，客户端的 daemon 渲染程序有一个特殊的地方：渲染 daemon 在主循环中加入了<strong>渲染 tick</strong>。主循环针对键盘 IO 等事件不再立即回应（相比 server 程序是立即回应），渲染 daemon 会采用计时器来计时，每过一段时间批量处理所有的事件，并结合游戏程序经常采用的 ECS 架构模式，批量并行处理上层业务逻辑，这些上层的业务逻辑通常由 GUI 客户端开发者编写。</p><h2 id="mvc-架构" tabindex="-1">MVC 架构 <a class="header-anchor" href="#mvc-架构" aria-label="Permalink to “MVC 架构”">​</a></h2><p>MVC（Model-View-Controller）是现代 daemon 程序的典型架构模式，特别适用于 Web 应用和桌面应用。它将程序划分为三层，各层负责自己的逻辑，拆分了复杂的业务模块，降低了软件开发的复杂度。</p><h3 id="三层职责" tabindex="-1">三层职责 <a class="header-anchor" href="#三层职责" aria-label="Permalink to “三层职责”">​</a></h3><ul><li><strong>Model（模型）</strong>：负责数据和业务逻辑，管理应用程序的状态，处理数据持久化</li><li><strong>View（视图）</strong>：负责用户界面展示，显示模型中的数据，不包含业务逻辑</li><li><strong>Controller（控制器）</strong>：处理用户输入，更新模型，选择适当的视图进行显示</li></ul><h3 id="mvc-的工作流程" tabindex="-1">MVC 的工作流程 <a class="header-anchor" href="#mvc-的工作流程" aria-label="Permalink to “MVC 的工作流程”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>用户请求 → Controller → Model（业务逻辑） → 数据更新</span></span>
<span class="line"><span>                                    ↓</span></span>
<span class="line"><span>View ← 数据渲染 ← Controller ← 状态返回</span></span></code></pre></div><ol><li>用户通过视图发起请求</li><li>控制器接收请求并处理</li><li>控制器调用模型处理业务逻辑</li><li>模型更新数据状态</li><li>控制器选择视图进行展示</li><li>视图从模型获取数据并渲染</li></ol><h3 id="mvc-的进化" tabindex="-1">MVC 的进化 <a class="header-anchor" href="#mvc-的进化" aria-label="Permalink to “MVC 的进化”">​</a></h3><p>MVC 的缺点是 controller 的体积较大，逻辑在该层沉积；为了减少该层的臃肿，MVP 和 MVVM 架构是在 MVC 的架构上微调，使得 controller 层完全不再感知 view，自此 MVC 结构也逐渐和 MVP，MVVM 混淆在一起，MVC 正式成为了<em>三层单向依赖架构</em>程序的代名词。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>用户请求 → View → Presenter → Model → 数据更新</span></span>
<span class="line"><span>                               ↓</span></span>
<span class="line"><span>        ← View ← Presenter ← 结果返回</span></span></code></pre></div><p>或者使用更加现代的称呼</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>UI -&gt; Service -&gt; DAO</span></span></code></pre></div><h4 id="mvp-model-view-presenter" tabindex="-1">MVP（Model-View-Presenter） <a class="header-anchor" href="#mvp-model-view-presenter" aria-label="Permalink to “MVP（Model-View-Presenter）”">​</a></h4><ul><li>Presenter 替代 Controller，作为中间层完全隔离 View 和 Model</li><li>View 和 Model 完全分离，View 只负责展示，Presenter 处理所有逻辑</li><li>更适合桌面应用和传统客户端应用</li></ul><h4 id="mvvm-model-view-viewmodel" tabindex="-1">MVVM（Model-View-ViewModel） <a class="header-anchor" href="#mvvm-model-view-viewmodel" aria-label="Permalink to “MVVM（Model-View-ViewModel）”">​</a></h4><ul><li>ViewModel 作为 View 和 Model 的桥梁</li><li>通过数据绑定机制实现 View 和 ViewModel 的自动同步</li><li>更适合现代前端框架（如 Vue、Angular）</li></ul><h3 id="mvc-的最佳实践" tabindex="-1">MVC 的最佳实践 <a class="header-anchor" href="#mvc-的最佳实践" aria-label="Permalink to “MVC 的最佳实践”">​</a></h3><ul><li><strong>保持模型简单</strong>：只包含数据和业务逻辑，避免在模型中处理 UI 逻辑</li><li><strong>视图职责单一</strong>：只负责展示，不包含业务逻辑</li><li><strong>使用依赖注入</strong>：降低组件耦合，提高可测试性</li><li><strong>分层解耦</strong>：确保层间的单向依赖，避免循环依赖</li></ul><h2 id="ecs-架构" tabindex="-1">ECS 架构 <a class="header-anchor" href="#ecs-架构" aria-label="Permalink to “ECS 架构”">​</a></h2><p>ECS（Entity-Component-System）是一种主要用于渲染程序和游戏开发的架构模式。它通过将数据和行为分离来实现高度模块化和可扩展的系统设计。在游戏中，结合渲染引擎的渲染节奏，插空批量执行游戏逻辑。</p><h3 id="核心优势" tabindex="-1">核心优势 <a class="header-anchor" href="#核心优势" aria-label="Permalink to “核心优势”">​</a></h3><ul><li><strong>模块化</strong>：基于组合优于继承的思想，组件可以自由组合，系统可以独立开发。开发者可以根据需要灵活地组合不同的组件来创建新的实体类型，而无需修改现有代码。</li><li><strong>性能优化</strong>：组件数据存储在连续的内存空间中，数据局部性好，便于实现缓存友好型代码。特别适合处理大量相似对象，系统可以高效地遍历和处理相同类型的组件数据。</li><li><strong>可维护性</strong>：通过关注点分离，使代码结构更加清晰。每个系统只负责处理特定类型的组件，组件只包含数据，系统只包含逻辑，这种清晰的职责划分使得代码易于理解和维护。</li><li><strong>灵活性</strong>：实体可以在运行时动态添加或移除组件，系统可以独立启用或禁用，便于实现热重载功能。</li></ul><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to “核心概念”">​</a></h3><p><strong>Entity（实体）</strong></p><ul><li>实体是游戏世界中的基本单位</li><li>实体本身不包含任何数据或行为</li><li>实体只是一个唯一的标识符，用于组合不同的组件</li><li>例如：玩家、敌人、道具等都可以是实体</li></ul><p><strong>Component（组件）</strong></p><ul><li>组件是纯数据容器</li><li>每个组件只包含特定类型的数据</li><li>组件没有行为逻辑</li><li>常见组件示例： <ul><li><code>PositionComponent</code>：位置信息（x, y, z 坐标）</li><li><code>HealthComponent</code>：生命值（当前值、最大值）</li><li><code>SpriteComponent</code>：精灵/图像（纹理、尺寸）</li><li><code>CollisionComponent</code>：碰撞信息（碰撞盒、碰撞组）</li></ul></li></ul><p><strong>System（系统）</strong></p><ul><li>系统是处理逻辑的地方</li><li>每个系统负责处理特定类型的组件</li><li>系统不存储状态，只处理数据</li><li>常见系统示例： <ul><li><code>MovementSystem</code>：处理移动逻辑</li><li><code>RenderingSystem</code>：处理渲染逻辑</li><li><code>CollisionSystem</code>：处理碰撞检测</li><li><code>HealthSystem</code>：处理生命值变化</li></ul></li></ul><h3 id="ecs-的工作流程" tabindex="-1">ECS 的工作流程 <a class="header-anchor" href="#ecs-的工作流程" aria-label="Permalink to “ECS 的工作流程”">​</a></h3><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ECS 的典型执行流程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gameLoop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (running) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1. 输入处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    inputSystem.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2. 系统更新（按依赖顺序）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    movementSystem.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deltaTime);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collisionSystem.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    healthSystem.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3. 渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    renderingSystem.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 4. 等待下一个 tick</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    waitForNextFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    config-&gt;inputSystem </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initInputSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    config-&gt;movementSystem </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initMovementSystem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gameLoop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ecs-的最佳实践" tabindex="-1">ECS 的最佳实践 <a class="header-anchor" href="#ecs-的最佳实践" aria-label="Permalink to “ECS 的最佳实践”">​</a></h3><ul><li><strong>保持组件简单</strong>：组件只包含数据，不包含逻辑</li><li><strong>系统职责单一</strong>：每个系统只负责一类特定的行为</li><li><strong>避免系统间依赖</strong>：系统之间应该尽可能独立，通过组件通信</li><li><strong>合理组织数据</strong>：使用结构体数组（SoA）而非数组结构体（AoS）以提高缓存命中率</li><li><strong>注意性能瓶颈</strong>：避免在系统执行过程中添加/删除组件或实体</li></ul><blockquote><p><strong>掉帧问题</strong>：ECS 可以极大地提高一次渲染循环中的业务处理计算量，但是，如果开发者在渲染循环中加入了阻塞任务，那么极有可能导致在渲染循环即将到来的下一个周期，还没能够处理完上一个周期的任务，因此错过了本轮的渲染画面更新，从而导致了掉帧的情况。掉帧对于用户来说，表现行为就是画面一卡一卡的。</p></blockquote><h2 id="mvc-与-ecs-的对比" tabindex="-1">MVC 与 ECS 的对比 <a class="header-anchor" href="#mvc-与-ecs-的对比" aria-label="Permalink to “MVC 与 ECS 的对比”">​</a></h2><p>MVC 和 ECS 都是处理 daemon 程序的架构模式，但它们的适用场景和设计理念有所不同。</p><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to “适用场景”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>MVC</th><th>ECS</th></tr></thead><tbody><tr><td>应用类型</td><td>Web 应用、桌面应用</td><td>游戏、渲染程序</td></tr><tr><td>处理方式</td><td>事件驱动、即时响应</td><td>批量处理、定时渲染</td></tr><tr><td>性能要求</td><td>中等</td><td>极高</td></tr><tr><td>复杂度</td><td>较低</td><td>较高</td></tr></tbody></table><ul><li><p>ECS 是针对 MVC 架构中中间业务处理层的<strong>并行性不够和批量化处理能力不够</strong>的现实情况提出的业务处理模式。ECS 可以通过 System 抽象，将不同类型的业务进行并行化逻辑，提高了 CPU 的利用率。</p></li><li><p>ECS 与渲染程序的渲染节奏更加契合。渲染程序会采用一定的渲染节奏，每隔一段时间触发一次批量化的业务逻辑计算，再进行画面的更新，而不是像 MVC 程序（例如 web server）那样，一旦接受到新的 IO 任务就开始一次业务分发和处理。</p><p>这将有效提高程序在大规模 IO 事件和批量化任务面前的吞吐能力，但是在一定程度上引入了延迟，这也是为什么 server 程序不采用 ECS 的原因。</p></li></ul><h3 id="延迟与吞吐的权衡" tabindex="-1">延迟与吞吐的权衡 <a class="header-anchor" href="#延迟与吞吐的权衡" aria-label="Permalink to “延迟与吞吐的权衡”">​</a></h3><ul><li><strong>MVC</strong>：低延迟、中等吞吐。适合需要快速响应用户请求的应用，如 Web 服务、企业应用等。</li><li><strong>ECS</strong>：较高延迟、极高吞吐。适合需要处理大量实体和复杂逻辑的游戏和渲染程序，延迟通常在一帧以内（16.67ms @ 60fps），用户感知不明显。</li></ul>`,56)])])}const c=i(t,[["render",h]]);export{E as __pageData,c as default};
