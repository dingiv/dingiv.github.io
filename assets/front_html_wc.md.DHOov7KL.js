import{_ as a,c as i,o as t,ae as n}from"./chunks/framework.Dh1jimFm.js";const c=JSON.parse('{"title":"web component","description":"","frontmatter":{},"headers":[],"relativePath":"front/html/wc.md","filePath":"front/html/wc.md"}'),e={name:"front/html/wc.md"};function l(h,s,p,k,o,r){return t(),i("div",null,s[0]||(s[0]=[n(`<h1 id="web-component" tabindex="-1">web component <a class="header-anchor" href="#web-component" aria-label="Permalink to &quot;web component&quot;">​</a></h1><p>原生的web元素组件化能力，使用全局API customElements.define()来进行注册，单个元素的声明使用class语法，继承HTMLElement进行书写，该类实例化之后，成为DOM元素实例，需要在元素的身上定义几个关键的hooks函数，然后来对元素的逻辑进行管理。</p><h2 id="hooks" tabindex="-1">hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;hooks&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[propKey:string] : any </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任意属性，可以暴露在元素实例的数据</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  :  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回这个元素的可观测动态属性，这些属性将会被观察，并在发生变化时调用回调函数attributeChangedCallback</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">static get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observedAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() :  string[] </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attributeChangedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(property, oldValue, newValue) : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connectedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这个元素被挂载到document时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnectedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这个元素从document卸载时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adoptedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span></span></code></pre></div><h2 id="影子节点的css解决方案" tabindex="-1">影子节点的css解决方案 <a class="header-anchor" href="#影子节点的css解决方案" aria-label="Permalink to &quot;影子节点的css解决方案&quot;">​</a></h2><ul><li>局部声明，在影子节点内部声明的style标签只会作用于该影子节点，连同类都没有办法影响，因此这种样式将会被重复声明；</li><li>局部引用，使用link标签引入css文件，这种方式一个页面只会申请一次网络请求，同时能够使用css文件隔离逻辑</li><li>CSS变量，影子节点的能够访问自定义元素的CSS变量，这是一种外部CSS变量向影子节点传递的简陋方式</li><li>样式穿透，在组件的内部使用自定义元素的类型，加上::part(&#39;tag&#39;)伪元素选择器可以选择影子节点内部part属性等于&#39;tag&#39;的元素，另一方面，在影子节点组件的内部使用::slotted(&#39;selector&#39;)将可以在组件内修改未来插槽中填充的元素的样式</li><li>样式表构造，使用API CSSStyleSheet，手动创建一个CSSOM树，创建好后添加到adoptedStyleSheets属性，该属性位于document上和shadowRoot上，即可改变CSS属性，该方式性能最好，并且可以实现多个影子节点实例之间共用CSS</li></ul>`,6)]))}const E=a(e,[["render",l]]);export{c as __pageData,E as default};
