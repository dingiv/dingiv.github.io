import{_ as l,c as i,o as t,ae as r}from"./chunks/framework.Cd-3tpCq.js";const e="/assets/irq.dio.B_eGee80.svg",c=JSON.parse('{"title":"中断","description":"","frontmatter":{},"headers":[],"relativePath":"basic/hardware/interrupt.md","filePath":"basic/hardware/interrupt.md"}'),o={name:"basic/hardware/interrupt.md"};function d(h,a,n,s,b,p){return t(),i("div",null,a[0]||(a[0]=[r('<h1 id="中断" tabindex="-1">中断 <a class="header-anchor" href="#中断" aria-label="Permalink to &quot;中断&quot;">​</a></h1><p>中断是硬件层的特性，允许外部设备通过硬件信号打断 CPU 的正常执行流程，转而处理更紧急的任务。更进一步的，中断信号使得 CPU 停下手中的工作，保存寄存器现场，然后跳转到某个内存地址，执行该位置处的函数。</p><p>其实现的理由是让 CPU 或者计算机系统具有<strong>被动感知</strong>外界的能力。因为，如果不是被动感知，那么 CPU 就需要通过主动轮询的方式去主动调查外界，就会导致 CPU 资源的浪费。同时，中断为上层程序的赖以使用的<strong>回调函数和异步能力</strong>的功能基础提供支持。</p><p>中断分为两种类型。外部中断，来自外部设备的中断、时钟中断、电源管理中断、核间中断（多核心 CPU 之间进行的主动中断触发）等；内部中断，通过特定的指令由软件主动触发，来自异常（由 CPU 执行指令时产生的错误），陷阱（由程序主动触发的中断），系统调用（用户程序请求操作系统服务）。</p><h2 id="中断的基本特点" tabindex="-1">中断的基本特点 <a class="header-anchor" href="#中断的基本特点" aria-label="Permalink to &quot;中断的基本特点&quot;">​</a></h2><ul><li>异步性：中断可以在任何时候发生，不需要与 CPU 的执行同步</li><li>优先级：不同类型的中断具有不同的优先级，确保重要事件得到及时处理</li><li>可屏蔽：某些中断可以被暂时禁止，以保护关键代码段的执行</li><li>可嵌套：高优先级中断可以打断低优先级中断的处理</li></ul><h2 id="中断控制器" tabindex="-1">中断控制器 <a class="header-anchor" href="#中断控制器" aria-label="Permalink to &quot;中断控制器&quot;">​</a></h2><p>中断控制器是管理中断请求的硬件设备，主要负责：</p><ol><li>接收来自各个设备的中断请求</li><li>对中断请求进行优先级排序</li><li>向 CPU 发送中断信号</li><li>管理中断屏蔽和使能</li></ol><p><img src="'+e+'" alt="中断控制器"></p><p>现代计算机系统通常使用高级可编程中断控制器（APIC），它支持：</p><ul><li>多处理器环境下的中断分发</li><li>中断优先级管理</li><li>中断向量表</li><li>中断屏蔽控制</li></ul><p>在多核处理器系统中，中断处理变得更加复杂，中断控制器需要负责中断分发，决定由哪个 CPU 核心处理中断；负载均衡，在不同核心间分配中断处理任务；缓存一致性，确保中断处理程序的数据一致性；同步机制，处理多核心间的中断竞争。</p><h2 id="中断处理流程" tabindex="-1">中断处理流程 <a class="header-anchor" href="#中断处理流程" aria-label="Permalink to &quot;中断处理流程&quot;">​</a></h2><p>当发生中断时，硬件会执行以下步骤：</p><ol><li>保存当前执行状态，将程序计数器（PC）压入栈，保存处理器状态寄存器，保存其他必要的寄存器</li><li>切换到中断处理模式，禁用其他中断（可配置），切换到内核模式，加载中断处理程序的地址</li><li>执行中断服务程序，识别中断源，处理中断请求，清除中断标志</li><li>恢复执行状态，恢复保存的寄存器，恢复处理器状态，返回被中断的程序</li></ol><h3 id="中断向量表" tabindex="-1">中断向量表 <a class="header-anchor" href="#中断向量表" aria-label="Permalink to &quot;中断向量表&quot;">​</a></h3><p>中断向量表是一个存储中断处理程序入口地址的数据结构，通常位于内存的固定位置。每个中断类型对应一个向量号，通过向量号可以找到对应的处理程序。</p><h3 id="中断优先级" tabindex="-1">中断优先级 <a class="header-anchor" href="#中断优先级" aria-label="Permalink to &quot;中断优先级&quot;">​</a></h3><p>中断优先级决定了多个中断同时发生时，哪个中断会被优先处理。优先级通常分为：</p><ol><li>不可屏蔽中断（NMI）</li><li>硬件中断</li><li>软件中断</li><li>异常</li></ol><h3 id="中断延迟" tabindex="-1">中断延迟 <a class="header-anchor" href="#中断延迟" aria-label="Permalink to &quot;中断延迟&quot;">​</a></h3><p>中断延迟是指从中断发生到开始执行中断处理程序的时间，包括：</p><ul><li>硬件延迟：中断信号传播时间</li><li>软件延迟：中断处理程序准备时间</li><li>系统延迟：其他中断或系统活动造成的延迟</li></ul><h3 id="中断优化" tabindex="-1">中断优化 <a class="header-anchor" href="#中断优化" aria-label="Permalink to &quot;中断优化&quot;">​</a></h3><p>为了提高中断处理效率，现代处理器采用多种优化技术：</p><ol><li>中断合并：将多个相似的中断合并处理</li><li>中断亲和性：将中断绑定到特定 CPU 核心</li><li>中断轮询：在低负载时使用轮询代替中断</li><li>中断延迟：通过延迟处理非关键中断来减少系统开销</li></ol><h2 id="作用场景" tabindex="-1">作用场景 <a class="header-anchor" href="#作用场景" aria-label="Permalink to &quot;作用场景&quot;">​</a></h2><ul><li>多任务处理：通过中断实现进程切换和调度</li><li>资源管理：及时响应硬件资源状态变化</li><li>事件驱动：响应IO设备的中断，实现监听IO事件</li><li>异常处理：处理系统异常和错误</li><li>实时响应：保证关键事件的及时处理</li></ul><table tabindex="0"><thead><tr><th>类型</th><th>具体中断</th></tr></thead><tbody><tr><td>硬件中断</td><td>- IO中断（磁盘读写完成）<br>- 定时器中断<br>- 外设中断（鼠标键盘操作）<br>- 电源管理中断<br>- 网络设备中断<br>- DMA传输完成中断</td></tr><tr><td>软件中断</td><td>- 系统调用（通过int指令触发）<br>- 异常处理（如除零错误）<br>- 调试断点<br>- 信号处理<br>- 内核态切换</td></tr><tr><td>异常</td><td>- 页错误（Page Fault）<br>- 段错误（Segmentation Fault）<br>- 除零错误<br>- 非法指令<br>- 栈溢出<br>- 特权级错误</td></tr></tbody></table>',30)]))}const P=l(o,[["render",d]]);export{c as __pageData,P as default};
