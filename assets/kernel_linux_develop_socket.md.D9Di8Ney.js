import{_ as a,c as i,o as l,ae as s}from"./chunks/framework.Dgg8-8ov.js";const k=JSON.parse('{"title":"套接字","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/develop/socket.md","filePath":"kernel/linux/develop/socket.md"}'),t={name:"kernel/linux/develop/socket.md"};function n(o,e,p,r,c,d){return l(),i("div",null,e[0]||(e[0]=[s(`<h1 id="套接字" tabindex="-1">套接字 <a class="header-anchor" href="#套接字" aria-label="Permalink to &quot;套接字&quot;">​</a></h1><h3 id="字节序处理" tabindex="-1">字节序处理 <a class="header-anchor" href="#字节序处理" aria-label="Permalink to &quot;字节序处理&quot;">​</a></h3><ol><li><p>基本概念</p><ul><li>内存和数据流被抽象为字节数组</li><li>数据编码需要先转换为 16 进制</li><li>内存地址从低到高：0x00000000 -&gt; 0xffffffff</li></ul></li><li><p>字节序转换</p><ul><li>不同平台 CPU 的大小端序不同</li><li>网络通信和驱动编写需要固定字节序</li><li>使用转换函数处理字节序：<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu_to_le32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu_to_le64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></li></ul></li></ol>`,3)]))}const _=a(t,[["render",n]]);export{k as __pageData,_ as default};
