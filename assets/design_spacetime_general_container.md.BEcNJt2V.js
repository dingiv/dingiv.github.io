import{_ as t,o as n,c as a,ah as o}from"./chunks/framework.BvDvRtye.js";const m=JSON.parse('{"title":"容器","description":"","frontmatter":{},"headers":[],"relativePath":"design/spacetime/general/container.md","filePath":"design/spacetime/general/container.md"}'),r={name:"design/spacetime/general/container.md"};function i(p,e,s,c,l,d){return n(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="容器" tabindex="-1">容器 <a class="header-anchor" href="#容器" aria-label="Permalink to “容器”">​</a></h1><p>容器在软件工程中是一个信息量巨大的词。一谈到容器，我们可能会想到 docker 容器。但是，容器的外延并不止于此，但我们尝试从不同的层面区理解容器时，我们会发现容器其实是一个<strong>专注于管理某类资源的有限系统</strong>。</p><ul><li>资源隔离：容器用于呈装何种资源，提供何种层次的隔离能力</li><li>依赖管理：为了容器内部的资源提供必要的运行环境和依赖</li><li>容器间通信：在多实例的容器系统中，负责容器间的通信和交互</li><li>生命周期：资源往往具有生命周期，容器本身也就具有了生命周期</li></ul><p>有限性：容器管理的资源是有限的，容器管理的内容是有限。</p><p>控制反转 (IoC) 的边界： 思考不仅是对象的创建权交出去，连执行流的控制权是否也能交出去？（例如插件架构、微内核架构）。</p><p>服务发现 vs 依赖注入： 在分布式/微服务环境下，依赖不再是简单的内存对象注入，而是服务地址的动态发现。</p><p>笔记 container 和 scope 触及了系统如何划分。</p><p>C4 模型 (C4 Model)： 这是目前最推荐的架构可视化方法。它将系统分为四个级别：Context (上下文)、Containers (容器，如 Web 应用、数据库)、Components (组件)、Code (代码)。你的 container 和 scope 笔记正好对应了 C4 的前两层。</p><p>限界上下文 (Bounded Context)： 这是 DDD（领域驱动设计）的核心。架构设计最难的不是写代码，而是划定“范围 (Scope)”。同一个“订单”对象，在销售 Scope 和物流 Scope 里的定义是完全不同的。</p>',9)])])}const C=t(r,[["render",i]]);export{m as __pageData,C as default};
