import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.BtEkjhVd.js";const p=JSON.parse('{"title":"Linux 开发笔记","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/linux/develop/lib.md","filePath":"kernel/linux/develop/lib.md"}'),r={name:"kernel/linux/develop/lib.md"};function o(n,l,s,h,u,c){return e(),a("div",null,l[0]||(l[0]=[t(`<h1 id="linux-开发笔记" tabindex="-1">Linux 开发笔记 <a class="header-anchor" href="#linux-开发笔记" aria-label="Permalink to &quot;Linux 开发笔记&quot;">​</a></h1><h2 id="开发库" tabindex="-1">开发库 <a class="header-anchor" href="#开发库" aria-label="Permalink to &quot;开发库&quot;">​</a></h2><h3 id="glib" tabindex="-1">Glib <a class="header-anchor" href="#glib" aria-label="Permalink to &quot;Glib&quot;">​</a></h3><p>Glib 是由 GNU 书写的 C 语言通用跨平台库，广泛应用于 C 语言程序中。它提供 C 标准库所没有的很多上层 API 封装，简化了 C 语言的开发和使用，包括：</p><ul><li>内存管理</li><li>字符串处理</li><li>常用数据结构</li><li>文件管理</li><li>锁机制</li></ul><h3 id="klib-linux-kernel-library" tabindex="-1">Klib (Linux Kernel Library) <a class="header-anchor" href="#klib-linux-kernel-library" aria-label="Permalink to &quot;Klib (Linux Kernel Library)&quot;">​</a></h3><p>Linux 下的程序编译环境默认包含 <code>/usr/include</code> 文件夹下的头文件：</p><ul><li><code>/usr/include/linux</code>：用于编译和开发内核模块</li><li><code>/usr/include/sys</code>：提供与 Linux 系统强相关的函数库</li></ul><p>系统调用机制：</p><ul><li>用户态程序通过包含 <code>sys/xxx.h</code> 进行系统调用</li><li>通过 <code>sys/ioctl.h</code> 提供的文件操作接口与内核模块交互</li><li>系统调用函数在进程实例化时由系统自动加载到内核空间</li></ul><h3 id="常用第三方库" tabindex="-1">常用第三方库 <a class="header-anchor" href="#常用第三方库" aria-label="Permalink to &quot;常用第三方库&quot;">​</a></h3><ol><li><p>网络相关</p><ul><li>libcurl：HTTP 客户端库</li><li>OpenSSL：加密和安全通信</li><li>libevent：事件驱动网络库</li><li>libuv：跨平台异步 I/O 库</li></ul></li><li><p>数据处理</p><ul><li>SQLite：轻量级数据库</li><li>zlib：数据压缩</li><li>libxml2：XML 处理</li><li>jansson：JSON 处理</li></ul></li><li><p>多媒体</p><ul><li>FFmpeg：音视频处理</li><li>libpng：PNG 图像处理</li></ul></li></ol><h2 id="代码实践" tabindex="-1">代码实践 <a class="header-anchor" href="#代码实践" aria-label="Permalink to &quot;代码实践&quot;">​</a></h2><h3 id="函数设计原则" tabindex="-1">函数设计原则 <a class="header-anchor" href="#函数设计原则" aria-label="Permalink to &quot;函数设计原则&quot;">​</a></h3><ol><li><p>函数纯洁性</p><ul><li>C 程序对 I/O 操作有容忍性</li><li>多数函数允许使用 I/O 操作</li></ul></li><li><p>参数传递</p><ul><li>推崇&quot;改参函数&quot;模式</li><li>函数返回值通常为 int 类型，表示操作是否成功</li><li>实际结果通过参数中的指针返回</li><li>内存分配由用户决定（栈或堆）</li></ul></li><li><p>内存管理</p><ul><li>动态内存分配需要传递指针的指针</li><li>函数通过参数返回动态分配的内存</li></ul></li><li><p>编程规范</p><ul><li>减少全局状态引用</li><li>检查所有返回 int 结果的函数</li><li>验证所有接收指针的参数的合法性</li></ul></li></ol><h3 id="字节序处理" tabindex="-1">字节序处理 <a class="header-anchor" href="#字节序处理" aria-label="Permalink to &quot;字节序处理&quot;">​</a></h3><ol><li><p>基本概念</p><ul><li>内存和数据流被抽象为字节数组</li><li>数据编码需要先转换为 16 进制</li><li>内存地址从低到高：0x00000000 -&gt; 0xffffffff</li></ul></li><li><p>字节序转换</p><ul><li>不同平台 CPU 的大小端序不同</li><li>网络通信和驱动编写需要固定字节序</li><li>使用转换函数处理字节序：<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu_to_le32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpu_to_le64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div></li></ul></li></ol><h2 id="网络编程" tabindex="-1">网络编程 <a class="header-anchor" href="#网络编程" aria-label="Permalink to &quot;网络编程&quot;">​</a></h2><h3 id="socket-编程" tabindex="-1">Socket 编程 <a class="header-anchor" href="#socket-编程" aria-label="Permalink to &quot;Socket 编程&quot;">​</a></h3><h4 id="tcp-服务端流程" tabindex="-1">TCP 服务端流程 <a class="header-anchor" href="#tcp-服务端流程" aria-label="Permalink to &quot;TCP 服务端流程&quot;">​</a></h4><ol><li>创建 Socket</li><li>绑定地址</li><li>监听连接</li><li>接受连接</li><li>读写数据</li></ol><h4 id="tcp-客户端流程" tabindex="-1">TCP 客户端流程 <a class="header-anchor" href="#tcp-客户端流程" aria-label="Permalink to &quot;TCP 客户端流程&quot;">​</a></h4><ol><li>创建 Socket</li><li>连接服务器</li><li>读写数据</li></ol><h3 id="scatter-gather-i-o" tabindex="-1">Scatter/Gather I/O <a class="header-anchor" href="#scatter-gather-i-o" aria-label="Permalink to &quot;Scatter/Gather I/O&quot;">​</a></h3><p>Scatter/Gather I/O（分散-聚集 I/O）是一种高效的数据传输技术：</p><ul><li>避免不必要的内存拷贝</li><li>减少 CPU 负担</li><li>提升 I/O 性能</li></ul><p>实现方式：</p><ol><li>Scatter Read：从连续数据源读取，分散存储到多个内存块</li><li>Gather Write：从多个内存块读取，一次性写入连续目标</li></ol><h2 id="内核开发" tabindex="-1">内核开发 <a class="header-anchor" href="#内核开发" aria-label="Permalink to &quot;内核开发&quot;">​</a></h2><h3 id="开发环境" tabindex="-1">开发环境 <a class="header-anchor" href="#开发环境" aria-label="Permalink to &quot;开发环境&quot;">​</a></h3><ul><li>使用 QEMU 模拟器进行跨平台硬件模拟</li><li>支持不同架构下的内核开发和调试</li></ul><h3 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-label="Permalink to &quot;系统调用&quot;">​</a></h3><ul><li>通过 <code>sys/syscall.h</code> 扩展系统调用接口</li><li>使用 <code>syscall</code> 函数，参数为系统调用号（<code>SYS_xxx</code>）</li></ul>`,33)]))}const b=i(r,[["render",o]]);export{p as __pageData,b as default};
