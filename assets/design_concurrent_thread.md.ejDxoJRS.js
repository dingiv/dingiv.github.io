import{_ as e,c as t,o as i,ae as l}from"./chunks/framework.BQlYxExx.js";const u=JSON.parse('{"title":"多线程","description":"","frontmatter":{},"headers":[],"relativePath":"design/concurrent/thread.md","filePath":"design/concurrent/thread.md"}'),r={name:"design/concurrent/thread.md"};function n(o,a,s,p,c,d){return i(),t("div",null,[...a[0]||(a[0]=[l('<h1 id="多线程" tabindex="-1">多线程 <a class="header-anchor" href="#多线程" aria-label="Permalink to &quot;多线程&quot;">​</a></h1><p>多线程并发编程是充分利用现代处理器性能的重要课题。在此处我们暂不讨论内核态线程（运行在内核内部的线程，由内核直接管理，用户态无法访问），仅讨论用户态线程。</p><p>多个线程位于同一个进程中，共享进程的资源，例如：内存、网络等等；同时，让多个函数并行执行，提高程序的运算能力。其中，并发访问共享内存会导致出乎意料的程序错误，为此，必须谨慎处理，并使用一定的技巧。</p><h2 id="线程模型" tabindex="-1">线程模型 <a class="header-anchor" href="#线程模型" aria-label="Permalink to &quot;线程模型&quot;">​</a></h2><p>用户态的线程往往基于内核线程来进行封装。一个用户线程可以封装一个内核线程，或者多个用户态线程映射多个内核线程。</p><ul><li>一对一：经典封装，直接封装操作系统提供的线程进行使用</li><li>多对一：在使用单一系统线程的情况下，呈现并行假象，用于减少阻塞</li><li>多对多：M:N 模型，使用复杂的用户太调度器来极致压榨性能</li></ul><p>因此，用户态线程根据抽象层次可以分为：应用级线程和系统级线程。</p><p>一对一模型往往是系统级线程，在程序中创建的一个线程就是对一个系统线程的封装，而多对一和多对多的模型往往是应用级线程。我们使用的时候往往是一个应用级线程库调度的线程对象。</p><h2 id="系统级线程" tabindex="-1">系统级线程 <a class="header-anchor" href="#系统级线程" aria-label="Permalink to &quot;系统级线程&quot;">​</a></h2><p>系统级线程往往就是对系统调用的封装，一个应用中的线程对应的就是操作系统提供的线程，常见的系统级线程包括：</p><ul><li>C：posix thread 库</li><li>Java：标准库 Thread</li></ul><h2 id="应用级线程-纤程、协程" tabindex="-1">应用级线程（纤程、协程） <a class="header-anchor" href="#应用级线程-纤程、协程" aria-label="Permalink to &quot;应用级线程（纤程、协程）&quot;">​</a></h2><p>应用级线程是指完全由用户空间的线程库管理和调度的线程，与系统级线程不同，用户态线程的创建、销毁、同步和调度等操作都不需要内核的直接参与，因此具有更小的开销和更高的灵活性。用户态线程的切换只涉及用户空间的上下文切换，不会引发内核态切换，因此速度更快。纤程往往是多个实例共享一个底层的系统线程，让 CPU 能够充分使用，防止阻塞。</p><p>有栈（stack-based）：</p><ul><li>C: posix ucontext, M:1</li><li>Go: goroutine, M:N</li></ul><p>无栈（stack-free，基于状态机）：</p><ul><li>C#: async/await, M:N</li><li>Rust: async/await, M:N</li><li>JavaScript: async/await, M:1</li><li>Python: async/await, M:1</li></ul><p>用户态线程适合于大量并发、轻量级任务的场景，但由于内核并不感知用户态线程的存在，所以当一个用户态线程阻塞（如I/O操作）时，整个进程都会被阻塞，无法充分利用多核CPU资源。</p><p>在异步编程中，一个可以用户主动中断程序执行，并在未来的某个阶段从中断点恢复。并使用了 async/await 语法来封装跳转的动作，优化程序员的开发体验。</p><h3 id="有栈实现和无栈实现" tabindex="-1">有栈实现和无栈实现 <a class="header-anchor" href="#有栈实现和无栈实现" aria-label="Permalink to &quot;有栈实现和无栈实现&quot;">​</a></h3><p>有栈实现通过维护一个用户态的栈空间，模仿操作系统为线程抽象的一个栈空间，从而来模拟用户空间的线程，运行时将函数中的状态保存在栈上，在调用时一并使用栈空间中的状态，从而保存状态；</p><p>无栈实现使用更加激进的手段，将一个个 async 函数转化为一个同步的状态机函数和一个状态对象，状态对象中保存着当前函数运行到的中断点，同时并由外部调度器监听事件，并在合适的时机进行调度。</p>',22)])])}const _=e(r,[["render",n]]);export{u as __pageData,_ as default};
