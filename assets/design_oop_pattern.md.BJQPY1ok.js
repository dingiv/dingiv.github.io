import{_ as r,o as a,c as d,ah as e}from"./chunks/framework.BiR4sZ89.js";const c=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"design/oop/pattern.md","filePath":"design/oop/pattern.md"}'),o={name:"design/oop/pattern.md"};function n(s,t,i,l,h,g){return a(),d("div",null,[...t[0]||(t[0]=[e('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to “设计模式”">​</a></h1><p><strong>设计模式</strong>（Design Pattern）是指在<strong>软件设计</strong>中，对反复出现的问题提出的<strong>通用、可复用的解决方案</strong>。</p><p>它不是具体的代码片段，而是一种经过验证的<strong>设计模板</strong>或<strong>思路</strong>，可以根据具体场景进行调整和实现。</p><h3 id="核心定义-最简洁版" tabindex="-1">核心定义（最简洁版） <a class="header-anchor" href="#核心定义-最简洁版" aria-label="Permalink to “核心定义（最简洁版）”">​</a></h3><p>设计模式是<strong>软件开发中常见问题的典型解决方案</strong>，<br> 目的是让代码更<strong>易维护</strong>、<strong>易扩展</strong>、<strong>易理解</strong>、<strong>可复用</strong>。</p><h3 id="经典书籍中的权威表述-gof《设计模式》1994" tabindex="-1">经典书籍中的权威表述（GoF《设计模式》1994） <a class="header-anchor" href="#经典书籍中的权威表述-gof《设计模式》1994" aria-label="Permalink to “经典书籍中的权威表述（GoF《设计模式》1994）”">​</a></h3><p>“设计模式是为<strong>面向对象软件</strong>中<strong>反复出现的设计问题</strong>提供的一般<strong>可复用解决方案</strong>。”</p><h3 id="设计模式真正解决什么问题" tabindex="-1">设计模式真正解决什么问题？ <a class="header-anchor" href="#设计模式真正解决什么问题" aria-label="Permalink to “设计模式真正解决什么问题？”">​</a></h3><table tabindex="0"><thead><tr><th>问题类型</th><th>没有模式时的常见表现</th><th>使用模式后的收益</th></tr></thead><tbody><tr><td>对象创建复杂</td><td>到处new，硬编码类名</td><td>集中创建逻辑、延迟创建、动态选择实现</td></tr><tr><td>类之间强耦合</td><td>修改一个类要改十几个地方</td><td>通过接口、组合、委托解耦</td></tr><tr><td>算法/行为经常变化</td><td>if-else/switch 爆炸</td><td>策略、状态、命令、访问者等灵活切换</td></tr><tr><td>扩展新功能很痛苦</td><td>大量改动原有代码，容易引入 bug</td><td>开闭原则（对修改关闭，对扩展开放）</td></tr><tr><td>代码可读性差</td><td>别人看不懂你写的复杂逻辑</td><td>用模式名称就能快速传达意图</td></tr></tbody></table><h3 id="_23种经典设计模式-gof分类" tabindex="-1">23种经典设计模式（GoF分类） <a class="header-anchor" href="#_23种经典设计模式-gof分类" aria-label="Permalink to “23种经典设计模式（GoF分类）”">​</a></h3><table tabindex="0"><thead><tr><th>类别</th><th>数量</th><th>代表性模式</th><th>主要目的</th></tr></thead><tbody><tr><td>创建型</td><td>5</td><td>单例、工厂方法、抽象工厂、建造者、原型</td><td>控制对象的创建方式</td></tr><tr><td>结构型</td><td>7</td><td>适配器、桥接、组合、装饰、外观、享元、代理</td><td>处理类/对象之间的组合结构</td></tr><tr><td>行为型</td><td>11</td><td>观察者、策略、命令、状态、模板方法、责任链、访问者、中介者、迭代器、备忘录、解释器</td><td>处理类/对象之间的职责分配与通信</td></tr></tbody></table><h3 id="现代视角-2026年实际开发中最常用的" tabindex="-1">现代视角（2026年实际开发中最常用的） <a class="header-anchor" href="#现代视角-2026年实际开发中最常用的" aria-label="Permalink to “现代视角（2026年实际开发中最常用的）”">​</a></h3><ul><li><strong>最常写</strong>：单例、工厂（简单工厂+工厂方法）、观察者/发布-订阅、策略、装饰器、适配器、代理</li><li><strong>框架里大量使用</strong>：依赖注入（DI）容器本质上是工厂+策略+代理的组合</li><li><strong>微服务/分布式</strong>：熔断器、限流器、降级、负载均衡器、重试、幂等 → 很多也是模式思想的延伸</li><li><strong>前端</strong>：观察者（Vue/React响应式）、组合（组件树）、高阶组件（HOC）≈装饰器、状态机（XState）≈状态模式</li></ul><p>一句话总结：</p><p><strong>设计模式不是让你死记硬背23种写法，而是让你学会用最小的改动代价来应对变化。</strong></p><p>你现在是想：</p><ul><li>先理解某个具体模式（比如单例、工厂、观察者）？</li><li>看某个模式在真实项目里的应用场景？</li><li>还是想知道怎么判断“什么时候该用哪个模式”？</li></ul><p>直接告诉我下一步想聚焦哪个点。</p>',18)])])}const b=r(o,[["render",n]]);export{c as __pageData,b as default};
