import{_ as e,o as i,c as l,ah as r}from"./chunks/framework.BiR4sZ89.js";const m=JSON.parse('{"title":"内存管理","description":"","frontmatter":{},"headers":[],"relativePath":"basic/os/mm.md","filePath":"basic/os/mm.md"}'),t={name:"basic/os/mm.md"};function s(n,a,o,p,h,d){return i(),l("div",null,[...a[0]||(a[0]=[r('<h1 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to “内存管理”">​</a></h1><p>内存管理是操作系统最核心的功能之一，它负责管理计算机的物理内存和虚拟内存，为应用程序提供内存分配、保护和共享机制。现代操作系统的内存管理主要解决以下问题：</p><ul><li>内存分配和重定向：如何高效地为程序分配内存</li><li>内存保护和隔离：防止程序访问不属于自己的内存，防止程序之间相互干扰</li><li>内存共享：允许多个程序共享同一块内存</li><li>内存交换：使用磁盘存储临时内存，提供比内存条更大的地址空间</li></ul><h2 id="物理内存管理" tabindex="-1">物理内存管理 <a class="header-anchor" href="#物理内存管理" aria-label="Permalink to “物理内存管理”">​</a></h2><p>操作系统负责直接管理物理内存条的数据划分，保证物理内存的分配和释放。在分配和组织物理内存的过程中，往往使用一定的组织策略，其中主要有两种分配方式，分段方式和分页方式，现代的操作系统往往采用的分页方式。</p><h3 id="分页方式" tabindex="-1">分页方式 <a class="header-anchor" href="#分页方式" aria-label="Permalink to “分页方式”">​</a></h3><p>将物理内存和虚拟内存都划分为<strong>固定大小的内存分页</strong>，或者可以理解为一段连续的内存，通常大小为 <strong>4096</strong> 个字节，使用<strong>页表</strong>记录虚拟页到物理页的映射。分页方式没有外部碎片，内存利用率高，但页表会占用内存，并可能产生内部碎片。</p><h3 id="分段方式" tabindex="-1">分段方式 <a class="header-anchor" href="#分段方式" aria-label="Permalink to “分段方式”">​</a></h3><p>将程序分为多个逻辑段（如代码段、数据段、栈段等），每个段可以独立分配内存，并通过段表记录段的位置和大小。这种方式虽然符合程序的逻辑结构，但可能产生大量的外部碎片。</p><h2 id="虚拟内存管理" tabindex="-1">虚拟内存管理 <a class="header-anchor" href="#虚拟内存管理" aria-label="Permalink to “虚拟内存管理”">​</a></h2><p>为了实现的用户空间的进程的内存隔离性，同时，让应用程序无须在编写时考虑和操作具体的物理内存地址，应用程序使用的地址往往是虚拟内存地址。</p><p>程序通过操作系统提供的内存分配 API 向操作系统申请内存，操作系统去真实的物理内存条中获取空闲空间，并以一页一页的内存块为单位进行管理，操作系统通过页表记录</p><h2 id="内存优化技术" tabindex="-1">内存优化技术 <a class="header-anchor" href="#内存优化技术" aria-label="Permalink to “内存优化技术”">​</a></h2><ul><li><p>内存交换 内存交换是内存管理的重要技术，它通过将部分内存内容暂时存储到磁盘上，为程序提供比物理内存更大的地址空间。当物理内存不足时，系统需要将某些页面换出到磁盘，这个过程由页面置换算法控制。</p><p>页面置换算法主要有三种实现方式。最近最少使用（LRU）算法淘汰最长时间未使用的页面，虽然需要记录页面的使用时间，实现较为复杂，但效果最好。先进先出（FIFO）算法则简单地淘汰最早进入内存的页面，实现简单但效果一般，且不考虑页面的使用频率。时钟算法使用引用位记录页面是否被访问，通过循环检查页面来淘汰未被访问的页面，这是 LRU 的近似实现，效果较好。</p></li><li><p>内存映射 内存映射技术允许将文件直接映射到进程的地址空间，这样程序可以像使用内存一样来读写文件，并且可以加快文件读写的速度。文件映射将文件内容映射到内存，支持按需加载，允许多个进程共享同一文件映射。匿名映射则创建与文件无关的内存映射，主要用于进程间共享内存，支持大块内存分配。</p></li><li><p>内存保护 内存保护机制确保程序只能访问其被允许的内存区域，程序之间通过进程这个抽象被隔离了。通过页表权限位，系统可以控制内存的读/写/执行权限，区分用户模式和内核模式，这些功能通过硬件 MMU 实现。地址空间隔离则为每个进程提供独立的虚拟地址空间，防止进程间相互干扰，提高系统安全性。</p></li><li><p>内存压缩技术，通过压缩不常用的内存页面，减少页面换出到磁盘的频率，提高内存利用率。</p></li><li><p>使用大页，支持使用更大的页面大小（如 2MB、1GB），减少页表项数量，提高 TLB 命中率。</p></li><li><p>内存池技术，预分配固定大小的内存块，减少内存分配和释放的开销，避免内存碎片。</p></li><li><p>内存预取，通过预测程序可能访问的内存，提前将数据加载到内存，减少页面错误。</p></li></ul>',14)])])}const _=e(t,[["render",s]]);export{m as __pageData,_ as default};
