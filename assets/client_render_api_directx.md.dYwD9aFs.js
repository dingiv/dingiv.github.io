import{_ as i,o as a,c as n,ah as l}from"./chunks/framework.BvDvRtye.js";const g=JSON.parse('{"title":"DirectX","description":"","frontmatter":{"title":"DirectX","order":20},"headers":[],"relativePath":"client/render/api/directx.md","filePath":"client/render/api/directx.md"}'),t={name:"client/render/api/directx.md"};function e(h,s,p,k,r,E){return a(),n("div",null,[...s[0]||(s[0]=[l(`<h1 id="hlsl" tabindex="-1">HLSL <a class="header-anchor" href="#hlsl" aria-label="Permalink to “HLSL”">​</a></h1><p>High-Level Shading Language（HLSL）是微软 DirectX 图形 API 的标准着色语言，用于编写 Windows 平台的游戏和图形应用。HLSL 语法基于 C++，支持模板、运算符重载、命名空间等高级特性，在游戏开发领域占据主导地位。</p><p>HLSL 与 DirectX 的深度集成是其核心竞争力。着色器通过 HLSL 编译为字节码（DXBC 或 DXIL），与应用一起分发，无需在运行时编译，消除了启动时的卡顿。DirectX 的调试工具（PIX、Visual Studio Graphics Debugger）对着色器提供了强大支持，可单步执行、检查变量、查看 GPU 状态。HLSL 也是 Xbox 和 Windows 的统一图形语言，跨平台游戏可共享着色器代码。</p><h2 id="着色器模型" tabindex="-1">着色器模型 <a class="header-anchor" href="#着色器模型" aria-label="Permalink to “着色器模型”">​</a></h2><p>HLSL 的着色器模型（Shader Model）版本控制机制确保了硬件兼容性。每个 SM 版本对应一组 GPU 功能和指令集，开发者可在着色器中指定最低版本要求。SM 2.0 支持 DirectX 9.0c，包含基本的顶点和像素着色器。SM 3.0 增加动态流控制，支持更复杂的算法。SM 4.0 引入几何着色器，支持整数运算和纹理数组。SM 5.0 支持 DirectX 11，增加曲面细分着色器和计算着色器。SM 6.0+ 支持 DirectX 12，增加波前操作、射线追踪等高级特性。</p><p>着色器模型通过着色器编译目标指定。例如 <code>#pragma target 5.0</code> 声明着色器需要 SM 5.0 支持。如果硬件不支持，编译器会报错或驱动会拒绝创建着色器。这种机制避免了运行时崩溃，但也增加了复杂性：开发者需要为不同硬件级别编写多个着色器版本，或在运行时选择合适的着色器。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// DirectX 11 特性：纹理数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture2DArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> texArray : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t0);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SamplerState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> samplerState : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s0);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PSMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(VSOutput input) : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SV_Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> texArray.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(samplerState, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input.uv, input.slice));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="基础语法" tabindex="-1">基础语法 <a class="header-anchor" href="#基础语法" aria-label="Permalink to “基础语法”">​</a></h2><p>HLSL 的变量声明类似 C++，但增加了语义（Semantic）和寄存器绑定。语义将变量连接到管线阶段，如 <code>POSITION</code>（顶点位置）、<code>NORMAL</code>（法向量）、<code>TEXCOORD</code>（纹理坐标）、<code>SV_Target</code>（渲染目标输出）。寄存器绑定将变量分配到硬件资源槽，如 <code>register(t0)</code> 绑定到纹理寄存器 0，<code>register(b0)</code> 绑定到常量缓冲区 0。这种显式绑定使得着色器与应用的数据交换清晰明确。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 常量缓冲区</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">cbuffer</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ConstantBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b0) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> modelMatrix;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewMatrix;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projectionMatrix;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 顶点着色器输入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VSInput {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">POSITION</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normal : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NORMAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXCOORD0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 顶点着色器输出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VSOutput {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SV_POSITION</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normal : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NORMAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXCOORD0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VSOutput </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VSMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(VSInput input) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    VSOutput output;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worldPos = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input.position, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), modelMatrix);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output.position = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(worldPos, viewMatrix);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output.position = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output.position, projectionMatrix);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output.normal = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input.normal, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float3x3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)modelMatrix);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output.uv = input.uv;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>HLSL 支持函数重载和模板，提供了比 GLSL 更强大的抽象能力。<code>max()</code> 函数可接受 int、float、向量等不同类型的参数，编译器自动生成适当的版本。模板函数可编写通用算法，如向量加法可同时支持 vec2、vec3、vec4。这种类型安全机制减少了运行时错误，但编译时间可能增加。</p><h2 id="缓冲区资源" tabindex="-1">缓冲区资源 <a class="header-anchor" href="#缓冲区资源" aria-label="Permalink to “缓冲区资源”">​</a></h2><p>HLSL 提供多种缓冲区类型，用于在应用和着色器间传递数据。常量缓冲区（Constant Buffer，cbuffer）用于频繁更新的少量数据（变换矩阵、材质参数），大小限制为 64KB（硬件限制），适合每帧更新。纹理缓冲区（Texture Buffer，tbuffer）是常量缓冲区的纹理版本，可通过纹理采样器访问，支持随机读取。</p><p>结构化缓冲区（Structured Buffer）是 DX10+ 引入的通用缓冲区，可存储任意结构体数组，支持随机读取和写入。追加缓冲区（Append Buffer）和消费缓冲区（Consume Buffer）支持原子操作，用于粒子系统等无序数据流。读写缓冲区（RWStructuredBuffer）支持原子操作和线程间同步，是计算着色器的核心数据结构。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 结构化缓冲区</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Particle {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> velocity;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> life;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StructuredBuffer&lt;Particle&gt; inputParticles : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t0);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RWStructuredBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;Particle&gt; outputParticles : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u0);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CSMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DTid : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SV_DispatchThreadID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Particle p = inputParticles[DTid.x];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p.position += p.velocity * deltaTime;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p.life -= deltaTime;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outputParticles[DTid.x] = p;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="纹理采样" tabindex="-1">纹理采样 <a class="header-anchor" href="#纹理采样" aria-label="Permalink to “纹理采样”">​</a></h2><p>HLSL 的纹理系统比 GLSL 更灵活，支持纹理数组的多维资源。Texture2D、Texture3D、TextureCube 等类型对应不同的纹理维度，Texture2DArray 支持纹理数组（常用于地形切片、立方体阴影贴图）。SamplerState 定义采样模式（滤波、包裹、边界），可与纹理分离绑定，实现一个采样器用于多个纹理。</p><p>纹理采样方法包括 Sample（标准采样，自动应用 mipmap 和滤波）、SampleLevel（显式指定 mipmap 层级）、SampleGrad（显式指定导数，手动计算 mipmap）、Load（直接读取纹素，无滤波）。计算着色器常用 Load 进行精确访问，图形着色器常用 Sample 获得平滑结果。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diffuseTexture : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t0);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalTexture : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> roughnessTexture : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t2);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TextureCube</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> environmentTexture : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t3);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SamplerState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> samplerState : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s0);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PSMain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(VSOutput input) : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SV_Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 标准采样</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diffuse = diffuseTexture.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(samplerState, input.uv);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 法线贴图采样</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normal = normalTexture.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(samplerState, input.uv).rgb;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    normal = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(normal * </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 环境反射采样</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reflectDir = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(-viewDir, normal);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> environment = environmentTexture.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(samplerState, reflectDir).rgb;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diffuse.rgb * environment, diffuse.a);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="hlsl-与-fxc-dxc" tabindex="-1">HLSL 与 FXC/DXC <a class="header-anchor" href="#hlsl-与-fxc-dxc" aria-label="Permalink to “HLSL 与 FXC/DXC”">​</a></h2><p>HLSL 的编译器有两个：FXC（Legacy 编译器）和 DXC（现代编译器）。FXC 用于 DirectX 9-11，生成 DXBC 字节码，功能成熟但不再更新。DXC 基于 LLVM，用于 DirectX 12 和 SPIR-V 生成，支持最新的 HLSL 特性（SM 6.0+）和更好的优化。选择哪个编译器取决于目标平台：DirectX 11 可用 FXC 或 DXC，DirectX 12 必须用 DXC，Vulkan 需要用 DXC 生成 SPIR-V。</p><p>编译命令行工具分别是 <code>fxc.exe</code> 和 <code>dxc.exe</code>。Visual Studio 内置了这两个编译器，可通过项目配置自动编译着色器。编译选项包括优化级别（/O0-O3）、调试信息（/Zi）、着色器模型（/target sm_5_0）、输出文件名（/Fo）。编译错误和警告会显示在输出窗口，点击可跳转到对应行。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译命令示例</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fxc.exe /T ps_5_0 /E PSMain /Fo pixelShader.cso pixelShader.hlsl</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dxc.exe -T ps_6_0 -E PSMain -Fo pixelShader.cso pixelShader.hlsl</span></span></code></pre></div><p>运行时加载着色器使用 D3DReadFileToBlob 读取编译后的字节码，然后调用 CreateVertexShader/CreatePixelShader 创建着色器对象。这种预编译模式避免了运行时编译开销，但需要维护多个字节码文件（顶点、像素、几何、曲面细分、计算）。DirectX 12 的根签名系统进一步简化了资源绑定，着色器可在 HLSL 中声明根签名，与应用自动同步。</p><h2 id="directx-12-特性" tabindex="-1">DirectX 12 特性 <a class="header-anchor" href="#directx-12-特性" aria-label="Permalink to “DirectX 12 特性”">​</a></h2><p>DirectX 12 引入了波前操作（Wave Intrinsics），允许着色器访问 SIMD 群内的线程。WaveGetLaneCount 返回波的大小（通常 32 或 64），WaveGetLaneIndex 返回当前线程在波内的索引。WaveActiveAnyTrue、WaveActiveAllTrue 检测波内是否有线程满足条件，WaveActiveSum、WaveActiveMax 计算波内线程的聚合值。这些操作可用于优化算法（减少原子操作、实现快速前缀和）。</p><p>射线追踪（Ray Tracing）是 DirectX 12 的重要特性，通过 Raytracing Shaders 实现。RayGeneration Shader 发射射线，Intersection Shader 计算射线与几何的交点，AnyHit Shader 检测射线是否击中几何，ClosestHit Shader 处理最近的交点，Miss Shader 处理未击中的情况。射线追踪需要硬件支持（RT Core），可实现真实反射、阴影、全局光照等效果。</p><div class="language-hlsl"><button title="Copy Code" class="copy"></button><span class="lang">hlsl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 射线生成着色器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RaytracingShaderConfig MyConfig = {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// max payload size</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // max attribute size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;raygeneration&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RayGen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uv = (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DispatchThreadID.xy) + </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) / ViewDimensions;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> origin = CameraPosition;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> direction = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv.x * CameraRight + uv.y * CameraUp + CameraForward);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RayDesc ray;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ray.Origin = origin;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ray.Direction = direction;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ray.TMin = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ray.TMax = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TraceRay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Output[DispatchThreadID.xy] = color;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>网格着色器（Mesh Shader）是 DirectX 12 的另一种新特性，取代了传统的顶点/几何着色器流程。网格着色器直接生成图元（点、线、三角形），可动态改变几何拓扑，实现更灵活的几何处理。放大着色器（Amplification Shader）可启动多个网格着色器实例，用于细分和剔除。这种新的几何管线比曲面细分更高效，适合复杂几何和程序化生成。</p><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to “性能优化”">​</a></h2><p>HLSL 的性能优化原则与 GLSL 类似，但有一些 DirectX 特定的技巧。使用 <code>flattens</code> 和 <code>branch</code> 属性控制分支编译，<code>[flatten]</code> 将 if-else 编译为条件移动（无分支开销），<code>[branch]</code> 保留分支（适合 if 的一个分支总是成立的情况）。使用 <code>groupshared</code> 内存共享线程组内数据，减少全局内存访问。使用 <code>WaveActiveMax</code> 等波前操作代替原子操作，提升性能。</p><p>早期深度测试（Early-Z）是重要的优化，在片段着色器前执行深度测试，剔除被遮挡的片段。确保着色器不修改深度（<code>earlydepthstencil</code> 属性），驱动会自动启用 Early-Z。对于 Alpha 测试，使用 <code>clip()</code> 或 <code>discard</code> 会禁用 Early-Z，可考虑用 Alpha-to-Coverage 或预乘 Alpha 替代。</p><p>性能分析工具包括 PIX（微软官方）、RenderDoc（开源）、Nsight（NVIDIA）、Radeon GPU Profiler（AMD）。这些工具可捕获帧并分析着色器执行时间、资源使用、管线状态。PIX 的调试器支持单步执行着色器、检查变量值、查看 GPU 内存。优化应基于实际测量，热点分析（profiling）比猜测更可靠。</p><h2 id="与-glsl-的差异" tabindex="-1">与 GLSL 的差异 <a class="header-anchor" href="#与-glsl-的差异" aria-label="Permalink to “与 GLSL 的差异”">​</a></h2><p>HLSL 与 GLSL 的语法类似，但有一些重要差异。HLSL 使用 <code>mul(向量, 矩阵)</code>，GLSL 使用 <code>矩阵 * 向量</code>（HLSL 是行向量，GLSL 是列向量）。HLSL 的矩阵是行主序（row-major），GLSL 是列主序（column-major），需要在应用中正确设置转置。HLSL 的 <code>Texture2D::Sample()</code> 对应 GLSL 的 <code>texture()</code>，参数顺序相同。HLSL 的 <code>SV_Position</code> 对应 GLSL 的 <code>gl_Position</code>，系统值都用 <code>SV_</code> 前缀。</p><p>SPIR-V Cross、glslang 等工具可实现 HLSL 与 GLSL 的互相转换。跨平台引擎（如 Unreal、Unity）通常用 HLSL 作为主语言，然后转换为其他平台的着色器语言。这种策略减少了维护成本，但也限制了平台特定特性的使用。</p>`,36)])])}const c=i(t,[["render",e]]);export{g as __pageData,c as default};
