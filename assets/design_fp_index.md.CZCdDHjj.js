import{_ as s,c as a,o as n,ae as l}from"./chunks/framework.CDjunVez.js";const E=JSON.parse('{"title":"函数式","description":"","frontmatter":{"title":"函数式","order":20},"headers":[],"relativePath":"design/fp/index.md","filePath":"design/fp/index.md"}'),t={name:"design/fp/index.md"};function e(h,i,p,r,k,o){return n(),a("div",null,[...i[0]||(i[0]=[l(`<h1 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to &quot;函数式编程&quot;">​</a></h1><p>函数式编程是一种编程范式，它将程序视为数学函数对输入数据的评估从而产生输出的过程。并强调使用纯函数、不可变数据、高阶函数和函数组合等概念。</p><h2 id="函数式编程的四个概念" tabindex="-1">函数式编程的四个概念 <a class="header-anchor" href="#函数式编程的四个概念" aria-label="Permalink to &quot;函数式编程的四个概念&quot;">​</a></h2><p>函数式的世界中，有四个基本概念：常量、纯函数、变量、脏函数。要区分这四个概念，需要先理解生命周期和作用域。</p><ul><li>生命周期：在程序运行期间，一个对象或者数据从创建到销毁的那一段时间。创建 -&gt; 读取* n / 更新* n -&gt; 销毁，（6 个 hook）。常量只会经历创建、读取和销毁，而变量会经历更新。</li><li>作用域：全局作用域和局部作用域，全局作用域对程序的所有部分可见，生命周期贯穿整个程序运行期间，一次程序运行期间只会被展开一次，由此导致了其作用域中的状态只能经历一次创建和销毁；局部作用域对某个部分的程序和代码可见。</li><li>所有权：状态具有所有权归属，往往是声明这个状态的最近一级作用域拥有其所有权。作用域需要资源的释放。</li><li>副作用：一个函数在运行的时候，与外界发生了交互，对外界产生了影响。</li></ul><p>函数式要求，对变量做出限制：</p><ol><li>尽量多地使用常量，而不是变量；更不要使用全局变量，只有常量才能全局；但是常量不允许改变，如何解决这个问题，那就销毁它，再创建一个新的；</li><li>函数应当是纯的；</li></ol><h3 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h3><p>常量是指一经创建就不再改变值的量，常量具有<strong>可确定性</strong>，常量是可复用的，常量是可组合的，所以往往可以被放置在全局作用域中，拥有广泛的可见性和较长的生命周期。</p><h3 id="纯函数" tabindex="-1">纯函数 <a class="header-anchor" href="#纯函数" aria-label="Permalink to &quot;纯函数&quot;">​</a></h3><p>纯函数是指接受一些输入，并在进行一些计算处理后，返回一定的输出的这一程序过程。相较于普通的函数，纯函数的输入和输出是一一对应的，纯函数的输出只依赖于输入，纯函数的输出不会受到外部状态的影响。纯函数是函数式编程的核心，具有纯洁性、可复用性、可组合性、可测试性、较高的可维护性，因此它往往可以被放置在全局作用域中，拥有广泛的可见性和较长的生命周期。</p><p>纯函数的优势：</p><ul><li>可确定性：具有可控的行为和确定的输入输出；这使得程序员可以轻松地理解和预测纯函数的行为，便于使用和维护；</li><li>可测试性：不依赖于外界环境，可以方便地测试；而脏函数，在测试前需要对环境进行初始化，测试后需要对环境进行清理，增加了测试的复杂度；</li><li>可移植性和可复用性：不依赖外界环境，可以轻松移植到不同的平台，这里说的外界环境，包括全局变量、IO操作、网络请求等常见的程序操作；同时，由于依赖少，可以轻松地被复用，减少了代码的重复性；</li><li>可重入性和可并行性：不会改变外部状态，可以随意并行，简化了<strong>多线程编程</strong>的难度；同时，可重入性，带来了<strong>响应式编程</strong>的便利性，因为要无痛响应，保持函数行为的可控是一个重要前提；</li><li>可缓存性：可以轻松进行缓存，主要用于耗时任务，加快程序的速度；</li></ul><h3 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h3><p>变量是相对于常量而言的。变量拥有<strong>不确定性</strong>，变量拥有 update 生命周期。在函数式编程中，变量也被称为状态。在大型的应用程序中，程序的复杂性往往因为变量的不可控而大大增加。</p><ul><li>一方面，当我们需要对变量进行某一个操作时，由于变量的不确定性，我们就需要校验变量的合法性，然后才能操作。当一个程序依赖多个变量的时候，校验的复杂度就会飙升，而如果当多个程序模块共享一些变量的时候，在每一个模块当中都需要重复进行校验。</li><li>另一方面，如果变量之间存在依赖关系，那么，当一个或多个变量发生变化时，同步依赖于它的变量是一个复杂而繁琐的问题，同时可能会引入<strong>多线程编程</strong>的<strong>资源竞争</strong>问题。</li></ul><p>因此，应当让变量的生命周期尽量减短，限制其作用域，从而降低程序复杂度，保证程序的可维护性。对于第二个方面，可以使用<strong>响应式编程</strong>来解决。</p><h3 id="脏函数" tabindex="-1">脏函数 <a class="header-anchor" href="#脏函数" aria-label="Permalink to &quot;脏函数&quot;">​</a></h3><p>脏函数是相对于纯函数而言的。如果一个函数与外界发生了交互，造成了一些意想不到的影响，那么这个函数就是一个脏函数，也可以被称为<strong>副作用</strong>。一个函数可能因为以下途径产生副作用：</p><ol><li>函数直接依赖或引用了<strong>外部作用域中的变量</strong>，从而形成了隐式参数；</li><li>函数通过传入的参数指针修改了指针指向的数据，从而对其参数进行了修改；</li><li>函数执行了 IO 操作，如读写文件、网络请求等，其本质是修改外界数据的状态；</li><li>调用了其他脏函数（脏函数的传染性）；</li></ol><blockquote><h4 id="js-中的隐性副作用" tabindex="-1">JS 中的隐性副作用 <a class="header-anchor" href="#js-中的隐性副作用" aria-label="Permalink to &quot;JS 中的隐性副作用&quot;">​</a></h4><p>除去一些常见的副作用，JS 中有一些隐性副作用可能会被忽略，如：</p><ol><li><code>async/await</code> 和 Promise 的使用；</li><li><code>setTimeout</code>、<code>setInterval</code> 的使用；</li><li><code>Math.random()</code> 和 <code>Date.now()</code> 的使用；</li><li><code>console.log()</code> 的使用；</li><li>多数 Web API 的使用；</li><li>......</li></ol></blockquote><p>总结下来：主要有三种脏函数：1、隐参函数；2、写参函数；3、IO 函数。</p><h2 id="纯函数和函数组合" tabindex="-1">纯函数和函数组合 <a class="header-anchor" href="#纯函数和函数组合" aria-label="Permalink to &quot;纯函数和函数组合&quot;">​</a></h2><p><strong>函数组合</strong>是指将多个函数组合成一个函数，从而获得更复杂的功能。语言支持<strong>高阶函数</strong>是实现组合的前提。函数组合是函数式编程中的核心概念，组合可以对多个函数进行创建、增强、pipe、柯里化等，将多个简单的函数组合成一个更大的函数，从而实现更复杂的逻辑。</p><p>组合往往是针对于纯函数而言的，对于脏函数而言，组合的意义被大大削减，因为脏函数的副作用会限制其通用性。</p><blockquote><p>函数组合的概念区分于面向对象中的组合。面向对象中的组合是指一个类实现了多个原子化的接口，从而组合了多种<strong>能力</strong>，以达到程序的复用性。同时，解决了多继承的菱形继承问题和普通继承的代码粒度问题。</p></blockquote><h3 id="高阶函数" tabindex="-1">高阶函数 <a class="header-anchor" href="#高阶函数" aria-label="Permalink to &quot;高阶函数&quot;">​</a></h3><p>高阶函数是指至少满足以下条件之一的函数：</p><ol><li>接受一个或多个函数作为参数；</li><li>返回一个函数；</li></ol><p>高阶函数是一种强大的语言特性，在支持高阶函数的语言中，它允许我们以函数作为一等公民，从而实现函数的抽象、复用、组合等操作。高阶函数是函数式编程的核心概念，它使得函数式编程具有更高的抽象层次和更强的表达能力。</p><h3 id="多元函数" tabindex="-1">多元函数 <a class="header-anchor" href="#多元函数" aria-label="Permalink to &quot;多元函数&quot;">​</a></h3><p>函数根据参数的个数可以分成一元函数、高阶一元函数、二元函数、高阶二元函数等等。</p><p>在函数式编程中，一元函数具有特殊的地位。对于一元函数，我们可以简单地将一个参数的结果传入另一个函数中，这样依次调用，从而形成一个像流水线一样的结构，让程序的逻辑变得有条理。这是纯函数的重要表现形式，一个纯函数往往被看作是一个透明的管道，只对传入的数据做加工处理，简单而清晰地呈现出数据流。这是一个最为理想和纯粹的函数式编程模型，使用起来最为简单。</p><p>二元函数具有可利用的特殊性质。二元函数再固定一个参数位就是一元函数，即二元函数可以看作是一个具有一个额外依赖的一元函数，这让二元函数可以在绑定完了依赖之后，转变成一个一元函数。主要有两种方式，1.面向对象的方法调用语法 <code>.</code>，2.闭包和柯里化，指定参数并延迟调用。</p><p>组合或者 pipe 的写法由链式调用和使用高阶多元函数 compose 或者 pipeline 来完成，compose 从右往左调用，pipeline 从左往右调用。</p><h2 id="变量和状态管理" tabindex="-1"><a href="./state">变量和状态管理</a> <a class="header-anchor" href="#变量和状态管理" aria-label="Permalink to &quot;[变量和状态管理](./state)&quot;">​</a></h2><p>对于变量而言，我们无法避免其副作用，但是我们可以通过一些手段来减少副作用的影响范围，从而降低程序复杂度，保证程序的可维护性。状态管理就是致力于解决这个问题。</p><h2 id="脏函数和副作用" tabindex="-1">脏函数和副作用 <a class="header-anchor" href="#脏函数和副作用" aria-label="Permalink to &quot;脏函数和副作用&quot;">​</a></h2><p>在程序设计中，我们无法完全避免副作用，但是我们可以通过一些手段来减少副作用的影响范围，从而降低程序复杂度，保证程序的可维护性。一般地，一个程序的入口函数 main 就是一个脏函数，它接受一些输入，然后调用一些函数，最后输出一些结果。一个程序最纯的结果，就是除了 main 函数是脏函数，其他函数都是纯函数。</p><h3 id="脏函数的延迟执行" tabindex="-1">脏函数的延迟执行 <a class="header-anchor" href="#脏函数的延迟执行" aria-label="Permalink to &quot;脏函数的延迟执行&quot;">​</a></h3><p>脏函数在不被调用之前都可以认为是无害的，但是直到它被调用之后，那么副作用产生，对于函数式的编程而言，不是要完全没有副作用，而是要把副作用局限在一个很小的范围内，或者将副作用的发生延迟到尽可能后期，最迟是在用户输入数据（前端）或者对外界进行访问（后端）的时候，这个时候发生的副作用是无可避免的。我们可以采用<strong>惰性求值</strong>和<strong>声明式副作用</strong>来延迟副作用的发生。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Dirty</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Pure</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, env.encoding);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReadAction</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 read 这个 IO 动作抽象为一个数据结构或者可以说是配置，使用纯函数定义配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: path,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    encoding : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用接受某种配置，然后执行一个 IO 操作的执行器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> executeAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action.path, action.encoding);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="脏函数的可原谅性" tabindex="-1">脏函数的可原谅性 <a class="header-anchor" href="#脏函数的可原谅性" aria-label="Permalink to &quot;脏函数的可原谅性&quot;">​</a></h3><p>在实际的开发中，我们无法完全避免副作用，但是我们可以选择原谅一些副作用，从而获得更高的开发自由度，如：</p><ol><li><strong>私有闭包</strong>，一个<strong>闭包函数</strong>独享了一个外部变量，这个外部变量除了这个函数，其他函数都不能访问。可以认为这个外部变量是函数私有的，这个副作用是可原谅的；典型例子：随机数生成器、节流函数、单例函数、函数缓存；在 JS 中，由于是单线程的，所以私有闭包不需要考虑并发问题；</li><li><strong>局部变量</strong>，如果一个函数在内部创建了一个变量，即拥有一个变量的<strong>创造权</strong>，可以认为这是在<strong>初始化</strong>阶段，那么在函数的内部修改该变量或者调用<strong>写参函数</strong>修改它，不会被传染；</li><li><strong>独立 IO</strong>，在函数中，调用了一些独立性较强的 IO 模块，这些模块对程序的主体功能没有直接影响，并且不会抛出错误，如日志打印、调试信息等，这些方法往往独立于程序的主体逻辑，不容易增加程序的逻辑复杂度，这些副作用是可原谅的；</li></ol><h2 id="其他概念" tabindex="-1">其他概念 <a class="header-anchor" href="#其他概念" aria-label="Permalink to &quot;其他概念&quot;">​</a></h2><ul><li>高阶函数：以函数为参数或返回值的函数</li><li>一元函数：只有一个参数和一个返回值的函数叫做一元函数</li><li>纯函数：运行之后不产生副作用的函数，它具有与传入的参数一一对应的可预期的返回值，甚至更纯——不依赖于外界的变量。</li><li>柯里化：将一个多元函数转化为一个返回可连续调用的一元函数</li><li>组合：将多个函数转化为一个组合功能的函数。compose/pipeline，compose将函数从右至左调用，pipeline从左至右调用</li><li>Point-Free：函数组合。使用各个小功能的函数组合形成更大更复杂的一个函数，直到需要输入之前，我们不关心具体需要处理的数据。</li><li>声明式：尽量只声明变量，而不是去修改已有的数据</li><li>不可变：数据一但被创建就不应被改变，并且如果是一个复杂类型，那么其内部的属性也应该是不可变的。</li></ul>`,47)])])}const c=s(t,[["render",e]]);export{E as __pageData,c as default};
