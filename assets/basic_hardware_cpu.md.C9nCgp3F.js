import{_ as i,c as l,o as e,ae as r}from"./chunks/framework.BQlYxExx.js";const d=JSON.parse('{"title":"CPU","description":"","frontmatter":{},"headers":[],"relativePath":"basic/hardware/cpu.md","filePath":"basic/hardware/cpu.md"}'),t={name:"basic/hardware/cpu.md"};function o(n,a,s,c,h,p){return e(),l("div",null,[...a[0]||(a[0]=[r('<h1 id="cpu" tabindex="-1">CPU <a class="header-anchor" href="#cpu" aria-label="Permalink to &quot;CPU&quot;">​</a></h1><p>CPU 的基本组成包括运算逻辑单元（ALU）、控制单元、寄存器组、缓存（Cache）等。其核心任务是从内存中获取指令，进行译码、执行，并将结果写回寄存器或内存。</p><h2 id="逻辑门和-alu" tabindex="-1">逻辑门和 ALU <a class="header-anchor" href="#逻辑门和-alu" aria-label="Permalink to &quot;逻辑门和 ALU&quot;">​</a></h2><p>CPU 的工作原理基于<strong>数字电路与时序逻辑</strong>理论，使用<strong>逻辑门</strong>（Logic Gate）电路作为基本单元，用于实现与（AND）、或（OR）、非（NOT）等基本逻辑运算，通过输入一组电平信号，然后输出一个处理后的结果电平信号，从而实现处理数据的能力。CPU 内部由大量逻辑门组成，构建出更复杂的电路模块。</p><p><strong>算术逻辑单元（ALU, Arithmetic Logic Unit）</strong> 是 CPU 的核心部件之一，负责执行算术运算（如加减乘除）和逻辑运算（如与、或、非、异或等）。ALU 通常与寄存器组协作，完成数据的读取、运算和结果存储。</p><ul><li>典型 ALU 支持的操作包括：加法、减法、与、或、非、异或、移位等。</li><li>ALU 的性能直接影响 CPU 的整体运算能力。</li></ul><h2 id="指令集" tabindex="-1">指令集 <a class="header-anchor" href="#指令集" aria-label="Permalink to &quot;指令集&quot;">​</a></h2><p>指令是 CPU 能够支持的作为输入的电平信号，根据不同的电平信号，CPU 执行不同的任务。CPU 越是复杂，支持的指令往往就越多。</p><p>指令集架构（ISA, Instruction Set Architecture）定义了 CPU 能够识别和执行的机器指令集合，是硬件与软件之间的接口。为了减少上层软件的变动，避免因为下层硬件的改动而使得软件重写，软硬件之间规定了一批固定的指令，软件只需调用指令，而无须关注下层硬件实现；而只要硬件提供的上层接口不变，其内部便可以自由设计和变动，并且让上层无感。</p><p>常见的指令集：</p><ul><li>x86：由 Intel 推出的复杂指令集（CISC），广泛应用于 PC 和服务器领域，兼容性强，指令丰富。</li><li>ARM：精简指令集（RISC），以高能效著称，广泛应用于移动设备、嵌入式系统和物联网。</li><li>RISC-V：开源的精简指令集架构，模块化设计，便于扩展，逐渐在学术和工业界获得关注。</li></ul><p>每种指令集都有自己的指令格式、寻址方式和扩展特性。软件编译器需针对不同 ISA 生成对应的机器码。</p><h2 id="流水线" tabindex="-1">流水线 <a class="header-anchor" href="#流水线" aria-label="Permalink to &quot;流水线&quot;">​</a></h2><p>在硬件的内部，实现各个指令往往需要多个步骤，引入了较多的优化和设计机制。</p><p>流水线（Pipeline）是将指令的执行过程分为若干阶段（如取指、译码、执行、访存、写回），各阶段可并行处理不同指令，从而提升指令吞吐量。</p><ul><li>典型五级流水线：取指（IF）、译码（ID）、执行（EX）、访存（MEM）、写回（WB）。</li><li>优点：提高了 CPU 的并行度和资源利用率。</li><li>缺点：存在流水线冒险（数据冒险、结构冒险、控制冒险）等问题，需要通过转发、插入气泡、分支预测等机制解决。</li></ul><h3 id="分支预测" tabindex="-1">分支预测 <a class="header-anchor" href="#分支预测" aria-label="Permalink to &quot;分支预测&quot;">​</a></h3><p>分支预测（Branch Prediction）用于减少流水线因分支指令（如 if/else、循环跳转）带来的停顿。</p><ul><li>通过硬件分支预测器预测分支结果，提前加载和执行后续指令。</li><li>预测正确则流水线不中断，预测失败则需要清空流水线并重新取指，带来性能损失。</li><li>现代 CPU 采用动态分支预测（如二位饱和计数器、全局历史表等）提升预测准确率。</li></ul><h3 id="乱序执行" tabindex="-1">乱序执行 <a class="header-anchor" href="#乱序执行" aria-label="Permalink to &quot;乱序执行&quot;">​</a></h3><p>乱序执行（Out-of-Order Execution）是指 CPU 不严格按照程序顺序执行指令，而是根据数据依赖和资源可用性动态调整执行顺序。</p><ul><li>通过乱序调度单元、重排序缓冲区（ROB）、寄存器重命名等机制实现。</li><li>优点：隐藏指令间的延迟，提高指令级并行度。</li><li>缺点：硬件实现复杂，需要保证最终执行结果与顺序执行一致（乱序执行的等价性）。</li></ul><h3 id="超标量" tabindex="-1">超标量 <a class="header-anchor" href="#超标量" aria-label="Permalink to &quot;超标量&quot;">​</a></h3><p>超标量（Superscalar）架构允许 CPU 在一个时钟周期内同时发射和执行多条指令，依赖于多个执行单元（如多个 ALU、FPU）。</p><ul><li>通过指令调度和乱序执行，最大化硬件资源利用。</li><li>现代高性能 CPU 通常具备 2~4 发射宽度（即每周期可发射 2~4 条指令）。</li></ul><h2 id="cpu权限级别" tabindex="-1">CPU权限级别 <a class="header-anchor" href="#cpu权限级别" aria-label="Permalink to &quot;CPU权限级别&quot;">​</a></h2><p>现代 CPU 通常采用多级权限环（Protection Ring）机制，保障系统安全和稳定运行。</p><ul><li><strong>ring0</strong>：最高权限，操作系统内核态，能直接访问所有硬件资源。</li><li><strong>ring1/2</strong>：中间权限，部分操作系统或驱动程序使用（现代主流 OS 很少用）。</li><li><strong>ring3</strong>：最低权限，用户态，普通应用程序运行，不能直接访问硬件，需通过系统调用与内核交互。</li></ul><p>这种分级机制防止用户程序越权操作，提升系统安全性和可靠性。</p><p>随着摩尔定律逐渐放缓，CPU 的发展重心从单核性能转向多核并行、异构计算、能效优化和安全增强。新一代 CPU 越来越多地集成 AI 加速器、专用协处理器等模块，满足多样化的应用需求。</p><h2 id="simd" tabindex="-1">SIMD <a class="header-anchor" href="#simd" aria-label="Permalink to &quot;SIMD&quot;">​</a></h2><p>SIMT</p>',32)])])}const P=i(t,[["render",o]]);export{d as __pageData,P as default};
