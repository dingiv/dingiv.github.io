import{_ as l,c as i,o as a,ae as t}from"./chunks/framework.Cd-3tpCq.js";const u=JSON.parse('{"title":"总线协议","description":"","frontmatter":{},"headers":[],"relativePath":"kernel/embed/bus/index.md","filePath":"kernel/embed/bus/index.md"}'),r={name:"kernel/embed/bus/index.md"};function n(o,e,s,d,_,p){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="总线协议" tabindex="-1">总线协议 <a class="header-anchor" href="#总线协议" aria-label="Permalink to &quot;总线协议&quot;">​</a></h1><p>不同的设备通过各自的总线挂载到系统上，总线协议定义了硬件设备与 CPU、内存之间的通信规则，包括数据传输、设备发现、资源分配等生命周期的内容。这是硬件层面的内容，但它也提示了操作系统，应当以怎样的逻辑来管理这个总线上的硬件。</p><p>总线上的设备通过一个特殊的硬件，总线控制器来管理，这是硬件层面的协议，操作系统可以通过总线控制的驱动来管理总线控制器，从而通过总线控制器来管理这条总线上的所有设备。</p><p>目前的硬件总线主要包括：PCI、USB、I2S 等，对于部分设备无挂载总线，使用自定义的方式进行注册；</p><h2 id="硬件行为" tabindex="-1">硬件行为 <a class="header-anchor" href="#硬件行为" aria-label="Permalink to &quot;硬件行为&quot;">​</a></h2><p>总线协议规定了一种设备的行为模型，通过行为模型确定了该类设备如何和总线控制器交互，同时操作系统如何通过总线控制器来管理该类型的设备。</p><ul><li>设备探测：操作系统识别系统中存在硬件设备的过程，通过扫描总线来发现设备，支持热插拔特性，即支持动态探测；<strong>探测</strong>解决的问题是<strong>在物理内存地址空间上的哪一段上存在着一个怎样的设备</strong>？</li><li>设备枚举：为设备分配总线唯一标识（如地址、设备号），一般是设备探测后的进一步过程，在此之后，操作系统才能初始化这个设备，给这个设备绑定驱动，使其可被操作系统和驱动使用。</li><li>资源配置：设置设备寄存器、分配资源，通常在设备枚举完成后，由总线驱动或内核在设备初始化（probe 阶段）时执行，包括： <ul><li>中断号（IRQ）</li><li>内存映射 I/O（MMIO）地址</li><li>I/O 端口</li><li>DMA 通道</li></ul></li><li>设备拔出：总线设备支持热插拔，即在操作系统不重启的情况下，动态添加和移除硬件设备；</li><li>电源管理：控制设备电源状态，使得设备进入休眠状态；</li><li>数据传输：设备成功配置，设备进入工作阶段，通过驱动程序中的数据传输函数进行数据读写数据；</li><li>中断处理：主要用于监听硬件事件，实现硬件级别的异步回调机制，包括数据接收、DMA 功能、错误处理等；</li></ul>',7)]))}const m=l(r,[["render",n]]);export{u as __pageData,m as default};
