import{_ as l,c as i,o as a,ae as r}from"./chunks/framework.CDjunVez.js";const V=JSON.parse('{"title":"MVC","description":"","frontmatter":{},"headers":[],"relativePath":"design/arch/mvc.md","filePath":"design/arch/mvc.md"}'),o={name:"design/arch/mvc.md"};function t(c,e,d,n,h,m){return a(),i("div",null,[...e[0]||(e[0]=[r('<h1 id="mvc" tabindex="-1">MVC <a class="header-anchor" href="#mvc" aria-label="Permalink to &quot;MVC&quot;">​</a></h1><p>MVC（Model-View-Controller）现代 daemon 程序的典型架构模式。它将程序划分为三层，各层负责自己的逻辑，拆分了复杂的业务模块，降低了软件开发的复杂度。</p><ul><li>Model（模型）：负责数据和业务逻辑，管理应用程序的状态，处理数据持久化</li><li>View（视图）：负责用户界面展示，显示模型中的数据，不包含业务逻辑</li><li>Controller（控制器）：处理用户输入，更新模型，选择适当的视图进行显示</li></ul><h2 id="mvc-的工作流程" tabindex="-1">MVC 的工作流程 <a class="header-anchor" href="#mvc-的工作流程" aria-label="Permalink to &quot;MVC 的工作流程&quot;">​</a></h2><ol><li>用户通过视图发起请求</li><li>控制器接收请求并处理</li><li>控制器调用模型处理业务逻辑</li><li>模型更新数据状态</li><li>控制器选择视图进行展示</li><li>视图从模型获取数据并渲染</li></ol><h2 id="mvc-的变体" tabindex="-1">MVC 的变体 <a class="header-anchor" href="#mvc-的变体" aria-label="Permalink to &quot;MVC 的变体&quot;">​</a></h2><h3 id="mvp-model-view-presenter" tabindex="-1">MVP（Model-View-Presenter） <a class="header-anchor" href="#mvp-model-view-presenter" aria-label="Permalink to &quot;MVP（Model-View-Presenter）&quot;">​</a></h3><ul><li>Presenter 替代 Controller</li><li>View 和 Model 完全分离</li><li>更适合桌面应用</li></ul><h3 id="mvvm-model-view-viewmodel" tabindex="-1">MVVM（Model-View-ViewModel） <a class="header-anchor" href="#mvvm-model-view-viewmodel" aria-label="Permalink to &quot;MVVM（Model-View-ViewModel）&quot;">​</a></h3><ul><li>ViewModel 作为 View 和 Model 的桥梁</li><li>数据绑定机制</li><li>更适合现代前端框架</li></ul><h3 id="hmvc-hierarchical-mvc" tabindex="-1">HMVC（Hierarchical-MVC） <a class="header-anchor" href="#hmvc-hierarchical-mvc" aria-label="Permalink to &quot;HMVC（Hierarchical-MVC）&quot;">​</a></h3><ul><li>多层次的 MVC 结构</li><li>支持模块化开发</li><li>适合大型应用</li></ul><h2 id="mvc-的最佳实践" tabindex="-1">MVC 的最佳实践 <a class="header-anchor" href="#mvc-的最佳实践" aria-label="Permalink to &quot;MVC 的最佳实践&quot;">​</a></h2><ul><li>保持模型简单：只包含数据和业务逻辑，避免在模型中处理 UI 逻辑</li><li>视图职责单一：只负责展示，不包含业务逻辑</li><li>控制器保持精简：只负责协调，不包含复杂逻辑</li><li>使用依赖注入：降低组件耦合，提高可测试性</li></ul>',14)])])}const M=l(o,[["render",t]]);export{V as __pageData,M as default};
