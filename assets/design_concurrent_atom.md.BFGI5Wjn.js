import{_ as s,o as t,c as a,ah as d}from"./chunks/framework.DYrKkesV.js";const o=JSON.parse('{"title":"原子操作","description":"","frontmatter":{},"headers":[],"relativePath":"design/concurrent/atom.md","filePath":"design/concurrent/atom.md"}'),n={name:"design/concurrent/atom.md"};function e(h,i,l,k,p,r){return t(),a("div",null,[...i[0]||(i[0]=[d(`<h1 id="原子操作" tabindex="-1">原子操作 <a class="header-anchor" href="#原子操作" aria-label="Permalink to “原子操作”">​</a></h1><p>原子操作（Atomic Operation）是指在多处理器或多线程环境下，不可被中断、不可分割的操作。即使有多个线程/CPU 并发执行，原子操作要么全部完成，要么全部不做，不会出现中间状态。原子操作由硬件级别提供支持，与硬件强相关。</p><h2 id="原子指令和原子变量" tabindex="-1">原子指令和原子变量 <a class="header-anchor" href="#原子指令和原子变量" aria-label="Permalink to “原子指令和原子变量”">​</a></h2><p><strong>原子指令</strong>是各个 CPU 平台提供的，能够保证原子性的特殊指令，是原子操作的基础。</p><ul><li>x86 架构的 <code>LOCK</code> 前缀指令（如 <code>LOCK XADD</code>、<code>LOCK CMPXCHG</code>）</li><li>ARM 架构的 <code>LDREX/STREX</code>、<code>SWP</code> 等</li></ul><p>这些指令通常用于实现原子加减、原子交换、原子比较并交换（CAS, Compare-And-Swap）等操作，是上层原子操作的基础。</p><p><strong>原子变量</strong>是指支持原子操作的数据类型。需要特别说明的是，原子变量往往是在编译器层面实现的类型标记，其内存布局相较于普通的数据类型没有本质差异。原子变量用于提示编译器进行内存优化和语义提示。</p><p>以最简单的多线程同时对同一个变量进行加 1 操作的例子为例，在多核/多线程环境下，普通变量的操作（如 <code>a++</code>）实际上分为多步（读、加、写），可能被其他线程打断，导致数据竞争和不一致。原子操作可以保证这些操作的完整性，无需加锁即可安全并发访问。</p><h2 id="linux-原子接口" tabindex="-1">linux 原子接口 <a class="header-anchor" href="#linux-原子接口" aria-label="Permalink to “linux 原子接口”">​</a></h2><p>Linux 内核为不同平台提供了统一的原子操作接口，屏蔽了下层硬件平台的原子操作。以 C 函数的形式给出。</p><p>常见接口：</p><table tabindex="0"><thead><tr><th>类别</th><th>接口/类型名称</th><th>说明</th></tr></thead><tbody><tr><td>原子类型</td><td><code>atomic_t</code></td><td>32位整型</td></tr><tr><td></td><td><code>atomic64_t</code> / <code>atomic_long_t</code></td><td>64位整型（部分平台为 <code>atomic_long_t</code>）</td></tr><tr><td>原子操作</td><td><code>atomic_set(&amp;v, i)</code></td><td>赋值，把 <code>v</code> 设置为 <code>i</code></td></tr><tr><td></td><td><code>atomic_read(&amp;v)</code></td><td>读取 <code>v</code> 的值</td></tr><tr><td></td><td><code>atomic_add(i, &amp;v)</code></td><td>给 <code>v</code> 加上 <code>i</code></td></tr><tr><td></td><td><code>atomic_sub(i, &amp;v)</code></td><td>从 <code>v</code> 减去 <code>i</code></td></tr><tr><td></td><td><code>atomic_inc(&amp;v)</code></td><td>自增1（<code>v = v + 1</code>）</td></tr><tr><td></td><td><code>atomic_dec(&amp;v)</code></td><td>自减1（<code>v = v - 1</code>）</td></tr><tr><td></td><td><code>atomic_add_return(i, &amp;v)</code></td><td>加上 <code>i</code> 并返回新值</td></tr><tr><td></td><td><code>atomic_sub_return(i, &amp;v)</code></td><td>减去 <code>i</code> 并返回新值</td></tr><tr><td></td><td><code>atomic_cmpxchg(&amp;v, old, new)</code></td><td>如果 <code>v</code> 等于 <code>old</code>，则设为 <code>new</code>，返回原值</td></tr><tr><td></td><td><code>atomic_xchg(&amp;v, new)</code></td><td>把 <code>v</code> 设为 <code>new</code> 并返回旧值</td></tr><tr><td></td><td><code>atomic_add_unless(&amp;v,a,u)</code></td><td>如果 <code>v</code> 不等于 <code>u</code>，则加上 <code>a</code>，如果有加则返回非零</td></tr><tr><td>64位变体</td><td><code>atomic64_set</code>、<code>atomic64_read</code> ...</td><td>操作与对应32位类似，仅操作对象为 <code>atomic64_t</code>，接口名带 <code>64</code> 后缀</td></tr><tr><td>初始化</td><td><code>ATOMIC_INIT(i)</code></td><td>初始化 <code>atomic_t</code> 为 <code>i</code></td></tr><tr><td></td><td><code>ATOMIC64_INIT(i)</code></td><td>初始化 <code>atomic64_t</code> 为 <code>i</code></td></tr></tbody></table><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;linux/atomic.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">atomic_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ATOMIC_INIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    atomic_inc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 原子加1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> atomic_read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 原子读取</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    atomic_dec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 原子减1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // CAS操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> atomic_cmpxchg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 如果counter==5，则设为10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="c-接口原子接口" tabindex="-1">C 接口原子接口 <a class="header-anchor" href="#c-接口原子接口" aria-label="Permalink to “C 接口原子接口”">​</a></h2><p>C11 标准库中引入了语言级的原子变量接口，提供跨操作系统的原子操作抽象。</p><p>原子变量</p><ul><li><code>atomic_int</code></li></ul><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdatomic.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;pthread.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">atomic_int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        atomic_fetch_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Atomic increment</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pthread_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> threads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        pthread_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">threads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, increment, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        pthread_join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">threads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Counter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">atomic_load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Outputs ~10000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><table tabindex="0"><thead><tr><th>类别</th><th>接口/类型名称</th><th>说明</th></tr></thead><tbody><tr><td>原子类型</td><td><code>_Atomic</code> 限定符，如 <code>_Atomic int</code></td><td>用于声明原子类型变量</td></tr><tr><td></td><td><code>atomic_bool</code></td><td></td></tr><tr><td></td><td><code>atomic_char</code></td><td></td></tr><tr><td></td><td><code>atomic_int</code></td><td></td></tr><tr><td></td><td><code>atomic_long</code></td><td></td></tr><tr><td></td><td><code>atomic_pointer</code></td><td></td></tr><tr><td>原子操作</td><td><code>atomic_store(&amp;obj, val)</code></td><td>存储，将 <code>val</code> 写入 <code>obj</code></td></tr><tr><td></td><td><code>atomic_load(&amp;obj)</code></td><td>读取，从 <code>obj</code> 读取值</td></tr><tr><td></td><td><code>atomic_exchange(&amp;obj, val)</code></td><td>替换，将 <code>obj</code> 设为 <code>val</code>，返回旧值</td></tr><tr><td></td><td><code>atomic_fetch_add(&amp;obj, opnd)</code></td><td>加上 <code>opnd</code>，返回操作前的值</td></tr><tr><td></td><td><code>atomic_fetch_sub(&amp;obj, opnd)</code></td><td>减去 <code>opnd</code>，返回操作前的值</td></tr><tr><td></td><td><code>atomic_fetch_and(&amp;obj, opnd)</code></td><td>按位与（AND），返回操作前的值</td></tr><tr><td></td><td><code>atomic_fetch_or(&amp;obj, opnd)</code></td><td>按位或（OR），返回操作前的值</td></tr><tr><td></td><td><code>atomic_fetch_xor(&amp;obj, opnd)</code></td><td>按位异或（XOR），返回操作前的值</td></tr><tr><td></td><td><code>atomic_compare_exchange_strong(&amp;obj, &amp;exp, des)</code></td><td>若 <code>obj</code> 等于 <code>exp</code>，则设为 <code>des</code>，否则更新 <code>exp</code> 为当前值</td></tr><tr><td></td><td><code>atomic_compare_exchange_weak(&amp;obj, &amp;exp, des)</code></td><td>类似 strong，可能会伪失败</td></tr><tr><td>内存序控制参数</td><td><code>memory_order_relaxed</code></td><td>无序保证，执行速度最快，但允许操作重排</td></tr><tr><td></td><td><code>memory_order_acquire</code></td><td>读取操作，保证之后的操作不会被重排到该读取之前</td></tr><tr><td></td><td><code>memory_order_release</code></td><td>写入操作，保证之前的操作不会被重排到该写入之后</td></tr><tr><td></td><td><code>memory_order_acq_rel</code></td><td>用于读改写操作（如 fetch_add），同时具备 acquire 与 release 语义</td></tr><tr><td></td><td><code>memory_order_seq_cst</code></td><td>最严格，也是默认选项，所有线程间保证全序一致性</td></tr><tr><td>辅助操作</td><td><code>atomic_init(&amp;obj, val)</code></td><td>初始化原子类型变量</td></tr><tr><td></td><td><code>atomic_is_lock_free(&amp;obj)</code></td><td>检查该对象的操作是否为无锁实现</td></tr></tbody></table><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdatomic.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">atomic_int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">atomic_fetch_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Increments counter atomically</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> atomic_load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Reads counter atomically</span></span></code></pre></div><h2 id="内存屏障" tabindex="-1">内存屏障 <a class="header-anchor" href="#内存屏障" aria-label="Permalink to “内存屏障”">​</a></h2><p>现代的编译器会在编译时做很多工作，其中有的工作是指令重排，也就是代码执行的实际顺序不一定按照我们编写的代码顺序来执行。在单线程情况下，这通常不会有问题，但是一旦到了多线程的环境下，指令重排就可能导致数据竞争和不可预期的结果。更糟糕的是，现代的 CPU 往往可以使用一些硬件加速手段，例如：分支预测和流水线并发，这些硬件级别的行为也会导致指令顺序发生重排。</p><p>为了解决这种问题，引入了内存屏障（memory barrier，或 memory fence）的机制。内存屏障是一种特殊的指令，用于限制编译器和 CPU 的指令重排，保证内存操作的可见性和有序性。常见的内存屏障分为以下几类：</p><ul><li>全屏障（Full Barrier, 通常为 mfence）：确保其前后的所有读写操作都完成，常用于关键的同步点。</li><li>读屏障（Load Barrier, lfence）：保证屏障前的读操作全部完成，才会进行屏障后的读操作。</li><li>写屏障（Store Barrier, sfence）：保证屏障前的写操作全部完成，之后的写操作才会开始。</li></ul><p>内存屏障主要用途包括：</p><ul><li>防止乱序执行：确保关键顺序不可颠倒，避免多线程访问共享变量时出现“看见过时值”或“操作丢失”问题。</li><li>实现同步原语：如锁（mutex）、自旋锁（spinlock）、信号量（semaphore）等都依赖内存屏障保障可见性和顺序性。</li><li>确保写入对其他CPU可见：跨核心通信时，强制将数据从 CPU 缓存刷回主内存，确保其他处理器能够及时看到变更。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><ul><li>原子操作适合简单数据类型（如整型），复杂结构体仍需加锁保护。</li><li>无锁并发虽然高效，但实现复杂，需谨慎设计，避免ABA问题等陷阱。</li><li>在 SMP（多核）系统下，原子操作通常伴随内存屏障（memory barrier）以保证可见性和有序性。</li></ul>`,28)])])}const E=s(n,[["render",e]]);export{o as __pageData,E as default};
