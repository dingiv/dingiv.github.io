import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.Cd-3tpCq.js";const c=JSON.parse('{"title":"Web Component","description":"","frontmatter":{},"headers":[],"relativePath":"client/html/trick/wc.md","filePath":"client/html/trick/wc.md"}'),n={name:"client/html/trick/wc.md"};function l(h,s,p,k,o,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="web-component" tabindex="-1">Web Component <a class="header-anchor" href="#web-component" aria-label="Permalink to &quot;Web Component&quot;">​</a></h1><p>原生的 web 元素组件化能力，使用全局 API <code>customElements.define()</code> 来进行注册，单个元素的声明使用 class 语法，继承 HTMLElement 进行书写，该类实例化之后，成为 DOM 元素实例，需要在元素的身上定义几个关键的 hooks 函数，然后来对元素的逻辑进行管理。</p><h2 id="hooks" tabindex="-1">hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;hooks&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[propKey:string] : any </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任意属性，可以暴露在元素实例的数据</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  :  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回这个元素的可观测动态属性，这些属性将会被观察，并在发生变化时调用回调函数attributeChangedCallback</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">static get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observedAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() :  string[]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attributeChangedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(property, oldValue, newValue) : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connectedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这个元素被挂载到document时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnectedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这个元素从document卸载时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adoptedCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span></span></code></pre></div><h2 id="影子节点的-css-解决方案" tabindex="-1">影子节点的 css 解决方案 <a class="header-anchor" href="#影子节点的-css-解决方案" aria-label="Permalink to &quot;影子节点的 css 解决方案&quot;">​</a></h2><ul><li>局部声明，在影子节点内部声明的 style 标签只会作用于该影子节点，连同类都没有办法影响，因此这种样式将会被重复声明；</li><li>局部引用，使用 link 标签引入 css 文件，这种方式一个页面只会申请一次网络请求，同时能够使用 css 文件隔离逻辑</li><li>CSS 变量，影子节点的能够访问自定义元素的 CSS 变量，这是一种外部 CSS 变量向影子节点传递的简陋方式</li><li>样式穿透，在组件的内部使用自定义元素的类型，加上::part(&#39;tag&#39;)伪元素选择器可以选择影子节点内部 part 属性等于&#39;tag&#39;的元素，另一方面，在影子节点组件的内部使用::slotted(&#39;selector&#39;)将可以在组件内修改未来插槽中填充的元素的样式</li><li>样式表构造，使用 API CSSStyleSheet，手动创建一个 CSSOM 树，创建好后添加到 adoptedStyleSheets 属性，该属性位于 document 上和 shadowRoot 上，即可改变 CSS 属性，该方式性能最好，并且可以实现多个影子节点实例之间共用 CSS</li></ul>`,6)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
