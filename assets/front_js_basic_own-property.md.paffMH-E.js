import{_ as o,c as a,o as t,ae as r}from"./chunks/framework.BHrE6nLq.js";const s="/assets/own-p.BA_uTr85.png",m=JSON.parse('{"title":"属性的可枚举性和所有者","description":"","frontmatter":{},"headers":[],"relativePath":"front/js/basic/own-property.md","filePath":"front/js/basic/own-property.md"}'),n={name:"front/js/basic/own-property.md"};function i(l,e,c,d,p,h){return t(),a("div",null,e[0]||(e[0]=[r('<h1 id="属性的可枚举性和所有者" tabindex="-1">属性的可枚举性和所有者 <a class="header-anchor" href="#属性的可枚举性和所有者" aria-label="Permalink to &quot;属性的可枚举性和所有者&quot;">​</a></h1><p><img src="'+s+`" alt="alt text"></p><h2 id="own" tabindex="-1">Own <a class="header-anchor" href="#own" aria-label="Permalink to &quot;Own&quot;">​</a></h2><p>hasOwnProperty、Object.getOwnPropertyNames…… 凡是强调 <strong>Own</strong> 指的是在对象本身上定义的属性，而不是从原型链上继承而来的。</p><h2 id="name、symbol、" tabindex="-1">name、symbol、# <a class="header-anchor" href="#name、symbol、" aria-label="Permalink to &quot;name、symbol、#&quot;">​</a></h2><p>对象有三种属性，key 类型为字符串的属性，key 类型为 symbol 类型的，而完全私有的 <code>#</code> 开头的属性，只有谷歌浏览器的控制台能够访问，其他的方法访问不了 🐶</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertyNames</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertySymbols</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.getOwnPropertyDescriptors</span></span></code></pre></div><h2 id="enumerable-和-for-in" tabindex="-1">Enumerable 和 for...in <a class="header-anchor" href="#enumerable-和-for-in" aria-label="Permalink to &quot;Enumerable 和 for...in&quot;">​</a></h2><p><strong>对象的可枚举属性且不是 Symbol 类型的 key，可以通过 for...in 循环进行遍历，该遍历包括对象自身的和继承的可枚举属性。</strong></p><p>可枚举属性是指那些内部“可枚举”标志设置为 true 的属性，而平常我们在使用一些内置方法的时候，会默认将对象设置一些初始值</p><ul><li>对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true；</li><li>对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false；</li><li>对于原型链上的方法默认为 false，而访问器默认为 true；这是由于使用 class 语法定义的类，其原型链上的方法默认是不可枚举的，该行为是根据 ES 规范决定的；</li><li>Symbol 类型的 key 值的属性，默认为 false；</li></ul><h2 id="descriptor" tabindex="-1">Descriptor <a class="header-anchor" href="#descriptor" aria-label="Permalink to &quot;Descriptor&quot;">​</a></h2><p>用于描述一个对象的某个 key 值所代表的属性的配置对象。</p><ul><li>value。该值表示该 key 值的属性的值。</li><li>get。该函数使用一个空的参数列表，以便有权对值执行访问时，获取属性值。参见 getter。可能是 undefined。</li><li>set。使用包含分配值的参数调用的函数。每当尝试更改指定属性时执行。参见 setter。可能是 undefined。</li><li>enumerable。一个布尔值，表示是否可以通过 for...in 循环来枚举属性。另请参阅枚举性和属性所有权，以了解枚举属性如何与其他函数和语法交互。</li><li>configurable</li></ul><h2 id="对象的私有属性实现方法" tabindex="-1">对象的私有属性实现方法 <a class="header-anchor" href="#对象的私有属性实现方法" aria-label="Permalink to &quot;对象的私有属性实现方法&quot;">​</a></h2><ol><li>使用 <code>_</code> 开头的属性名，表示该属性是私有的，但是这种方式并不是真正的私有属性，只是约定俗成的，几乎没有限制，完全依赖于开发人员的意识，并且在使用 <code>for...in</code> 时，<code>_</code> 开头的属性也会被遍历出来，这种行为很可能是我们不希望的。因此，<strong>不推荐使用</strong>。</li><li>使用 <code>Symbol</code> 类型作为属性名，因为 <code>Symbol</code> 类型的属性名不会被 <code>for...in</code> 遍历出来，并且 <code>Object.getOwnPropertyNames</code> 也无法获取到 <code>Symbol</code> 类型的属性名，但是 <code>Object.getOwnPropertySymbols</code> 可以获取到 <code>Symbol</code> 类型的属性名。比较<strong>推荐使用</strong>。</li><li>使用 <code>WeakMap</code> 类型实现，将一个类和一个 <code>WeakMap</code> 实例关联起来，将类的实例作为 <code>WeakMap</code> 的 key，将类的私有属性作为 <code>WeakMap</code> 的 value，这样就可以实现类的私有属性，除了能够获得该 <code>WeakMap</code>，否则完全无法获取相应的属性，但是在实现上略微复杂，<strong>推荐使用</strong>。</li><li>使用 <code>#</code> 开头的属性名，这是 ES6 中新增的语法，表示该属性是私有的，并且该属性无法被 <code>for...in</code> 遍历出来，也无法被 <code>Object.getOwnPropertyNames</code> 获取到，但是 <code>Object.getOwnPropertyDescriptors</code> 可以获取到 <code>#</code> 开头的属性，但是即使 key 被获取到也无法在 class 外部访问。该种方式在和 Proxy、Reflect 一起使用时，非常容易发生错误，因此，<strong>不推荐使用</strong>。</li></ol>`,16)]))}const y=o(n,[["render",i]]);export{m as __pageData,y as default};
