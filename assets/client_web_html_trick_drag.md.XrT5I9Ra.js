import{_ as i,o as a,c as t,ah as n}from"./chunks/framework.BvDvRtye.js";const g=JSON.parse('{"title":"HTML 拖放 API","description":"","frontmatter":{},"headers":[],"relativePath":"client/web/html/trick/drag.md","filePath":"client/web/html/trick/drag.md"}'),l={name:"client/web/html/trick/drag.md"};function e(h,s,p,k,r,d){return a(),t("div",null,[...s[0]||(s[0]=[n(`<h1 id="html-拖放-api" tabindex="-1">HTML 拖放 API <a class="header-anchor" href="#html-拖放-api" aria-label="Permalink to “HTML 拖放 API”">​</a></h1><p>在拖放的过程中涉及两个元素，一个是拖动元素（或者说拖动源），一个是放置元素（或放置目标）。</p><ul><li>拖动元素是被拖动的元素，在这个元素身上可以提供原始的被拖动的数据，而被拖动的元素也有可能是从非浏览器中来的，它可能是从操作系统中拖动过来的，所以拖动元素不一定存在，所以考虑这点，更准确的说法应该是拖动源。当一个 html 元素被设置了 draggable 后，那么它就可以被拖动。</li><li>放置元素是拖动的过程中，在拖动路径上所遇到的其他元素，不能是拖动元素自己。一个元素想要成为放置元素，需要为改元素绑定 ondrop 事件处理器。同样的，放置的位置也可能不在浏览器中，而在其他的应用里，为了能让其他的应用也能识别拖动的内容，可以按照一定的约定进行拖动数据的定义。</li></ul><h2 id="拖动元素" tabindex="-1">拖动元素 <a class="header-anchor" href="#拖动元素" aria-label="Permalink to “拖动元素”">​</a></h2><p>当一个 html 元素被设置了 draggable 后，那么它就可以被拖动。</p><h3 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to “事件”">​</a></h3><p>拖动元素：如果一个拖动源在浏览器，那么我们可以在拖动元素的身上可以提供一些事件，这些事件如下：</p><ul><li>dragstart：当用户开始拖动元素的时候触发一次</li><li>drag：当用户开始拖动元素之后每隔一段时间触发一次，只要用户不松手，就重复触发</li><li>dragend：当用户结束拖动元素之后触发一次，也就是用户松手的时候</li></ul><p>放置元素：如果一个元素被拖动路径所经过或者在次结束拖动，那么会有如下事件：</p><ul><li>dragenter：当拖动元素进入放置元素的时候触发一次</li><li>dragover: 当拖动元素进入放置元素的过程中，如果拖动不结束，就会重复触发</li><li>drop：当拖动元素在改放置元素的身上结束拖动时触发，用于处理拖动之后的数据接收问题</li></ul><h3 id="定义拖拽数据" tabindex="-1">定义拖拽数据 <a class="header-anchor" href="#定义拖拽数据" aria-label="Permalink to “定义拖拽数据”">​</a></h3><p>拖拽数据是由数据源所提供的数据，所以定义拖拽数据在 dragstart 事件中进行定义。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onDragStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 添加拖拽数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ev.dataTransfer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/plain&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ev.target.innerText);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ev.dataTransfer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ev.target.outerHTML);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ev.dataTransfer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/uri-list&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ev.target.ownerDocument.location.href);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在dataTransfer上可以定义多个数据，数据的结构是一个平对象，string类型的键和任意类型的值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在定义的时候，一般会使用mime类型的名称作为键值，这种作法在各种程序中都很通用，可以保证当拖动目标不在浏览器中时的正常工作。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="定义拖拽图像或效果" tabindex="-1">定义拖拽图像或效果 <a class="header-anchor" href="#定义拖拽图像或效果" aria-label="Permalink to “定义拖拽图像或效果”">​</a></h3><p>拖拽效果涉及了两个人之间的交互。</p><h4 id="拖拽元素和放置元素之间的交互" tabindex="-1">拖拽元素和放置元素之间的交互 <a class="header-anchor" href="#拖拽元素和放置元素之间的交互" aria-label="Permalink to “拖拽元素和放置元素之间的交互”">​</a></h4><p>在拖拽元素的 dragstart 上设置拖动的效果类型</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onDragStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.dataTransfer.effectAllowed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;move&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.dataTransfer.dropEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;move&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在放置元素的 dragover 中阻止默认行为</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onDragOver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ev.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,20)])])}const o=i(l,[["render",e]]);export{g as __pageData,o as default};
