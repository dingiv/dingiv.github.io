import{_ as s,o as l,c as a,ah as e}from"./chunks/framework.DYrKkesV.js";const p=JSON.parse('{"title":"JVM","description":"","frontmatter":{},"headers":[],"relativePath":"server/java/jvm.md","filePath":"server/java/jvm.md"}'),t={name:"server/java/jvm.md"};function r(n,i,h,o,d,g){return l(),a("div",null,[...i[0]||(i[0]=[e('<h1 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to “JVM”">​</a></h1><ol start="5"><li>JVM Q13: JVM 内存结构？</li></ol><p>答案: 包括程序计数器、虚拟机栈、本地方法栈、堆、方法区（JDK 8 后为元空间）。堆存储对象，方法区存储类信息、常量池。 扩展: 元空间和永久代的区别？（元空间使用本地内存，动态扩展） Q14: 垃圾回收机制？</p><p>答案: GC 回收堆中无引用对象，常用算法有标记-清除、标记-整理、复制算法。常见收集器：CMS、G1（分代收集，关注低延迟）。 扩展: GC 调优参数？（-Xms、-Xmx、-XX:+UseG1GC） Q15: 类加载过程？</p><p>答案: 加载 → 连接（验证、准备、解析） → 初始化。双亲委派模型确保类加载安全。 扩展: 如何打破双亲委派？（自定义 ClassLoader，重写 loadClass）</p><p>JVM 调优是 Java Web 后台开发中提升系统性能、解决内存问题的重要手段，特别是在高并发场景下。以下是对 JVM 调优常见操作的详细讲解，涵盖核心概念、调优目标、常见参数、工具和实践，内容精炼且针对面试高频点。如果你需要具体代码示例、某个参数的深入分析或项目案例，请告诉我！</p><hr><h3 id="一、jvm-调优的目标" tabindex="-1">一、JVM 调优的目标 <a class="header-anchor" href="#一、jvm-调优的目标" aria-label="Permalink to “一、JVM 调优的目标”">​</a></h3><p>JVM 调优的主要目标是优化性能、降低延迟、提高吞吐量，具体包括：</p><ol><li><strong>减少 Full GC 频率和耗时</strong>：避免频繁或长时间的 GC 导致系统停顿。</li><li><strong>优化内存分配</strong>：合理分配堆内存，避免内存溢出（OOM）或浪费。</li><li><strong>提高吞吐量</strong>：提升系统处理请求的能力（如 TPS/QPS）。</li><li><strong>降低延迟</strong>：减少响应时间，优化用户体验。</li><li><strong>解决特定问题</strong>：如内存泄漏、线程阻塞、CPU 过高。</li></ol><hr><h3 id="二、jvm-内存结构回顾" tabindex="-1">二、JVM 内存结构回顾 <a class="header-anchor" href="#二、jvm-内存结构回顾" aria-label="Permalink to “二、JVM 内存结构回顾”">​</a></h3><p>JVM 调优主要针对堆和非堆内存：</p><ul><li><strong>堆内存</strong>：存储对象实例，分为新生代（Eden、Survivor）和老年代。</li><li><strong>非堆内存</strong>： <ul><li>方法区（JDK 8 后为元空间）：存储类信息、常量池。</li><li>栈：线程栈、程序计数器。</li><li>直接内存：NIO 使用，需单独调优。</li></ul></li><li><strong>垃圾回收器</strong>：如 CMS、G1，调优时需根据收集器特性调整。</li></ul><hr><h3 id="三、jvm-调优的常见操作" tabindex="-1">三、JVM 调优的常见操作 <a class="header-anchor" href="#三、jvm-调优的常见操作" aria-label="Permalink to “三、JVM 调优的常见操作”">​</a></h3><h4 id="_1-调整堆内存大小" tabindex="-1">1. 调整堆内存大小 <a class="header-anchor" href="#_1-调整堆内存大小" aria-label="Permalink to “1. 调整堆内存大小”">​</a></h4><ul><li><strong>参数</strong>： <ul><li><code>-Xms</code>：初始堆大小，建议与 <code>-Xmx</code> 设置相同，避免动态调整。</li><li><code>-Xmx</code>：最大堆大小，建议为物理内存的 1/4 至 1/2。</li><li><code>-XX:NewRatio</code>：老年代与新生代的比例（如 2 表示老年代是新生代的 2 倍）。</li><li><code>-XX:SurvivorRatio</code>：Eden 与 Survivor 区比例（如 8 表示 Eden 是 Survivor 的 8 倍）。</li></ul></li><li><strong>操作</strong>： <ul><li>根据业务规模设置堆大小，如高并发系统设 <code>-Xms4g -Xmx4g</code>。</li><li>调整新生代比例，减少 Minor GC 频率，例：<code>-XX:NewRatio=2</code>。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xms4g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xmx4g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:NewRatio=2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_2-选择合适的垃圾收集器" tabindex="-1">2. 选择合适的垃圾收集器 <a class="header-anchor" href="#_2-选择合适的垃圾收集器" aria-label="Permalink to “2. 选择合适的垃圾收集器”">​</a></h4><ul><li><strong>常见收集器</strong>： <ul><li><strong>CMS（Concurrent Mark Sweep）</strong>：低停顿，适合低延迟场景，但碎片较多。</li><li><strong>G1（Garbage First）</strong>：兼顾吞吐量和低延迟，适合大堆（&gt;4GB），JDK 9+ 默认。</li><li><strong>ZGC/Shenandoah</strong>：超低延迟，适合超大堆（JDK 11+）。</li></ul></li><li><strong>操作</strong>： <ul><li>高吞吐量场景：使用 <code>-XX:+UseParallelGC</code>（并行收集器）。</li><li>低延迟场景：使用 <code>-XX:+UseG1GC</code> 或 <code>-XX:+UseZGC</code>。</li><li>CMS 优化：调整 <code>-XX:CMSInitiatingOccupancyFraction</code>（如 70）控制老年代回收触发。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:+UseG1GC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xmx8g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_3-优化-gc-频率和耗时" tabindex="-1">3. 优化 GC 频率和耗时 <a class="header-anchor" href="#_3-优化-gc-频率和耗时" aria-label="Permalink to “3. 优化 GC 频率和耗时”">​</a></h4><ul><li><strong>参数</strong>： <ul><li><code>-XX:MaxGCPauseMillis</code>：设置 G1 的最大停顿时间（如 200ms）。</li><li><code>-XX:GCTimeRatio</code>：GC 时间占比，影响吞吐量（如 19 表示 GC 占 5%）。</li><li><code>-XX:+UseStringDeduplication</code>：字符串去重，减少内存占用（JDK 8u20+）。</li></ul></li><li><strong>操作</strong>： <ul><li>监控 GC 日志，分析 Minor GC 和 Full GC 频率。</li><li>减少大对象分配，避免直接进入老年代。</li><li>调整 <code>-XX:MaxTenuringThreshold</code>（如 15），控制对象晋升老年代的年龄。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:+UseG1GC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:MaxGCPauseMillis=200</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:MaxTenuringThreshold=15</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_4-处理元空间-metaspace" tabindex="-1">4. 处理元空间（Metaspace） <a class="header-anchor" href="#_4-处理元空间-metaspace" aria-label="Permalink to “4. 处理元空间（Metaspace）”">​</a></h4><ul><li><strong>问题</strong>：元空间过小可能导致 <code>OutOfMemoryError: Metaspace</code>。</li><li><strong>参数</strong>： <ul><li><code>-XX:MetaspaceSize</code>：初始元空间大小。</li><li><code>-XX:MaxMetaspaceSize</code>：最大元空间大小，建议设置上限（如 512m）。</li></ul></li><li><strong>操作</strong>： <ul><li>动态加载类较多的系统（如 Spring Boot），设置 <code>-XX:MaxMetaspaceSize=512m</code>。</li><li>监控类加载数量，减少不必要的动态代理或反射。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:MetaspaceSize=256m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:MaxMetaspaceSize=512m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_5-优化直接内存" tabindex="-1">5. 优化直接内存 <a class="header-anchor" href="#_5-优化直接内存" aria-label="Permalink to “5. 优化直接内存”">​</a></h4><ul><li><strong>问题</strong>：NIO 或 Netty 使用直接内存，过大可能导致 OOM。</li><li><strong>参数</strong>： <ul><li><code>-XX:MaxDirectMemorySize</code>：限制直接内存大小（如 1g）。</li></ul></li><li><strong>操作</strong>： <ul><li>监控直接内存使用（如 <code>sun.nio.ch.DirectBuffer</code>）。</li><li>优化 NIO 代码，及时释放 ByteBuffer。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:MaxDirectMemorySize=1g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_6-分析和监控" tabindex="-1">6. 分析和监控 <a class="header-anchor" href="#_6-分析和监控" aria-label="Permalink to “6. 分析和监控”">​</a></h4><ul><li><strong>工具</strong>： <ul><li><strong>jstat</strong>：查看 GC 频率、堆使用情况。<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -gcutil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span></span></code></pre></div></li><li><strong>jmap</strong>：生成堆转储，分析内存占用。<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jmap</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -dump:live,format=b,file=heap.hprof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></li><li><strong>jvisualvm/jconsole</strong>：可视化监控 GC、内存、线程。</li><li><strong>Arthas</strong>：在线诊断，查看对象、线程、GC 状态。</li><li><strong>GC 日志</strong>：启用 GC 日志分析。<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:+PrintGCDetails</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:+PrintGCTimeStamps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Xloggc:gc.log</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul></li><li><strong>操作</strong>： <ul><li>定期分析堆转储，查找内存泄漏（如 HashMap 未清理）。</li><li>监控 GC 停顿时间，调整参数优化吞吐量或延迟。</li></ul></li></ul><h4 id="_7-线程和锁优化" tabindex="-1">7. 线程和锁优化 <a class="header-anchor" href="#_7-线程和锁优化" aria-label="Permalink to “7. 线程和锁优化”">​</a></h4><ul><li><strong>问题</strong>：线程过多导致上下文切换，或锁竞争导致性能下降。</li><li><strong>操作</strong>： <ul><li>调整线程池大小（如 Tomcat 的 <code>maxThreads</code> 或 Java 的 <code>ThreadPoolExecutor</code>）。</li><li>使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁，减少锁开销。</li><li>监控线程状态，排查死锁（使用 <code>jstack &lt;pid&gt;</code>）。</li></ul></li><li><strong>示例</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -XX:+UseBiasedLocking</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.jar</span></span></code></pre></div></li></ul><h4 id="_8-项目特定调优" tabindex="-1">8. 项目特定调优 <a class="header-anchor" href="#_8-项目特定调优" aria-label="Permalink to “8. 项目特定调优”">​</a></h4><ul><li><strong>高并发场景</strong>： <ul><li>增大新生代（<code>-Xmn</code>），减少 Minor GC。</li><li>使用 G1 收集器，设置 <code>-XX:MaxGCPauseMillis=100</code>。</li></ul></li><li><strong>内存敏感场景</strong>： <ul><li>减少对象创建，使用对象池（如 Apache Commons Pool）。</li><li>启用字符串去重（<code>-XX:+UseStringDeduplication</code>）。</li></ul></li><li><strong>低延迟场景</strong>： <ul><li>使用 ZGC（<code>-XX:+UseZGC</code>），设置小停顿时间。</li></ul></li></ul><hr><h3 id="四、调优流程" tabindex="-1">四、调优流程 <a class="header-anchor" href="#四、调优流程" aria-label="Permalink to “四、调优流程”">​</a></h3><ol><li><strong>收集信息</strong>： <ul><li>监控系统指标：GC 频率、停顿时间、内存使用率、CPU 负载。</li><li>使用工具：jstat、jmap、Arthas、VisualVM。</li></ul></li><li><strong>分析瓶颈</strong>： <ul><li>频繁 Full GC：堆太小或内存泄漏。</li><li>高延迟：GC 停顿时间长或锁竞争。</li><li>OOM：堆、元空间或直接内存溢出。</li></ul></li><li><strong>调整参数</strong>： <ul><li>根据瓶颈调整堆大小、GC 策略、线程池等。</li><li>小步调整，单次改动一个参数，观察效果。</li></ul></li><li><strong>验证效果</strong>： <ul><li>压测验证 TPS/QPS、响应时间。</li><li>分析 GC 日志，确保优化有效。</li></ul></li><li><strong>持续监控</strong>： <ul><li>部署后持续观察，结合 Prometheus、Grafana 等工具。</li></ul></li></ol><hr><h3 id="五、面试扩展问题" tabindex="-1">五、面试扩展问题 <a class="header-anchor" href="#五、面试扩展问题" aria-label="Permalink to “五、面试扩展问题”">​</a></h3><ol><li><strong>如何排查 OOM 问题？</strong><ul><li>启用 GC 日志，分析堆使用。</li><li>使用 jmap 生成堆转储，MAT/Eclipse 分析大对象。</li><li>检查元空间、直接内存使用。</li></ul></li><li><strong>G1 和 CMS 的区别？</strong><ul><li>CMS：低停顿，分代收集，碎片多。</li><li>G1：分区收集，适合大堆，自动调优。</li></ul></li><li><strong>项目中如何进行 JVM 调优？</strong><ul><li>例：电商系统，频繁 Full GC，分析发现大对象过多，调整 <code>-Xmn</code> 增大新生代，使用 G1 收集器，减少停顿时间。</li></ul></li><li><strong>如何减少 GC 开销？</strong><ul><li>优化代码：减少临时对象、避免大对象。</li><li>调整堆结构：增大新生代、优化 Survivor 比例。</li></ul></li></ol><hr><h3 id="六、总结" tabindex="-1">六、总结 <a class="header-anchor" href="#六、总结" aria-label="Permalink to “六、总结”">​</a></h3><ul><li><strong>核心操作</strong>：调整堆大小、选择垃圾收集器、优化 GC 频率、监控元空间和直接内存、使用工具分析。</li><li><strong>常用参数</strong>：<code>-Xms</code>、<code>-Xmx</code>、<code>-XX:+UseG1GC</code>、<code>-XX:MaxGCPauseMillis</code>、<code>-XX:MaxMetaspaceSize</code>。</li><li><strong>工具</strong>：jstat、jmap、VisualVM、Arthas、GC 日志。</li><li><strong>实践建议</strong>：结合业务场景（如高并发、内存敏感），从小规模调整开始，压测验证，持续监控。</li></ul><p>如果你需要具体参数配置示例、GC 日志分析步骤、或某场景的调优案例（如 Redis + Spring Boot），请告诉我！</p>',42)])])}const c=s(t,[["render",r]]);export{p as __pageData,c as default};
