import{_ as d,o as l,c as e,ah as T,j as t,a}from"./chunks/framework.BvDvRtye.js";const x=JSON.parse('{"title":"机器学习","description":"","frontmatter":{"title":"机器学习","order":20},"headers":[],"relativePath":"ai/neural/ml/index.md","filePath":"ai/neural/ml/index.md"}'),r={name:"ai/neural/ml/index.md"},i={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},s={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.912ex"},xmlns:"http://www.w3.org/2000/svg",width:"16.691ex",height:"2.87ex",role:"img",focusable:"false",viewBox:"0 -865.4 7377.6 1268.4","aria-hidden":"true"},n={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},o={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.798ex"},xmlns:"http://www.w3.org/2000/svg",width:"9.059ex",height:"2.846ex",role:"img",focusable:"false",viewBox:"0 -905 4004 1257.8","aria-hidden":"true"},m={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},h={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.798ex"},xmlns:"http://www.w3.org/2000/svg",width:"30.482ex",height:"3.087ex",role:"img",focusable:"false",viewBox:"0 -1011.8 13473.2 1364.5","aria-hidden":"true"};function p(g,Q,H,u,c,f){return l(),e("div",null,[Q[20]||(Q[20]=T("",20)),t("ol",null,[Q[13]||(Q[13]=t("li",null,[t("p",null,"数据预处理"),t("ul",null,[t("li",null,"缺失值处理：删除、填均值/中位数、插值、模型预测填充。"),t("li",null,"异常值处理：剔除、截断（winsorize）、变换。")])],-1)),t("li",null,[Q[12]||(Q[12]=t("p",null,"特征缩放",-1)),t("ul",null,[t("li",null,[Q[5]||(Q[5]=a("归一化（Normalization/Min-Max Scaling） ",-1)),t("ul",null,[Q[3]||(Q[3]=t("li",null,[a("将数据映射到 "),t("code",null,"[0, 1]"),a(" 或 "),t("code",null,"[-1, 1]"),a(" 区间。")],-1)),t("li",null,[Q[2]||(Q[2]=a("公式：",-1)),t("mjx-container",i,[(l(),e("svg",s,[...Q[0]||(Q[0]=[T("",1)])])),Q[1]||(Q[1]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("msup",null,[t("mi",null,"x"),t("mo",{"data-mjx-alternate":"1"},"′")]),t("mo",null,"="),t("mfrac",null,[t("mrow",null,[t("mi",null,"x"),t("mo",null,"−"),t("mi",null,"x"),t("mo",null,"∗"),t("mrow",{"data-mjx-texclass":"ORD"},[t("mi",null,"m"),t("mi",null,"i"),t("mi",null,"n")])]),t("mrow",null,[t("mi",null,"x"),t("mo",null,"∗"),t("mrow",{"data-mjx-texclass":"ORD"},[t("mi",null,"m"),t("mi",null,"a"),t("mi",null,"x")]),t("mo",null,"−"),t("mi",null,"x"),t("mi",{mathvariant:"normal"},"_"),t("mrow",{"data-mjx-texclass":"ORD"},[t("mi",null,"m"),t("mi",null,"i"),t("mi",null,"n")])])])])],-1))])]),Q[4]||(Q[4]=t("li",null,"适用：数据有明确边界、算法对数值范围敏感（如神经网络、KNN）。",-1))])]),t("li",null,[Q[11]||(Q[11]=a("标准化（Standardization/Z-Score） ",-1)),t("ul",null,[Q[9]||(Q[9]=t("li",null,"转换为均值 0、方差 1 的分布。",-1)),t("li",null,[Q[8]||(Q[8]=a("公式：",-1)),t("mjx-container",n,[(l(),e("svg",o,[...Q[6]||(Q[6]=[T("",1)])])),Q[7]||(Q[7]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("msup",null,[t("mi",null,"x"),t("mo",{"data-mjx-alternate":"1"},"′")]),t("mo",null,"="),t("mfrac",null,[t("mrow",null,[t("mi",null,"x"),t("mo",null,"−"),t("mi",null,"μ")]),t("mi",null,"σ")])])],-1))])]),Q[10]||(Q[10]=t("li",null,"适用：大多数算法（如线性模型、SVM、逻辑回归），对正态分布假设敏感时更优。",-1))])])])]),Q[14]||(Q[14]=T("",3))]),Q[21]||(Q[21]=T("",8)),t("p",null,[Q[17]||(Q[17]=t("strong",null,"Iteration",-1)),Q[18]||(Q[18]=a("。为了量化一个轮次内的计算量，我们引入步数（Steps）或迭代次数（Iterations）的概念，一个轮次所包含的步数等于训练样本总数除以批次大小（向上取整），即 ",-1)),t("mjx-container",m,[(l(),e("svg",h,[...Q[15]||(Q[15]=[T("",1)])])),Q[16]||(Q[16]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mtext",null,"steps per epoch"),t("mo",null,"="),t("mo",{fence:"false",stretchy:"false"},"⌈"),t("mfrac",null,[t("mtext",null,"数据集样本数"),t("mtext",null,"batch size")]),t("mo",{fence:"false",stretchy:"false"},"⌉")])],-1))]),Q[19]||(Q[19]=a("，因此，当批次大小较小时，一个轮次内的步数会显著增加，模型参数会被更频繁地更新，引入更多梯度噪声但总计算量保持不变；而当批次大小较大时，一个轮次内的步数减少，梯度估计更精确但单次更新需要更多显存，整个训练过程的步数与轮次数的乘积则代表了参数总共被更新的次数。",-1))]),Q[22]||(Q[22]=T("",14))])}const V=d(r,[["render",p]]);export{x as __pageData,V as default};
