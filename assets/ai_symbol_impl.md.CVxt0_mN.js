import{_ as a,c as s,o as i,ah as o}from"./chunks/framework.C5lh6Kkj.js";const c=JSON.parse('{"title":"Prolog","description":"","frontmatter":{},"headers":[],"relativePath":"ai/symbol/impl.md","filePath":"ai/symbol/impl.md"}'),l={name:"ai/symbol/impl.md"};function r(p,e,t,n,m,g){return i(),s("div",null,[...e[0]||(e[0]=[o('<h1 id="prolog" tabindex="-1">Prolog <a class="header-anchor" href="#prolog" aria-label="Permalink to “Prolog”">​</a></h1><p>基础逻辑入手 → 知识表示 → 推理机制 → 编程实现 → 现代融合</p><p>纯符号AI（GOFAI）的编程实现 纯符号AI（Good Old-Fashioned AI，也称经典符号主义AI）主要通过符号表示知识并使用逻辑规则进行推理来实现。编程上不依赖数据驱动学习，而是手工编码事实、规则和推理机制。 主要编程语言</p><p>Lisp：早期主流语言（1958年起），擅长符号操纵（symbol manipulation）。代码即数据（code as data），易于元编程和递归处理符号表达式。 Prolog：逻辑编程语言（1972年起），直接基于一阶逻辑。程序由事实和规则组成，推理引擎自动处理查询。</p><p>其他语言如C或Fortran有时用于底层，但核心逻辑仍用Lisp/Prolog实现。 核心实现技术</p><p>知识表示 事实：原子符号或谓词（如 parent(john, mary)）。 规则：IF-THEN生产规则（production rules）。 结构：帧（frames）、语义网（semantic nets）或本体。</p><p>推理引擎（Inference Engine） 前向链（forward chaining）：从事实推导新事实。 后向链（backward chaining）：从目标反推所需事实（Prolog默认）。 搜索算法：深度优先、广度优先或启发式搜索。</p><p>专家系统架构 知识库（knowledge base）：存储规则和事实。 推理引擎：应用规则。 用户界面：输入查询，输出解释。</p><p>典型专家系统如MYCIN（医疗诊断）用Lisp实现规则链，DENDRAL（化学结构分析）用符号匹配。 简单代码示例 Lisp 示例（简单生产系统规则：动物分类） lisp(defun animal-classification (features) (cond ((member &#39;flies features) (if (member &#39;lays-eggs features) &#39;bird &#39;bat)) ((member &#39;swims features) &#39;fish) (t &#39;mammal)))</p><p>;; 使用 (animal-classification &#39;(flies lays-eggs)) ; =&gt; bird Lisp 用列表和条件语句实现符号匹配和规则。 Prolog 示例（相同动物分类，更声明式） prologbird(X) :- flies(X), lays_eggs(X). bat(X) :- flies(X), + lays_eggs(X). fish(X) :- swims(X). mammal(X) :- + bird(X), + bat(X), + fish(X).</p><p>flies(eagle). lays_eggs(eagle). swims(shark).</p><p>?- bird(eagle). % yes ?- mammal(dog). % yes Prolog 中规则直接写成逻辑谓词，查询时引擎自动统一（unification）和回溯搜索。 实现挑战</p><p>手工编码规则：知识获取瓶颈。 脆性：无法处理不确定性或噪声。 规模问题：规则爆炸。</p><p>纯符号AI的编程本质是声明式（描述“什么”而非“如何”），依赖显式符号和逻辑推理。这与现代神经网络的子符号（sub-symbolic）方法形成对比。 你想看更复杂的专家系统代码示例，还是某个具体系统的实现细节？</p><p>方面,符号AI（经典GOFAI，如专家系统）,普通编程语言编写的程序（如C/Python/Java等） 核心范式,声明式（Declarative）：描述“是什么”（事实 + 规则）,命令式（Imperative）：描述“怎么做”（步骤序列） 知识表示,显式分离知识库（事实和规则）与推理引擎,逻辑直接硬编码在过程式代码中，无独立知识库 执行机制,推理引擎自动应用规则进行搜索、匹配、演绎,程序按固定顺序或分支执行，开发者控制所有流程 灵活性与修改,修改知识库（加/删规则）即可改变行为，无需改代码,修改逻辑需重写代码、重新编译/部署 通用性,目标是通用推理能力（自动推导新结论）,解决特定问题，无内置通用推理机制 不确定性处理,易扩展支持（如置信度、模糊逻辑）,需要手动编码所有异常和分支 解释性,推理过程可追溯（显示哪些规则被触发）,解释需额外调试或日志</p><p>具体解释为什么“感觉差不多”却实际不同</p><p>普通程序是固定算法 你写一个判断动物类别的程序：Pythonif flies and lays_eggs: return &quot;bird&quot; elif flies: return &quot;bat&quot; else: return &quot;mammal&quot;这只是开发者预先写好的所有可能分支，程序严格按代码路径执行，不会自动推导出你没写的新结论。 符号AI是知识 + 自动推理 用Prolog写：prologbird(X) :- flies(X), lays_eggs(X). mammal(X) :- has_milk(X). flies(eagle). lays_eggs(eagle). has_milk(cow).你只需声明事实和规则，推理引擎会自动： 回答 bird(eagle) → yes 甚至推导出未显式写的新事实 如果新增规则 reptile(X) :- lays_eggs(X), cold_blooded(X).，系统立即能推理新结论，无需改“主程序” 知识库和推理引擎完全分离，这就是关键区别。</p><p>“符号推理引擎不就是编译器吗？”——不是</p><p>编译器：把高级代码翻译成机器码，执行时仍是固定指令序列，无搜索、无回溯、无自动规则匹配。 符号推理引擎（如Prolog的Warren Abstract Machine或Lisp解释器）： 动态搜索规则空间（可能指数级） 支持统一（unification）和回溯（backtracking） 在运行时根据当前事实集自动生成新知识 更像一个“通用定理证明器”或“逻辑求解器”，而非单纯翻译器</p><p>总结一句话区别</p><p>普通程序：开发者把所有逻辑提前写死，程序机械执行。 符号AI：开发者只提供领域知识（事实+规则），系统自动进行通用推理，能产生程序员未预料的新结论。</p><p>正因为这种“知识与控制分离”，符号AI曾被寄望实现通用智能，但也因知识获取困难而衰落。 如果你想看一个更直观的对比实验（同一问题用命令式Python vs 声明式Prolog实现），我可以立刻写出来。</p>',22)])])}const f=a(l,[["render",r]]);export{c as __pageData,f as default};
