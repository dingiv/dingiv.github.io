import{_ as i,c as a,o as l,ae as t}from"./chunks/framework.BtEkjhVd.js";const p=JSON.parse('{"title":"面向对象","description":"","frontmatter":{"title":"面向对象","order":10},"headers":[],"relativePath":"design/oop/index.md","filePath":"design/oop/index.md"}'),o={name:"design/oop/index.md"};function r(n,e,d,s,_,c){return l(),a("div",null,e[0]||(e[0]=[t('<h1 id="面向对象编程" tabindex="-1">面向对象编程 <a class="header-anchor" href="#面向对象编程" aria-label="Permalink to &quot;面向对象编程&quot;">​</a></h1><p>面向对象： 对象：封装、继承、多态</p><h2 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to &quot;SOLID&quot;">​</a></h2><ul><li>S: 单一职责原则，对象应该具有一种单一的功能，不要把过多的功能放到同一个类中——将不同的功能进行细分</li><li>O: 开放封闭原则，对扩展开放，对修改关闭，添加新的功能的时候，应当尽量不要去修改已有的类或者代码——依赖注入</li><li>L: 里氏替换原则，对象可以在不改变程序正确性的前提下被它的子类所替换的——子类应当忠实地继承父类的所有方法</li><li>I: 接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口——接口的粒度应当尽量小</li><li>D: 依赖倒置原则，依赖于抽象而不是一个实例——依赖接口而不是实现类</li></ul><h2 id="具体做法" tabindex="-1">具体做法 <a class="header-anchor" href="#具体做法" aria-label="Permalink to &quot;具体做法&quot;">​</a></h2><ol><li>数据封装：对数据进行封装，限制数据的访问权限，特定数据只能由特定方法进行修改和管理</li><li>划分模块：将代码根据业务逻辑和功能，拆分成一个个小的模块，并且尽量保证功能的单一性，不将不同功能的代码混合到一起</li><li>单向依赖：不同的业务逻辑之间会存在依赖，他们的依赖关系可以形成一个图，这个图应该是一个单向无环图，最好是一棵树</li><li>依赖接口：模块之间进行依赖时，依赖于接口，不依赖于实现类，少用继承，多用实现（该做法在动态语言中可以适当放松）</li><li>依赖注入：模块的运行时依赖不应当由其自己获取，而应当由外界进行注入</li></ol>',6)]))}const u=i(o,[["render",r]]);export{p as __pageData,u as default};
