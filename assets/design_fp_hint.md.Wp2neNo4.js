import{_ as e,o as a,c as i,ah as l}from"./chunks/framework.BvDvRtye.js";const u=JSON.parse('{"title":"hint","description":"","frontmatter":{},"headers":[],"relativePath":"design/fp/hint.md","filePath":"design/fp/hint.md"}'),r={name:"design/fp/hint.md"};function d(n,t,s,o,h,c){return a(),i("div",null,[...t[0]||(t[0]=[l('<h1 id="hint" tabindex="-1">hint <a class="header-anchor" href="#hint" aria-label="Permalink to “hint”">​</a></h1><p><strong>函数式编程思想</strong>（FP）对现代软件设计的影响已经非常深远。它没有完全取代面向对象（OOP），但已成为<strong>主流语言和架构事实上的重要组成部分</strong>，尤其在 2020–2026 这段时间加速渗透。</p><p>以下是 FP 核心思想给现代软件设计带来的最实际、最广泛的指导，按影响力从大到小排序。</p><h3 id="_1-不可变性-immutability-成为默认选择" tabindex="-1">1. 不可变性（Immutability）成为默认选择 <a class="header-anchor" href="#_1-不可变性-immutability-成为默认选择" aria-label="Permalink to “1. 不可变性（Immutability）成为默认选择”">​</a></h3><ul><li>数据默认不可变 → 极大降低并发 Bug</li><li>前端：React / Vue 3 / SolidJS / Svelte → state 不可变 + diff 驱动渲染</li><li>后端：事件溯源、CQRS、DDD 中的聚合根倾向 immutable</li><li>架构影响：Redux / Zustand / Jotai / Recoil / Riverpod / Immer → 强制或强烈鼓励 immutable 更新</li><li>数据库/缓存：事件日志 + 物化视图 而不是直接 UPDATE</li></ul><p><strong>实际指导</strong>：优先用 record / data class / sealed class / value object，而不是可变 DTO。</p><h3 id="_2-纯函数-pure-functions-成为核心构建块" tabindex="-1">2. 纯函数（Pure functions）成为核心构建块 <a class="header-anchor" href="#_2-纯函数-pure-functions-成为核心构建块" aria-label="Permalink to “2. 纯函数（Pure functions）成为核心构建块”">​</a></h3><ul><li>无副作用、可引用透明 → 代码可预测、可缓存、可并行、可测试</li><li>最直接体现： <ul><li>Serverless / FaaS 函数（AWS Lambda、Vercel Functions）</li><li>数据处理 pipeline（Spark、Kafka Streams、Flink）</li><li>单元测试友好度暴增</li></ul></li><li>现代框架默认倾向：useEffect / useMemo / React Query / TanStack Query → 把副作用隔离</li></ul><p><strong>实际指导</strong>：业务逻辑尽量写成纯函数，副作用推到边界（适配器、端口、驱动）。</p><h3 id="_3-高阶函数-组合性-→-取代大量经典设计模式" tabindex="-1">3. 高阶函数 + 组合性 → 取代大量经典设计模式 <a class="header-anchor" href="#_3-高阶函数-组合性-→-取代大量经典设计模式" aria-label="Permalink to “3. 高阶函数 + 组合性 → 取代大量经典设计模式”">​</a></h3><table tabindex="0"><thead><tr><th>传统 OOP 模式</th><th>FP 更自然的表达方式</th><th>现代常见体现</th></tr></thead><tbody><tr><td>策略模式</td><td>函数作为参数 / 闭包</td><td>Comparator、sort、map、filter、reduce</td></tr><tr><td>命令模式</td><td>函数 / thunk / Task / IO monad</td><td>useCallback、事件处理器、ZIO / cats-effect</td></tr><tr><td>装饰器 / AOP</td><td>高阶函数 / 中间件 / 组合</td><td>Redux middleware、Express middleware</td></tr><tr><td>观察者模式</td><td>流 / Observable / Signal</td><td>RxJS、xstream、most、Svelte store</td></tr><tr><td>模板方法</td><td>高阶函数 + 部分应用</td><td>hooks、HOC、render prop</td></tr><tr><td>访问者模式</td><td>模式匹配 + algebraic data type</td><td>sealed interface + when (Kotlin)、match</td></tr></tbody></table><p><strong>实际指导</strong>：当你想用策略/命令/装饰器时，先问一句“能不能直接传函数或组合函数解决？”</p><h3 id="_4-声明式-命令式-成为-ui-和数据流主流" tabindex="-1">4. 声明式 &gt; 命令式 成为 UI 和数据流主流 <a class="header-anchor" href="#_4-声明式-命令式-成为-ui-和数据流主流" aria-label="Permalink to “4. 声明式 &gt; 命令式 成为 UI 和数据流主流”">​</a></h3><ul><li>“我要什么结果” 而不是 “我怎么一步步做”</li><li>最明显例子： <ul><li>React → JSX + hooks 是声明式</li><li>SQL / LINQ / GraphQL → 声明式查询</li><li>Dockerfile / Kubernetes manifests → 声明式部署</li><li>GitOps / Pulumi / Terraform → 声明式基础设施</li></ul></li></ul><p><strong>实际指导</strong>：业务规则、转换逻辑、UI 渲染尽量写成声明式表达式。</p><h3 id="_5-副作用显式化-边界隔离" tabindex="-1">5. 副作用显式化 &amp; 边界隔离 <a class="header-anchor" href="#_5-副作用显式化-边界隔离" aria-label="Permalink to “5. 副作用显式化 &amp; 边界隔离”">​</a></h3><p>现代架构最重要变化之一：</p><ul><li>Clean Architecture / Hexagonal / Ports &amp; Adapters → 把副作用推到最外层</li><li>Functional Core, Imperative Shell</li><li>Effect 系统（ZIO、Effect-TS、cats-effect、arrow-kt）→ 副作用变成值</li><li>React Query / RTK Query / SWR → 数据获取副作用被封装成可组合的钩子</li></ul><p><strong>实际指导</strong>：核心领域逻辑（domain）应尽量无 IO、无时间、无随机、无全局状态。</p><h3 id="_6-并发与并行友好性大幅提升-多核-云原生时代" tabindex="-1">6. 并发与并行友好性大幅提升（多核 / 云原生时代） <a class="header-anchor" href="#_6-并发与并行友好性大幅提升-多核-云原生时代" aria-label="Permalink to “6. 并发与并行友好性大幅提升（多核 / 云原生时代）”">​</a></h3><p>纯函数 + 不可变数据 → 天生适合多线程 / 分布式 最典型场景：</p><ul><li>数据流处理（Kafka、Flink、Spark）</li><li>Actor 模型（Akka、Orleans、Actix）</li><li>事件驱动微服务（Event Sourcing + CQRS）</li><li>前端并发渲染（React Suspense + concurrent mode）</li></ul><h3 id="_2026-年最常见的-fp-思想落地形态-混合式" tabindex="-1">2026 年最常见的 FP 思想落地形态（混合式） <a class="header-anchor" href="#_2026-年最常见的-fp-思想落地形态-混合式" aria-label="Permalink to “2026 年最常见的 FP 思想落地形态（混合式）”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>主流做法（FP 影响程度）</th></tr></thead><tbody><tr><td>前端 UI</td><td>hooks + 不可变状态 + 纯组件（极高）</td></tr><tr><td>后端业务逻辑</td><td>函数 + record + Either/Result + pipeline（高）</td></tr><tr><td>数据处理 / ETL</td><td>map/filter/reduce + streaming（极高）</td></tr><tr><td>微服务</td><td>事件驱动 + 最终一致性 + 函数式风格 handler（中→高）</td></tr><tr><td>基础设施</td><td>声明式配置（高）</td></tr></tbody></table><p>一句话总结：</p><p>函数式编程思想给现代软件设计带来的最大改变是：</p><p><strong>从“可变状态 + 命令式控制流” → “不可变数据 + 纯函数 + 声明式组合 + 副作用隔离”</strong><br> 这套思维显著提高了可预测性、可测试性、并发安全性和演进能力，尤其适合前端、数据密集型系统、云原生和分布式场景。</p><p>你当前最感兴趣的落地点是哪个？</p><ul><li>前端 hooks + 不可变状态</li><li>后端 Either/Result + 管道风格</li><li>副作用管理（Effect / IO monad）</li><li>函数式风格取代设计模式</li><li>事件溯源 + 函数式思想</li></ul><p>说一下，我可以给出更具体的代码/架构示例。</p>',30)])])}const m=e(r,[["render",d]]);export{u as __pageData,m as default};
