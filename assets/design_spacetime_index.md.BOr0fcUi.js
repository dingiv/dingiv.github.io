import{_ as e,o as p,c as t,ah as s}from"./chunks/framework.CJUjh4G6.js";const g=JSON.parse('{"title":"面向时空","description":"","frontmatter":{"title":"面向时空","order":999},"headers":[],"relativePath":"design/spacetime/index.md","filePath":"design/spacetime/index.md"}'),i={name:"design/spacetime/index.md"};function n(l,a,r,o,d,h){return p(),t("div",null,[...a[0]||(a[0]=[s(`<h1 id="面向时空" tabindex="-1">面向时空 <a class="header-anchor" href="#面向时空" aria-label="Permalink to “面向时空”">​</a></h1><p>面向时空编程需要开发者以<strong>空间结构管理和时间流程规划</strong>的姿态去理解软件开发的本质。</p><p>另一方面，面向时空编程需要兼容和解释已有的经典理论，将经典理论纳入时空框架中而不产生矛盾。这要帮助我们从一个更高更全面的维度去理解这些理论的本质，总结概括杂乱的理论商品，减少选择困难。</p><p>面向时空编程需要走到实践中去，提出具体的实践方案，让理论变得可行。</p><h2 id="软件时空观" tabindex="-1">软件时空观 <a class="header-anchor" href="#软件时空观" aria-label="Permalink to “软件时空观”">​</a></h2><p>分析设计一个程序系统，可以从<strong>空间结构</strong>和<strong>时间流程</strong>两个大方向入手，先看空间结构，然后看结构之间的交互流程。</p><h3 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to “结构”">​</a></h3><p>当下的软件系统在空间形态上有两个明显的边界，一个是进程边界，一个是主机边界，使得空间被划分成 3 层结构。</p><p><strong>进程内</strong></p><ul><li>模块拆分</li><li>依赖管理，作用域交互、依赖倒置 组件耦合原则</li></ul><p>当设计从类级别上升到组件级别时，需要遵循一套新的原则来控制组件间的依赖关系。</p><p>ADP：无环依赖原则</p><p>组件依赖图中不应出现环路。如果 A 依赖 B，B 依赖 C，那么 C 绝对不能依赖 A。循环依赖会导致组件无法独立测试和发布，任何变更都可能产生连锁反应。</p><p>解决循环依赖的方法通常是引入新的抽象组件，或者通过依赖倒置打破原有的依赖链条。</p><p>SDP：稳定依赖原则</p><p>依赖应该指向更稳定的方向。不稳定的组件（易变的）应该依赖稳定的组件（不易变的）。如果一个稳定的组件依赖了一个易变的组件，那么每次易变组件的修改都会迫使稳定组件跟着变化，这违背了稳定性的初衷。</p><p>组件的稳定性可以通过&quot;入度依赖数&quot;和&quot;出度依赖数&quot;来衡量：入度越大（被越多组件依赖）、出度越小（依赖越少组件），则组件越稳定。</p><p>SAP：稳定抽象原则</p><p>一个组件越稳定，它就应该越抽象。稳定的组件被广泛依赖，不应该频繁变化，因此应该是抽象的接口或基类；不稳定的组件可以频繁变化，因此可以是具体的实现。</p><p>这一原则与 SDP 结合，形成了组件设计的指导方针：向着&quot;稳定且抽象&quot;的方向努力，避免&quot;不稳定且具体&quot;的组件。</p><ul><li>状态管理，生命周期、纯函数</li></ul><p>状态管理，生命周期对齐，状态同步，状态分步加载，流式加载，分页加载 配置和配置文件管理，命令行，环境变量，配置中心，配置接口 依赖管理，正交性原则</p><p>通过接口隔离降低耦合、通过策略模式消除大量 if-else、通过依赖注入实现可测试性。</p><p><strong>本机上</strong></p><ul><li>文件管理</li><li>微服务治理</li><li>数据与配置分离</li></ul><p><strong>主机间</strong></p><ul><li>分布式锁</li><li>通信代理</li></ul><p>涉及跨进程通信，引入外部 IO，可能产生失败；设计跨主机通信，引入网络延迟，增加了程序阻塞。</p><h3 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to “流程”">​</a></h3><p><strong>时间是基于空间结构的</strong>，流程研究的是空间如何随着时间的改变而发生变化。</p><p>以前的开发者仅仅关注单进程中的时间流程，后来逐步扩展到整个集群架构层级的时间流程，</p><p>当我们将整个软件开发生命周期纳入设计，我们发现开发、测试、运维人员属于空间结构中的不同的组成，在时间流程上存在空窗，开发在编写程序阶段，测试人员和运维人员的时间是被阻塞和浪费的，因此出现了 DevOps 将测试和运维的任务在时间维度上向开发人员折叠</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>需求分析 -&gt; 开发设计 -&gt; 测试评估 -&gt; 运维监控</span></span>
<span class="line"><span>    ↑                                ↓</span></span>
<span class="line"><span>        &lt;-          &lt;-         &lt;-</span></span></code></pre></div><p>生命周期中有不同的角色分工 刚好对应着互联网公司的 4 个岗位，产品、开发、测试、运维，</p><p>是一个简化的长时间的时间迭代维度模型，初次编写一个软件的耗时仅占据整个软件的生命周期的一小部分，在设计软件的时候就应该站在整个软件的生命周期的全过程去考虑。</p>`,35)])])}const u=e(i,[["render",n]]);export{g as __pageData,u as default};
