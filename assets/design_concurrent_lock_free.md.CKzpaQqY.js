import{_ as s,c as i,o as e,ae as t}from"./chunks/framework.Cd-3tpCq.js";const k=JSON.parse('{"title":"无锁并发","description":"","frontmatter":{},"headers":[],"relativePath":"design/concurrent/lock_free.md","filePath":"design/concurrent/lock_free.md"}'),n={name:"design/concurrent/lock_free.md"};function l(r,a,h,p,o,d){return e(),i("div",null,a[0]||(a[0]=[t(`<h1 id="无锁并发" tabindex="-1">无锁并发 <a class="header-anchor" href="#无锁并发" aria-label="Permalink to &quot;无锁并发&quot;">​</a></h1><p>无锁并发技术是在不使用锁的情况下解决并发问题的技术，区别于锁机制，往往性能更加高效。使用锁往往容易导致死锁问题。</p><h2 id="原子操作" tabindex="-1">原子操作 <a class="header-anchor" href="#原子操作" aria-label="Permalink to &quot;原子操作&quot;">​</a></h2><p>依赖于硬件级别的能力，基于原子变量，对单一变量进行并发保证，可以基于此设计无锁队列和无锁环等数据结构，拥有极高的性能，且没有死锁。</p><h2 id="自旋忙等" tabindex="-1">自旋忙等 <a class="header-anchor" href="#自旋忙等" aria-label="Permalink to &quot;自旋忙等&quot;">​</a></h2><p>实现简单，但是延迟较高。CPU 需要一定得消耗。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 8ms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="rcu" tabindex="-1">RCU <a class="header-anchor" href="#rcu" aria-label="Permalink to &quot;RCU&quot;">​</a></h2><p>Read-Copy-Update 机制，在 Linux 系统广泛使用，对于读者来说支持共享读，对于写者来说，自己创建一个副本，然后修改，修改完之后再替换原本的数据，高并发读场景中的无锁利器。但是，写慢读快，延迟回收。</p><h2 id="消息传递" tabindex="-1">消息传递 <a class="header-anchor" href="#消息传递" aria-label="Permalink to &quot;消息传递&quot;">​</a></h2><p>不共享变量，从源头上解决问题</p>`,11)]))}const u=s(n,[["render",l]]);export{k as __pageData,u as default};
