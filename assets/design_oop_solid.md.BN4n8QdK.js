import{_ as i,o as t,c as l,ah as r}from"./chunks/framework.D8J2w7BQ.js";const P=JSON.parse('{"title":"SOLID","description":"","frontmatter":{},"headers":[],"relativePath":"design/oop/solid.md","filePath":"design/oop/solid.md"}'),n={name:"design/oop/solid.md"};function o(d,e,p,a,s,c){return t(),l("div",null,[...e[0]||(e[0]=[r('<h1 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to “SOLID”">​</a></h1><p>字母,英文全称,中文名,一句话核心含义,违反时最典型表现 S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能 O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码 L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱 I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法 D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类</p><p>单一职责原则 (SRP) 不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。 2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。</p><p>开闭原则 (OCP) 软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。 现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。 违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。</p><p>里氏替换原则 (LSP) 子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。 最容易踩的坑（Java/TS 常见）： 子类抛出父类没声明的受检异常 子类方法前置条件变严格（父类允许 null，子类不允许） 子类返回值类型收窄（父类返回 Collection，子类返回 List）</p><p>接口隔离原则 (ISP) 宁可多个小接口，也不要一个胖接口。 现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。 好处：实现类代码量减少，测试更容易 mock。</p><p>依赖倒置原则 (DIP) 最核心的一条，其他几条很多时候都是为它服务的。 高层（业务）不依赖低层（基础设施），都依赖抽象。 现代写法（几乎所有框架默认做法）： 通过构造函数 / Setter 注入接口（依赖注入） 使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析</p><p>违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。</p><p><strong>SOLID 原则</strong> 是面向对象设计中最经典的五条指导原则，由 Robert C. Martin（Uncle Bob）提出。目的是写出<strong>易维护、易扩展、低耦合、高内聚</strong>的代码。</p><table tabindex="0"><thead><tr><th>字母</th><th>英文全称</th><th>中文名</th><th>一句话核心含义</th><th>违反时最典型表现</th></tr></thead><tbody><tr><td>S</td><td>Single Responsibility Principle</td><td>单一职责原则</td><td>一个类/模块只因单一原因而改变</td><td>一个类改动会影响多个不相关功能</td></tr><tr><td>O</td><td>Open-Closed Principle</td><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>加新功能必须改已有核心代码</td></tr><tr><td>L</td><td>Liskov Substitution Principle</td><td>里氏替换原则</td><td>子类能透明替换父类而不破坏程序正确性</td><td>子类重写方法后行为异常 / 前置条件变弱</td></tr><tr><td>I</td><td>Interface Segregation Principle</td><td>接口隔离原则</td><td>不要强迫客户端依赖它不用的接口</td><td>实现一个大接口却只用其中两三个方法</td></tr><tr><td>D</td><td>Dependency Inversion Principle</td><td>依赖倒置原则</td><td>高层模块不依赖低层模块，都依赖抽象</td><td>业务逻辑直接 new 具体数据库/第三方类</td></tr></tbody></table><h3 id="每条原则最务实的理解-现代开发常见场景" tabindex="-1">每条原则最务实的理解 + 现代开发常见场景 <a class="header-anchor" href="#每条原则最务实的理解-现代开发常见场景" aria-label="Permalink to “每条原则最务实的理解 + 现代开发常见场景”">​</a></h3><ol><li><p><strong>单一职责原则 (SRP)</strong></p><ul><li>不是“一个类只能有一个方法”，而是<strong>一个类只服务于一个变化原因 / 一个业务角色</strong>。</li><li>2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。</li></ul></li><li><p><strong>开闭原则 (OCP)</strong></p><ul><li>软件设计终极目标：<strong>新需求主要靠新增代码实现，而不是改旧代码</strong>。</li><li>现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。</li><li>违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。</li></ul></li><li><p><strong>里氏替换原则 (LSP)</strong></p><ul><li>子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。</li><li>最容易踩的坑（Java/TS 常见）： <ul><li>子类抛出父类没声明的受检异常</li><li>子类方法前置条件变严格（父类允许 null，子类不允许）</li><li>子类返回值类型收窄（父类返回 Collection，子类返回 List）</li></ul></li></ul></li><li><p><strong>接口隔离原则 (ISP)</strong></p><ul><li>宁可多个小接口，也不要一个胖接口。</li><li>现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。</li><li>好处：实现类代码量减少，测试更容易 mock。</li></ul></li><li><p><strong>依赖倒置原则 (DIP)</strong></p><ul><li><strong>最核心的一条</strong>，其他几条很多时候都是为它服务的。</li><li>高层（业务）不依赖低层（基础设施），都依赖抽象。</li><li>现代写法（几乎所有框架默认做法）： <ul><li>通过构造函数 / Setter 注入接口（依赖注入）</li><li>使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析</li></ul></li><li>违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。</li></ul></li></ol><h3 id="一句话总结-solid-的真正价值-2026-年视角" tabindex="-1">一句话总结 SOLID 的真正价值（2026 年视角） <a class="header-anchor" href="#一句话总结-solid-的真正价值-2026-年视角" aria-label="Permalink to “一句话总结 SOLID 的真正价值（2026 年视角）”">​</a></h3><p>SOLID 不是让你写更“面向对象”的代码，而是帮你写出<strong>变化成本低、可测试、能长期演进</strong>的代码。</p><p>在微服务、云原生、领域驱动设计、函数式+OO 混合的今天，SOLID 仍然是判断一段代码设计质量的<strong>最重要基准</strong>之一。</p><p>你现在最想看哪一条原则的详细代码例子？</p><ul><li>单一职责（最常违反）</li><li>开闭（最难做好）</li><li>里氏替换（最容易踩坑）</li><li>接口隔离</li><li>依赖倒置（最有工程价值）</li></ul><p>或者你当前项目里哪个地方感觉违反了 SOLID，想具体讨论？</p><h2 id="solid-1" tabindex="-1">SOLID <a class="header-anchor" href="#solid-1" aria-label="Permalink to “SOLID”">​</a></h2><p>字母,英文全称,中文名,一句话核心含义,违反时最典型表现 S,Single Responsibility Principle,单一职责原则,一个类/模块只因单一原因而改变,一个类改动会影响多个不相关功能 O,Open-Closed Principle,开闭原则,对扩展开放，对修改关闭,加新功能必须改已有核心代码 L,Liskov Substitution Principle,里氏替换原则,子类能透明替换父类而不破坏程序正确性,子类重写方法后行为异常 / 前置条件变弱 I,Interface Segregation Principle,接口隔离原则,不要强迫客户端依赖它不用的接口,实现一个大接口却只用其中两三个方法 D,Dependency Inversion Principle,依赖倒置原则,高层模块不依赖低层模块，都依赖抽象,业务逻辑直接 new 具体数据库/第三方类</p><p>单一职责原则 (SRP) 不是“一个类只能有一个方法”，而是一个类只服务于一个变化原因 / 一个业务角色。 2026 年最常见违反：一个 Controller 同时干了参数校验、业务逻辑、数据库操作、发邮件、记录日志、格式化响应 → 应该拆成 Service / Validator / Notifier / Formatter 等。</p><p>开闭原则 (OCP) 软件设计终极目标：新需求主要靠新增代码实现，而不是改旧代码。 现代最常见做法：策略模式 + 插件式扩展、事件总线、规则引擎、配置驱动、装饰器模式、模板方法。 违反典型：大量 if-else 判断类型来决定行为 → 每次加新类型都要改核心类。</p><p>里氏替换原则 (LSP) 子类必须遵守父类的“契约”（前置条件不能变强，后置条件不能变弱，不变量保持）。 最容易踩的坑（Java/TS 常见）： 子类抛出父类没声明的受检异常 子类方法前置条件变严格（父类允许 null，子类不允许） 子类返回值类型收窄（父类返回 Collection，子类返回 List）</p><p>接口隔离原则 (ISP) 宁可多个小接口，也不要一个胖接口。 现代最典型反例：一个超级大的 UserService 接口包含登录、注册、重置密码、权限管理、积分操作、订单查询…… → 应该拆成 AuthService、ProfileService、PointService 等。 好处：实现类代码量减少，测试更容易 mock。</p><p>依赖倒置原则 (DIP) 最核心的一条，其他几条很多时候都是为它服务的。 高层（业务）不依赖低层（基础设施），都依赖抽象。 现代写法（几乎所有框架默认做法）： 通过构造函数 / Setter 注入接口（依赖注入） 使用 IoC 容器（Spring、NestJS、DI in .NET 等）自动解析</p><p>违反典型：Service 里直接 new JdbcTemplate / new RedisTemplate / new HttpClient。</p>',26)])])}const g=i(n,[["render",o]]);export{P as __pageData,g as default};
