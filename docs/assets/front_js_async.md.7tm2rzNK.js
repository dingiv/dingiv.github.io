import{_ as t,c as r,j as a,a as s,o}from"./chunks/framework.CGHvQLJz.js";const P=JSON.parse('{"title":"异步编程","description":"","frontmatter":{},"headers":[],"relativePath":"front/js/async.md","filePath":"front/js/async.md"}'),n={name:"front/js/async.md"};function i(c,e,l,m,d,f){return o(),r("div",null,e[0]||(e[0]=[a("h1",{id:"异步编程",tabindex:"-1"},[s("异步编程 "),a("a",{class:"header-anchor",href:"#异步编程","aria-label":'Permalink to "异步编程"'},"​")],-1),a("p",null,"异步函数，async function(){}，是一个一定返回Promise的函数，它会将函数返回值包裹在一个Promise中。在异步函数中可以使用一个关键字await，在await之前的所有逻辑将同步执行，但是在await之后的代码将被推到异步队列中进行执行。如果await关键字的右值是一个Promise，那么这个Promise会被解包，直至Promise完成时，等待完成后才会进行await之后的逻辑，这也就是为什么await之后的代码会被推到异步队列中的原因。异步函数允许使用近似于同步函数的语法来声明Promise，是一个Promise的语法糖，甚至是上位替代。捕获错误不使用.catch()语法，而是使用try catch语句，更加符合同步函数的语法。",-1),a("p",null,"异步生成器函数，将生成器函数和异步函数结合起来，很大程度上缓解了JS因为单线程限制而被大型任务阻塞的弊病。在异步生成器函数中，可以同时使用await和yield关键字，将大型任务进行异步解决和灵活拆分。",-1)]))}const _=t(n,[["render",i]]);export{P as __pageData,_ as default};
