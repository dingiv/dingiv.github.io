import{_ as i,c as a,a0 as t,o as h}from"./chunks/framework.CGHvQLJz.js";const E=JSON.parse('{"title":"promise","description":"","frontmatter":{},"headers":[],"relativePath":"front/js/basic/promise.md","filePath":"front/js/basic/promise.md"}'),e={name:"front/js/basic/promise.md"};function n(p,s,l,k,r,d){return h(),a("div",null,s[0]||(s[0]=[t(`<h1 id="promise" tabindex="-1">promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;promise&quot;">​</a></h1><p>在浏览器的事件循环中，总是先执行同步任务，然后执行异步任务，在异步任务中，回调函数被保存在了多级队列当中，不过可以简单的认为任务被分为两种队列，宏任务队列和微任务队列。每次执行异步任务时，总是先将微队列中的任务执行完毕之后然后再执行宏任务。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// p0 f0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// p1 f1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// p2 f2 pnew</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// p3 f3</span></span></code></pre></div><h2 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h2><p>构造函数的执行：</p><ol><li>先创建一个Promise实例，pending状态</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span></code></pre></div><p>2.立即执行内部的这个函数，当内部调用<code>s</code>时，完成这个Promise；</p><h2 id="then函数——完成时进队" tabindex="-1">then函数——完成时进队 <a class="header-anchor" href="#then函数——完成时进队" aria-label="Permalink to &quot;then函数——完成时进队&quot;">​</a></h2><p>对于一个Promise，可以调用其then方法，并传入一个回调函数。此时其执行顺序为：</p><ol><li>新建一个新的Promise（p1），其状态取决于其回调函数（f1）是否执行完毕；</li><li>什么时候开始执行回调函数呢？在上一个回调函数完成时，将该回调函数放入微队列中进行等待。此处强调一个非常重要的点，就是<strong>当调用then方法传入了一个回调函数的时候，回调函数还没有进入微队列中，回调函数进入微队列的时机是在当前被then的这个Promise完成的时候。并且就算进了微队列，也不是说回调函数会立即执行，它还需要进行排队才会执行。</strong></li><li>如果回调函数（f2）返回了一个新的Promise（pnew），那么此时该Promise（p2）将不会被完成，即等待该Promise的回调函数（f3）不会在此时进队，取而代之的是，一个匿名的回调函数<code>()=&gt;pnew.then(()=&gt;&#39;完成p2&#39;)</code>进入了队列当中，那么当执行了该匿名回调之后，<code>()=&gt;&#39;完成p2&#39;</code>进队，等待p2完成时，f3才会进队，换言之，f3进队的时机将被推迟两个回调函数。</li></ol><h2 id="异步函数" tabindex="-1">异步函数 <a class="header-anchor" href="#异步函数" aria-label="Permalink to &quot;异步函数&quot;">​</a></h2>`,12)]))}const g=i(e,[["render",n]]);export{E as __pageData,g as default};
