import{_ as a,c as l,o as i,a1 as o}from"./chunks/framework.CceCxLSN.js";const b=JSON.parse('{"title":"算法","description":"","frontmatter":{"title":"算法","order":1},"headers":[],"relativePath":"basic/algo/index.md","filePath":"basic/algo/index.md"}'),r={name:"basic/algo/index.md"},t=o('<h1 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h1><p>从定义来看，算法（algorithm），在数学和计算机科学之中，是指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理和自动推理。算法可以使用条件语句通过各种途径转移代码执行（称为自动决策），并推导出有效的推论（称为自动推理），最终实现自动化。算法是有效方法，包含一系列定义清晰的指令，并可用有限的时间，在有限的空间内清楚地表述出来。</p><p>从功利的角度上讲，算法是指使用计算机技术和编程语言，解决可以通过计算机自动化解决重复问题的方法。它的表现形式依托于具体的计算机语言或者指令，如何编排这些计算机指令就是算研究的主要问题。能够通过计算机算法解决的问题可以被称为算法问题。</p><h2 id="算法问题" tabindex="-1">算法问题 <a class="header-anchor" href="#算法问题" aria-label="Permalink to &quot;算法问题&quot;">​</a></h2><h3 id="算法问题的基本特点" tabindex="-1">算法问题的基本特点 <a class="header-anchor" href="#算法问题的基本特点" aria-label="Permalink to &quot;算法问题的基本特点&quot;">​</a></h3><p>基于有限的、具有一定规模的参数或者输入，使用有限的<strong>时间</strong>和<strong>空间</strong>资源，对这些参数进行处理，然后输出符合指定需求的结果。在这其中，关键的要素包括：<strong>输入、输出、时间资源、空间资源</strong>。算法旨在使用更少的资源，实现更多的输入输出。</p><p>使用计算机编程语言提供的特性，可以将处理算法问题的计算机指令使用编程语言中的<strong>函数</strong>来表示。那么，函数的参数对应的是算法的输入，函数的返回值就是算法的输出，函数执行消耗的时间和内存就是算法的使用资源。对于一个算法问题，可以将其拆分为若干子问题，对应了不同的函数和函数嵌套。</p><h3 id="算法的两个基本的操作——运算和遍历" tabindex="-1">算法的两个基本的操作——<em>运算和遍历</em> <a class="header-anchor" href="#算法的两个基本的操作——运算和遍历" aria-label="Permalink to &quot;算法的两个基本的操作——*运算和遍历*&quot;">​</a></h3><p>运算是指对数据进行算术运算或者逻辑映射，类似于数学公式和数学函数的映射等，遍历是指对规模化的数据进行获取，基于一定的顺序，对批量数据进行挨个处理或者找到满足目标条件的数据。算法通过编排合理的运算和遍历顺序，减少使用的时间和空间资源，从而实现高效。</p><p>从计算机的基本使用的角度（增删改+查或者说读写数据）上来看，算法问题就是如何使用更少的读写次数，更少的计算次数，更少的存储空间，从而实现更高效的输出。其中“查”或者“读”的需求是算法问题中最为常见的，它可以占据所有数据操作的九成。因此，如何高效地查找数据，是算法问题中的大头。而查找就是在遍历，并且查找是要让目标被先遍历到，非目标被后遍历或不遍历。</p><h3 id="算法问题和数学问题的联系和区别" tabindex="-1">算法问题和数学问题的联系和区别 <a class="header-anchor" href="#算法问题和数学问题的联系和区别" aria-label="Permalink to &quot;算法问题和数学问题的联系和区别&quot;">​</a></h3><p>算法问题本质是数学问题，但是存在侧重点的不同。数学问题重视<strong>运算和推理</strong>，而算法问题的推理要求往往较低，且需要额外处理<strong>遍历</strong>操作，数学问题不要处理<strong>遍历</strong>操作。<strong>遍历</strong>操作依赖于<strong>数据结构</strong>和<strong>遍历顺序或方式</strong>。</p><blockquote><p>数学问题通常需要使用数学公式和数学方法来解决，利用推理的手段：分析法（从结论出发倒推条件）和综合法（从条件出发归纳结论），不断地进行等价推理或者单向推理，最终将题目中所给的条件转化为所求结论或答案。其中，数学题目中的<strong>条件</strong>对应于算法问题的<strong>输入</strong>，数学题目中的<strong>结论</strong>对应于算法问题的<strong>输出</strong>。数学问题重在推理，注重的是解题思路和推理过程，解答题目往往需要使用多种公式理论和方法，从而构建逻辑完备的推理链条。</p><p>算法问题是人类使用计算机来解决人类解决不了的问题或者不想亲自解决的问题。准确的说是，<strong>使用冯诺依曼机器，解决大规模或者重复性计算的问题</strong>。在使用计算机的时候不可避免地需要解决两个问题，一个是数据在内存中的存放问题，一个是在大规模数据中快速找到目标的问题。人们在纸上使用数学符号挥斥方遒的时候无需考虑内存和寄存器的大小，而为了让计算机理解它要干的活则必须使用计算机听得懂的方式。</p></blockquote><h2 id="算法模型" tabindex="-1">算法模型 <a class="header-anchor" href="#算法模型" aria-label="Permalink to &quot;算法模型&quot;">​</a></h2><p>数学问题往往可以基于一些数学模型来解决，算法问题也有一些常见的模型和其相应的算法解决方案。</p><p>此处算法模型的分类基于的数据结构的类型和参数的自由度。</p><p>数据结构的类型可以分为：</p><ul><li>线性结构：数组、链表、栈、队列、堆（优先队列）等；</li><li>分支结构：各种树、跳表；</li><li>网络结构：各种图、矩阵；</li></ul><p>参数的自由度是指入参或者出参的数量多少，往往选取其中一个作为分析的思考角度。更进一步说，可以将问题的输入的条件或者输出的结果，归结为一个变量的值，如果输入的条件可以归结为一个变量，那么就是单参数问题，如果输入两个变量，那么就是双参数问题，如果输入多个变量，那么就是多参数问题。输出同理。</p><ul><li>入参：单参数、双参数、多参数；例如，输入一个数组，找一个元素，那么就是单参数入参，这个参数就是遍历这个数组时使用的<code>index</code>，单参数出参，这个参数就是；</li><li>出参：单输出、多输出；</li></ul><h3 id="基于线性结构的算法模型" tabindex="-1">基于线性结构的算法模型 <a class="header-anchor" href="#基于线性结构的算法模型" aria-label="Permalink to &quot;基于线性结构的算法模型&quot;">​</a></h3><ol><li><p>枚举</p><p>枚举法需要遍历所有可能的解，实现简单，时间复杂度一般较高。枚举法可以枚举所有可能的解，从解集中找到满足条件的解，或者从条件集中出发，重复寻找所有满足条件的解。是处理线性结构问题的基础，后续的算法可以基于枚举法进行优化。</p></li><li><p>双指针</p><p>双指针遍历，基于<strong>同时管理两个指针</strong>的遍历方式，可以减少遍历次数，从而降低时间复杂度。双指针遍历可以基于数组、链表、字符串等线性结构，也可以基于哈希表等非线性结构。双指针具体在操作的时候可以有很多不同的方式，例如左右指针、滑动窗口、快慢指针等。其主要特征是题目中具有两个参数。</p><p>题目中关键词：子数组、两个数组、区间等等；</p></li><li><p>二分法</p><p>二分法是一种<strong>在有序数组中查找目标值</strong>的方法，其时间复杂度为O(logn)。二分法的基本思想是将数组分成两部分，然后根据目标值的大小，选择其中一部分继续查找，直到找到目标值或者查找范围为空。二分法可以用于解决一些查找问题，例如查找有序数组中的目标值、查找有序数组中的第k小的元素等等。</p><p>题目中关键词：有序、查找、第k小的元素、最大化最小值、最小化最大值、单调等等；</p></li><li><p>贪心法</p><p>贪心法是一种遍历策略，在遍历时，有导向地选择在当前状态下最好或最优的选择进行优先遍历，忽略某些路径，跳过不必要的遍历，并且依然能够找到目标或最优结果的算法。贪心法需要我们提前知道：局部选择是否能导致全局最优。这往往要求题目具有一定的数学性质，例如最优子结构、无后效性、单调性等。</p><p>题目中关键词：最优、单调性等等；</p></li></ol><h3 id="基于平面结构的算法模型" tabindex="-1">基于平面结构的算法模型 <a class="header-anchor" href="#基于平面结构的算法模型" aria-label="Permalink to &quot;基于平面结构的算法模型&quot;">​</a></h3><ol><li><p>dfs 深度优先搜索</p></li><li><p>bfs 广度优先搜索</p></li><li><p>拓扑排序</p></li><li><p>最短路径</p></li><li><p>最小生成树</p></li><li><p>二分图</p></li><li><p>连通分量</p></li><li><p>基环树</p></li><li><p>欧拉回路</p></li></ol><h3 id="使用数据结构辅助的算法模型" tabindex="-1">使用数据结构辅助的算法模型 <a class="header-anchor" href="#使用数据结构辅助的算法模型" aria-label="Permalink to &quot;使用数据结构辅助的算法模型&quot;">​</a></h3><p>使用特殊地数据结构保存计算中的中间结果，从而减少重复计算和获取数据的时间，降低时间复杂度，但是这往往会引入额外的空间复杂度。这给我们带来一个启示，就是<strong>空间换时间</strong>，不要重复地去遍历，而是尽量在一次遍历中获知更多的信息，使用合理的数据结构来记录这些信息，从而加快遍历。</p><ol><li>栈</li><li>队列</li><li>堆</li><li>哈希</li><li>并查集</li><li>字典树</li><li>线段树</li></ol><h3 id="使用数学技巧辅助的算法模型" tabindex="-1">使用数学技巧辅助的算法模型 <a class="header-anchor" href="#使用数学技巧辅助的算法模型" aria-label="Permalink to &quot;使用数学技巧辅助的算法模型&quot;">​</a></h3><p>我们可以使用数学技巧来优化算法，例如使用数学公式、数学定理、数学性质等等。这些技巧可以帮助我们找到更优的算法解决方案，从而降低时间复杂度和空间复杂度。</p><ol><li><p>前缀和</p></li><li><p>差分</p></li><li><p>dp 动态规划</p><p>动态规划是一种通过将问题分解为子问题，并将子问题的解存储起来，从而避免重复计算的方法。动态规划通常用于解决一些具有重叠子问题和最优子结构的问题，例如背包问题、最长公共子序列问题、最长递增子序列问题等等。</p></li><li><p>位运算</p></li><li><p>排列组合</p></li><li></li></ol><h3 id="基于字符串的算法模型" tabindex="-1">基于字符串的算法模型 <a class="header-anchor" href="#基于字符串的算法模型" aria-label="Permalink to &quot;基于字符串的算法模型&quot;">​</a></h3><p>字符串算法是非常常见的算法问题，包括字符串的遍历、查找、替换、匹配、排序等等，主要是<strong>查找和匹配</strong>。字符串算法的时间复杂度通常较高，需要使用一些特定的技巧来优化。</p><h4 id="查找" tabindex="-1">查找 <a class="header-anchor" href="#查找" aria-label="Permalink to &quot;查找&quot;">​</a></h4><ul><li>KMP</li><li>Z算法</li><li>Manacher</li><li></li></ul><h4 id="匹配" tabindex="-1">匹配 <a class="header-anchor" href="#匹配" aria-label="Permalink to &quot;匹配&quot;">​</a></h4><ul><li>自动机</li><li>Trie</li></ul>',36),e=[t];function n(p,s,h,d,c,g){return i(),l("div",null,e)}const q=a(r,[["render",n]]);export{b as __pageData,q as default};
